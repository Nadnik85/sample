| - kissassist.mac v10.2.5 by Maskoi 02/25/2018.
| - Contributions by anonymoushero, crystane, eqmule, thenomadman, william12.
| - ChainPull, Debuffs and combat rewrites by ctaylor22.
| - PetTank, PullerPetTank & HunterPetTank roles developed by TreeHuginDruid
| - KISS Assist - A simple multi class macro
| Requires plugins* MQ2Cast, MQ2Exchange, MQ2Melee, MQ2MoveUtils, MQ2Posse, MQ2Rez, & MQ2Twist (Bards), MQ2Gmail, Extended Target Window and ninjadvloot.inc file.
| Usage - /mac kissassist assist TankName 95
| or target Main Tank and /mac kissassist assist
| This macro was written exclusively for subscribers of Redguides.com
| -------------------------------------------------------------------------------------
| Special Thanks to: 
|                    
|
#warning
#turbo 120
#include ninjadvloot.inc
| #DEFINE /squelch " "
|****************************************| GENERAL EVENTS |***********************************************|
#Event Camping           "#*#seconds to prepare your camp."
#Event EQBCIRC           "<#1#> #2#"
#Event FSEQBC            "#1# tells the fellowship, #2#"
#Event GUEQBC            "#1# tells the guild, #2#"
#Event GainSomething     "#*#You have gained|#1#|"
#Event GotHit            "#1# bashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# bites YOU for #*# points of damage.#*#"
#Event GotHit            "#1# crushes YOU for #*# points of damage.#*#"
#Event GotHit		     "#1# gores YOU for #*# points of damage.#*#"
#Event GotHit            "#1# hits YOU for #*# points of damage.#*#"
#Event GotHit            "#1# kicks YOU for #*# points of damage.#*#"
#Event GotHit            "#1# mauls YOU for #*# points of damage.#*#"
#Event GotHit            "#1# pierces YOU for #*# points of damage.#*#"
#Event GotHit            "#1# punches YOU for #*# points of damage.#*#"
#Event GotHit		     "#1# rampages YOU for #*# points of damage.#*#" 
#Event GotHit		     "#1# smashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# slashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# tries to #*# YOU, but #*#"
#Event Invised           "You Vanish #*#"
#Event Joined            "#1# has joined the group."
#Event KTDismount        "[MQ2] KTDismount#*#"
#Event KTDoorClick       "[MQ2] KTDoorClick #1#"
#Event KTDoorClick       "[MQ2] KTDoorClick#*#"
#Event KTHail            "[MQ2] KTHail #1#"
#Event KTInvite          "[MQ2] KTInvite #1#"
#Event KTSay             "[MQ2] KTSay #1#"
#Event KTTarget          "[MQ2] KTTarget #1#"
#Event LeftGroup         "#1# has left the group."
#Event MezBroke          "#1# has been awakened by #2#."
#Event Missing           "#*#You are missing some required components.#*#"
#Event PTaunt            "#*#Taunting attackers as normal, Master.#*#"
#Event PetSusStateAdd1   "#*# tells you, 'By your command, master.#*#"
#Event PetSusStateAdd2   "#*#You cannot have more than one pet at a time.#*#"    
#Event PetSusStateSub    "#*# tells you, 'I live again...'#*#"
#Event PetToysPlease     "#*#PetToysPlease #1#"
#Event TaskUpdate        "#*#Your task |#1#| has been updated#*#"
#Event Timer             Timer1
#Event TooSteep          "The ground here is too steep to camp"  
#Event WornOff           "Your #1# spell has worn off of #2#."
#Event Zoned             "LOADING, PLEASE WAIT#*#"
#Event Zoned             "You have entered#*#"
|****************************************| COMBAT EVENTS |***********************************************|
#Event Banestrike        "Your Banestrike fails because you have not yet mastered slaying this race."
#Event Burn              "[MQ2] |${BurnText}|"
#Event CantHit           "You can't hit them from here."
#Event CantSee           "You cannot see your target."
#Event GoMOff            "The gift of magic fades."
#Event GoMOff            "Your#*#gift of#*#mana fades."
#Event GoMOn             "#*#granted#*#gift of#*#mana#*#"
#Event GoMOn             "You feel strengthened by a gift of magic."
#Event GoMOn             "You feel strengthened by magic."
#Event ImDead            "#*#Returning to Bind Location#*#"
#Event ImDead            "You died."
#Event ImDead            "You have been slain by#*#"
#Event TooClose          "Your target is too close to use a ranged weapon!"
#Event TooFar            "Your target is too far away, get closer!"
#Event YouHit            "#1# has taken #2# damage from your #3#."
#Event YouHit            "#1# was hit by non-melee for #2# points of damage."
#Event YouHit            "You backstab #1# for #2# points of damage."
#Event YouHit            "You bash #1# for #2# points of damage."
#Event YouHit            "You bite #1# for #2# points of damage."
#Event YouHit            "You claw #1# for #2# points of damage."
#Event YouHit            "You crush #1# for #2# points of damage."
#Event YouHit            "You frenzy on #1# for #2# points of damage."
#Event YouHit            "You hit #1# for #2# points of damage."
#Event YouHit            "You kick #1# for #2# points of damage."
#Event YouHit            "You maul #1# for #2# points of damage."
#Event YouHit            "You pierce #1# for #2# points of damage."
#Event YouHit            "You punch #1# for #2# points of damage."
#Event YouHit            "You slash #1# for #2# points of damage."
#Event YouHit            "You slice #1# for #2# points of damage."
#Event YouHit            "You sting #1# for #2# points of damage."
#Event YouHit            "You strike #1# for #2# points of damage."
#Event YouHit            "You try to #*#, but miss"
#Event YouHit            "|${Me.Pet.CleanName}| backstabs #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| bashes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| bitess #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| claws #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| crushes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| frenzies on #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me.Pet.CleanName}| hits #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| kicks #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| mauls #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| pierces #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| punches #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| slashes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| slices #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| stings #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| strikes #1# for #2# points of damage."
#Event YouHit            "|${Me}| hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me}|`s pet backstabs #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet bashes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet bites #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet claws #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet crushes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet frenzies on #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me}|`s pet hits #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet kicks #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet mauls #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet pierces #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet punches #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet slashes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet slices #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet stings #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet strikes #1# for #2# points of damage."
| -------------------------------------------------------------------------------------
| New Binds to replace old Events
| -------------------------------------------------------------------------------------
#bind AddAFriend     /addfriend
#bind AddMezImmune   /addimmune
#bind AddToIgnore    /addignore
#bind AddToPull      /addpull
#bind BackOff        /backoff
#bind Burn           /burn
#bind Campfire       /campfire
#bind ChangeVarInt   /changevarint
#bind ChaseMe        /chaseme
#bind DebugAll       /debugall
#bind IniWrite       /iniwrite
#bind KissCheck      /kisscheck
#bind KissE          /kissedit
#bind MemMySpells    /memmyspells
#bind Parse          /parse
#bind Switch         /switchnow
#bind SwitchMA       /switchma
#bind ToggleVariable /togglevariable
#bind TrackMeDown    /trackmedown
#bind WriteMySpells  /writespells
#bind ZoneInfo       /zoneinfo
| -------------------------------------------------------------------------------------
| Sub Main
| -------------------------------------------------------------------------------------
Sub Main
    /doevents flush
    | Define debug variables before everything else
    /declare Debug                  int         outer       0
    /declare DebugAllOn             int         outer       0
    /declare DebugBuffs             int         outer       0
    /declare DebugCombat            int         outer       0
    /declare DebugHeal              int         outer       0
    /declare DebugMez               int         outer       0
    /declare DebugMove              int         outer       0
    /declare DebugPet               int         outer       0
    /declare DebugPull              int         outer       0
    /declare DebugRK                int         outer       0
    /declare CampXLoc               int         outer       ${Me.X}
    /declare CampYLoc               int         outer       ${Me.Y}
    /declare CampZLoc               int         outer       ${Me.Z}
    /declare LookForward            int         outer       ${Me.Heading.DegreesCCW}
    |/delay 5s
    | Need to check for plugin MQ2Bucles and unload it. Do this ASAP so can use /while commands from the start
    /if (${Bool[${Plugin[MQ2Bucles]}]}) {
        /squelch /plugin MQ2Bucles unload noauto
        /echo MQ2Bucles detected! This macro doesn't like it! Unloading ...
    }
    | ini file fix for zones with commas in them
    /declare ZoneName string outer ${Zone}${If[${Me.InInstance},_I,]}
    /if (${ZoneName.Find[,]} || ${ZoneName.Find[']} ) {
        /echo ${ZoneName} has a comma or apostrophe in the name, setting Zone Short Name ...
        /varset ZoneName ${Zone.ShortName}${If[${Me.InInstance},_I,]}
    }
    /declare MacroName              string      outer       KissAssist
    /declare MacroVer               string      outer       10.2.5
    /declare IniFileName            string      outer         
    /declare InfoFileName           string      outer       ${MacroName}_Info.ini
    /declare ConditionsFileName     string      outer       
    /declare BuffFileName           string      outer       ${MacroName}_Buffs.ini
    /declare PIniSet                int         outer       0
    /declare pi                     int         local       0
    /declare NumParams              int         local       0
    /declare GoMTimer               timer       outer       0
    | Check for command line variables
    /if (${Macro.Params}) {
        /echo There is ${Macro.Params} command line parameter(s)
        /varset NumParams ${Math.Calc[${Macro.Params}-1]}
        /for pi 0 to ${NumParams}
            /if (${Defined[Param${pi}]}) {
                /echo P${pi}: ${Param${pi}}
                /declare PParam${pi} string outer ${Param${pi}}
            }
        /next pi
        /call PParse 0 ${NumParams}
    }
    | if Kiss finds a Kissassist_ServerName_ToonName.ini file it will use that one
    /if (!${PIniSet}) {
        /if (${Ini[${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini,General,KissAssistVer].Length}) {
            /varset IniFileName ${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini
            /echo Server Name ini file detected using ${IniFileName}
        } else {
            /varset IniFileName ${MacroName}_${Me.CleanName}.ini
        }  
    }
    /declare KissAssistVer          string      outer       ${Ini[${IniFileName},General,KissAssistVer]}
    /if (${Debug}) /echo ${IniFileName} ${KissAssistVer} \agLine#: ${Macro.CurLine}
    /if (!${Ini[${IniFileName},General,KissAssistVer].Length}) /ini "${IniFileName}" "General" "KissAssistVer" "0.0"
| ************************* Aliases **************************************|
    /if (${Debug}) /echo \atDEBUG Ini/Alias info ${KissAssistVer.NotEqual[${MacroVer}]} "${KissAssistVer}" "${MacroVer}" \agLine#: ${Macro.CurLine}
    /if (${KissAssistVer.NotEqual[${MacroVer}]}) {
        /echo Version Mismatch Detected, Writing Aliases this can take up to 1 min
        /squelch /alias /afktoolson     /changevarint AFKTools AFKToolsOn
        /squelch /alias /assistat       /changevarint Melee AssistAt
        /squelch /alias /autofireon     /togglevariable AutoFireOn
        /squelch /alias /autorezon      /togglevariable AutoRezOn
        /squelch /alias /buffson        /togglevariable BuffsOn
        /squelch /alias /camphere       /togglevariable ReturnToCamp
        /squelch /alias /campradius     /changevarint General CampRadius
        /squelch /alias /chase          /togglevariable ChaseAssist
        /squelch /alias /chasedistance  /changevarint General ChaseDistance
        /squelch /alias /chaseoff       /changevarint General ChaseAssist 0        
        /squelch /alias /chaseon        /changevarint General ChaseAssist 1 
        /squelch /alias /conditions     /togglevariable conditions
        /squelch /alias /conditionsoff  /togglevariable conditions off
        /squelch /alias /conditionson   /togglevariable conditions on
        /squelch /alias /debug          /togglevariable Debug
        /squelch /alias /debugbuffs     /togglevariable DebugBuffs
        /squelch /alias /debugcombat    /togglevariable DebugCombat
        /squelch /alias /debugheal      /togglevariable DebugHeal
        /squelch /alias /debugmez       /togglevariable DebugMez
        /squelch /alias /debugmove      /togglevariable DebugMove
        /squelch /alias /debugpull      /togglevariable DebugPull
        /squelch /alias /debugrk        /togglevariable DebugRK
        /squelch /alias /dpsinterval    /changevarint DPS DPSInterval
        /squelch /alias /dpsmeter       /togglevariable DPSMeter
        /squelch /alias /dpson          /changevarint DPS DPSOn
        /squelch /alias /dpsskip        /changevarint DPS DPSSkip
        /squelch /alias /dpsspam        /togglevariable DPSSpam
        /squelch /alias /dpswrite       /togglevariable DPSWriteOn
        /squelch /alias /healson        /changevarint Heals HealsOn   
        /squelch /alias /interrupton    /togglevariable CastingInterruptOn     
        /squelch /alias /ktdismount     /echo KTDismount
        /squelch /alias /ktdoor         /echo KTDoorClick        
        /squelch /alias /kthail         /echo KTHail
        /squelch /alias /ktinvite       /echo KTInvite
        /squelch /alias /ktsay          /echo KTSay
        /squelch /alias /kttarget       /echo KTTarget  
        /squelch /alias /looton         /changevarint General LootOn
        /squelch /alias /maxradius      /changevarint Pull MaxRadius
        /squelch /alias /maxzrange      /changevarint Pull MaxZRange
        /squelch /alias /medcombat      /togglevariable MedCombat
        /squelch /alias /medstart       /changevarint General MedStart
        /squelch /alias /meleedistance  /changevarint Melee MeleeDistance
        /squelch /alias /meleeon        /togglevariable MeleeOn
        /squelch /alias /mercassistat   /changevarint Merc MercAssistAt
        /squelch /alias /mezon          /changevarint Mez MezOn
        /squelch /alias /movewhenhit    /togglevariable MoveWhenHit 
        /squelch /alias /pethold        /togglevariable PetHold
        /squelch /alias /peton          /togglevariable PetOn
        /squelch /alias /pettoyson      /togglevariable PetToysOn
        /squelch /alias /pettoysplz     /echo PetToysPlease
        /squelch /alias /rebuffon       /togglevariable RebuffOn
        /squelch /alias /returntocamp   /togglevariable ReturnToCamp
        /squelch /alias /scatteron      /togglevariable ScatterOn
        /squelch /alias /setae          /iniwrite AE
        /squelch /alias /setaggro       /iniwrite Aggro
        /squelch /alias /setbackoff     /backoff
        /squelch /alias /setbuffs       /iniwrite Buffs
        /squelch /alias /setburn        /iniwrite Burn
        /squelch /alias /setcure        /iniwrite Cure
        /squelch /alias /setdps         /iniwrite DPS
        /squelch /alias /setheals       /iniwrite Heals
        |/squelch /alias /switchma       /switchma
        /squelch /alias /trackme        /trackmedown
        /ini "${IniFileName}" "General" "KissAssistVer" "${MacroVer}"
    }
    /if (${Debug}) /echo \atDEBUG Aliases processed  \agLine#: ${Macro.CurLine}
| ************************* General **************************************|
    | Edit settings in your KissAssist_ToonName.ini file
    /echo Loading INI Info
    | Only call role from ini if not defined in command line from hot key
    /if (!${Defined[Role]}) /call LoadIni General Role                  string      Assist
    /call LoadIni General CampRadius            int         30
    /call LoadIni General CampRadiusExceed      int         400
    /call LoadIni General ReturnToCamp          int         0
    /call LoadIni General ChaseAssist           int         0
    /call LoadIni General ChaseDistance         int         25
    /call LoadIni General MedOn                 int         1
    /call LoadIni General MedStart              int         20
    /call LoadIni General MedCombat             int         0
    /call LoadIni General LootOn                int         0
    /call LoadIni General RezAcceptOn           string      0|98
    /call LoadIni General AcceptInvitesOn       int         1
    /call LoadIni General GroupWatchOn          string      0
    /call LoadIni General CastingInterruptOn    int         0
    /declare GroupWatchPct int outer 20
    /if (${GroupWatchOn.Find[|]}) {
        /varset GroupWatchPct ${GroupWatchOn.Arg[2,|]}
        /varset GroupWatchOn ${GroupWatchOn.Arg[1,|]}
    }
    /call LoadIni General EQBCOn                string      0
    /declare EQBCSay                            string      outer   bc
    /if (${EQBCOn.Arg[2,|].Length} && ${EQBCOn.Arg[1,|].Equal[2]}) {
        /if (${Debug}) /echo ${EQBCOn} ${EQBCOn.Arg[1,|]} ${EQBCOn.Arg[2,|]} \agLine#: ${Macro.CurLine}
        /varset EQBCSay bct ${EQBCOn.Arg[2,|]}
        /varset EQBCOn 2
    }
    /call LoadIni General IRCOn                 int         0
    /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}==0) {
        /call LoadIni General MiscGem               int         8
        /call LoadIni General MiscGemLW             int         0
        /call LoadIni General MiscGemRemem          int         1
    } else {
        /declare MiscGem                            int         outer   0
        /declare MiscGemLW                          int         outer   0  
        /declare MiscGemRemem                       int         outer   0
    }
    /call LoadIni General HoTTOn                int         0
    /call LoadIni General CampfireOn            int         0 
    /if (${Int[${Ini[${IniFileName},General,CharInfo].Arg[2,|]}]}!=${Me.Level}) /ini "${IniFileName}" "General" "CharInfo" "${Me.Class}|${Me.Level}|${Me.Subscription}"
    /if (${Int[${Ini[${IniFileName},General,DefaultUI].Arg[1,|]}]}!=${EverQuest.CurrentUI.Equal[Default]}) /ini "${IniFileName}" "General" "DefaultUI" "${If[${EverQuest.CurrentUI.Equal[Default]},TRUE,FALSE|Custom UIs are not supported. Please switch to Default UI before posting bugs.]}"
    /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
        /call LoadIni General GroupEscapeOn        int         0
    } else {
        /declare GroupEscapeOn                     int         outer    0
    }
    /call LoadIni General DPSMeter              int         1
    /call LoadIni General ScatterOn             int         0
    /call LoadIni General ConditionsOn          int         0
    /if (${ConditionsOn}) {
        /if (${ConditionsOn}==1) {
            /varset ConditionsFileName ${IniFileName.Replace[.ini,]}_Conditions.ini
        } else {
            /varset ConditionsFileName ${IniFileName}
        }
    }
| ************************* SpellSet *************************************|
    /call LoadIni SpellSet LoadSpellSet          int         0
    /call LoadIni SpellSet SpellSetName          string      "KissAssist"   
| ************************* Buffs ****************************************|
    /call LoadIni Buffs BuffsOn                 int         0
    /call LoadIni Buffs BuffsCOn                int         0          NULL         FALSE          "${ConditionsFileName}"
    /call LoadIni Buffs BuffsSize               int         20
    /declare Buffs[${BuffsSize}]                string      outer
    /declare BuffsCond[${BuffsSize}]            string      outer      TRUE
    /call LoadIni Buffs Buffs                   string      NULL       Buffs        BuffsCond      "${IniFileName}" "${ConditionsFileName}"
    /call LoadIni Buffs RebuffOn                int         1
    /call LoadIni Buffs CheckBuffsTimer         int         10
    /call LoadIni Buffs PowerSource             string      NULL
| ************************* Melee ****************************************|
    /call LoadIni Melee AssistAt                int         95
    /if (${Select[${Me.Class.ShortName},BST,BER,MNK,PAL,RNG,ROG,SHD,WAR]}) {
        /call LoadIni Melee MeleeOn             int         1
    } else {
        /call LoadIni Melee MeleeOn             int         0
    }
    /call LoadIni Melee FaceMobOn               int         1
    /call LoadIni Melee MeleeDistance           int         75
    /call LoadIni Melee StickHow                string      "snaproll rear"
    /call LoadIni Melee AutoFireOn              int         0
    /call LoadIni Melee UseMQ2Melee             int         1
    /if (${Select[${Me.Class.ShortName},BER]}) {
        /call LoadIni Melee BeforeCombat        string      "Cast Before Melee Disc"
    } else {
        /declare BeforeCombat                    string         outer 0
    }
    /if (${Select[${Me.Class.ShortName},ROG]}) {
        /call LoadIni Melee AutoHide            int         1
    } else {
        /declare AutoHide                        int         outer 0
    }
| ************************* GoM ****************************************|
    /if (!${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
        /call LoadIni GoM GoMSHelp              string       "Format - Spell|Target, MA Me or Mob, i.e. Rampaging Servant Rk. II|Mob"
        /call LoadIni GoM GoMCOn                int         0          NULL         FALSE          "${ConditionsFileName}"
        /call LoadIni GoM GoMSize               int         3
        /declare GoMSpell[${GoMSize}]           string      outer
        /declare GoMCond[${GoMSize}]            string      outer       TRUE
        |string       sectionName, varName,     varType,    varValue,  varArray,    varArray2,     FileName,        FileName2
        /call LoadIni GoM GoMSpell              string      NULL       GoMSpell     GoMCond        "${IniFileName}" "${ConditionsFileName}"  
    } else {
        /declare GoMSize                           int         outer 1
        /declare GoMSpell[${GoMSize}]           string      outer
    }
| ************************* Gmail ****************************************|
    /call LoadIni GMail GMailHelp              string       "Events currently support - Dead,Drag,GM,Level,Named,Leftgroup"
    /call LoadIni GMail GMailOn                int         0
    /call LoadIni GMail GMailSize              int         5
    /declare GMail[${GMailSize}]               string        outer
    /call LoadIni GMail GMail                  string        NULL       GMail
| *************************  AE ******************************************|
    /call LoadIni AE AEOn                       int         0
    /call LoadIni AE AECOn                      int         0          NULL         FALSE          "${ConditionsFileName}"
    /call LoadIni AE AESize                     int         10
    /call LoadIni AE AERadius                   int         50
    /declare AE[${AESize}]                      string      outer
    /declare AECond[${AESize}]                  string      outer      TRUE
    /call LoadIni AE AE                         string      NULL       AE           AECond         "${IniFileName}" "${ConditionsFileName}"
| ************************* DPS ******************************************|
    /call LoadIni DPS DPSOn                     int         0
    /call LoadIni DPS DPSCOn                    int         0           NULL          FALSE           "${ConditionsFileName}"
    /call LoadIni DPS DPSSize                   int         20
    /call LoadIni DPS DPSSkip                   int         20
    /call LoadIni DPS DPSInterval               int         2
    /declare DPS[${DPSSize}]                    string      outer
    /declare DPSCond[${DPSSize}]                string      outer       TRUE
    |string       sectionName, varName,         varType,    varValue,   varArray,     varArray2,     FileName,        FileName2
    /call LoadIni DPS DPS                       string      NULL        DPS           DPSCond        "${IniFileName}" "${ConditionsFileName}"
    /call LoadIni DPS DebuffAllOn               int         0
| ************************* Aggro ******************************************|
    /call LoadIni Aggro AggroOn                 int         0
    /if (${Select[${Me.Class.ShortName},SHD,WAR,PAL]})  {
        /call LoadIni Aggro AggroSize           int         10
    } else {
        /call LoadIni Aggro AggroSize           int         5
    }
    /declare Aggro[${AggroSize}]                string      outer
    /declare AggroCond[${AggroSize}]            string      outer       TRUE
    /call LoadIni Aggro Aggro                   string      NULL        Aggro         AggroCond      "${IniFileName}" "${ConditionsFileName}"
| ************************* Bard *****************************************|
    /declare IAmABard                           bool        outer          ${Me.Class.Name.Equal[Bard]}
    /if (${IAmABard}) {
        /call LoadIni General TwistOn           int         0
        /call LoadIni General TwistMed          int         "Mana song gem"
        /call LoadIni General TwistWhat         string      "Twist order here"
        /call LoadIni Melee MeleeTwistOn        int         0
        /call LoadIni Melee MeleeTwistWhat      string      "DPS twist order here"
        /call LoadIni Pull PullTwistOn          int         0
    } else {
        /declare TwistOn                        int        outer       0
        /declare MeleeTwistOn                   int        outer       0 
        /declare PullTwistOn                    int        outer       0 
        /declare TwistWhat                      string     outer       0
        /declare MeleeTwistWhat                 string     outer       0
        /declare TwistMed                       int        outer       0
    }
| ************************* Heals ***************************************|
    /call LoadIni Heals Help                    string      "Format Spell|% to heal at i.e. Devout Light Rk. II|50"
    /call LoadIni Heals HealsOn                 int         0
    /call LoadIni Heals HealsCOn                int         0           NULL          FALSE           "${ConditionsFileName}"
    /if (${Select[${Me.Class.ShortName},CLR,SHM,DRU,PAL]})  {
        /call LoadIni Heals HealsSize           int         15
    } else {
        /call LoadIni Heals HealsSize           int         5
    }
    /declare Heals[${HealsSize}]                string      outer
    /declare HealsCond[${HealsSize}]            string      outer       TRUE
    /call LoadIni Heals Heals                   string      NULL        Heals         HealsCond      "${IniFileName}" ${ConditionsFileName} 
    /call LoadIni Heals XTarHeal                int         0
    /call LoadIni Heals XTarHeal2               int         0
    /if (${Select[${Me.Class.ShortName},CLR,NEC,SHM,DRU,PAL]}) {
        /call LoadIni Heals AutoRezOn           int         0
        /call LoadIni Heals AutoRezWith         string      "Your Rez Item/AA/Spell"
    } else {
        /declare AutoRezOn                        int          outer       0
    }
    /call LoadIni Heals HealGroupPetsOn         int         0
| ************************* Cures ***************************************|
    /call LoadIni Cures CuresOn                 int         0
    /call LoadIni Cures CuresSize               int         5
    /declare Cures[${CuresSize}]                string      outer
    /call LoadIni Cures Cures                   string      NULL        Cures
| ************************* Pet *****************************************|
    /if (${Select[${Me.Class.ShortName},DRU,SHM,BST,ENC,MAG,NEC,SHD]}) {
        /call LoadIni Pet PetOn                 int         0
        /call LoadIni Pet PetSpell              string      "YourPetSpell"
        /if (${Select[${Me.Class.ShortName},BST,MAG,NEC]})  {
            /call LoadIni Pet PetFocus   string  "NULL"
        } else {
                /declare PetFocus string outer NULL
        }
        /call LoadIni Pet PetShrinkOn           int         0
        /call LoadIni Pet PetShrinkSpell        string      "Tiny Companion"
        /call LoadIni Pet PetBuffsOn            int         0
        /call LoadIni Pet PetBuffsSize          int         8
        /declare PetBuffs[${PetBuffsSize}]      string      outer
        /call LoadIni Pet PetBuffs              string      NULL    PetBuffs
        /call LoadIni Pet PetCombatOn           int         1
        /call LoadIni Pet PetAssistAt           int         95          
        /declare PetToysDone                    int         outer   0
        /call LoadIni Pet PetToysSize           int         6
        /declare PetToys[${PetToysSize}]        string      outer
        /if (${Select[${Me.Class.ShortName},MAG]}) {
            /call LoadIni Pet PetToysOn         int         0
            /call LoadIni Pet PetToys           string      NULL    PetToys
            /call LoadIni Pet PetToysGave       string      NULL
        } else {
                /declare PetToysGave            string      outer   NULL
                /declare PetToysOn              int         outer   0
        }
        /call LoadIni Pet PetBreakMezSpell    string      NULL
        /call LoadIni Pet PetRampPullWait       int         0  
        /call LoadIni Pet PetSuspend            int         0
        /call LoadIni Pet MoveWhenHit           int         0
        /call LoadIni Pet PetHoldOn             int         1
        /declare PetHold                        string     outer
        /if (${Me.AltAbility[Pet Discipline]}>=1) {
            /if (${Me.AltAbility[Pet Discipline]}<=5)      /varset PetHold hold
            /if (${Me.AltAbility[Pet Discipline]}>=6)      /varset PetHold ghold
        }
        /call LoadIni Pet PetForceHealOnMed     int         0
    } else {
        /declare PetForceHealOnMed              int         outer   0
        /declare PetOn                          int         outer   0
        /declare PetAssistAt                    int         outer   0
        /declare PetCombatOn                    int         outer   0
        /declare PetRampPullWait                int         outer   0
        /declare PetHoldOn                      int         outer   0
        /declare PetHold                        string      outer   0
    }
| ************************* Mez *****************************************|
    /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
        /call LoadIni Mez MezOn                 int         0
        /call LoadIni Mez MezRadius             int         50
        /call LoadIni Mez MezMinLevel           int         "Min Mez Spell Level"
        /call LoadIni Mez MezMaxLevel           int         "Max Mez Spell Level"
        /call LoadIni Mez MezStopHPs            int         80
        /call LoadIni Mez MezSpell              string      "Your Mez Spell"
        | necros can't AE mez
        /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
            /call LoadIni Mez MezAESpell        string      "Your AE Mez Spell|0"
            /declare MezAECount                 int         outer   ${MezAESpell.Arg[2,|]}
            /varset MezAESpell                  ${MezAESpell.Arg[1,|]}
        }
        /declare MezCount[13]                   int         outer 0
        /declare MezAEClosest                   int         outer 0
    } else {
        /declare MezOn                          int         outer 0
    }
        | This loads and declares the MezImmune var
        /call LoadIni "${ZoneName}" MezImmune string "List up to 10 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL False ${InfoFileName}

| ************************* Burn ****************************************|
    /call LoadIni Burn  BurnCOn                 int         0           Null          FALSE            "${ConditionsFileName}"
    /call LoadIni Burn  BurnSize                int         15
    /declare Burn[${BurnSize}]                  string      outer
    /declare BurnCond[${BurnSize}]              string      outer   TRUE
    /call LoadIni Burn  BurnText                string      "Decepticons Attack"
    /call LoadIni Burn  BurnAllNamed            int         0
    /call LoadIni Burn  Burn                    string      NULL        Burn          BurnCond        "${IniFileName}" "${ConditionsFileName}"
    /call LoadIni Burn  UseTribute              int         0
| ************************* Pull ****************************************|
    /call LoadIni Pull PullWith                 string      "Melee"
    /call LoadIni Pull PullMeleeStick           int         0
    /call LoadIni Pull MaxRadius                int         350
    /call LoadIni Pull MaxZRange                int         50
    /call LoadIni Pull UseWayPointZ             int         0
    /call LoadIni Pull PullWait                 int         5
    /call LoadIni "${ZoneName}" MobsToPull string "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or ALL for all mobs" NULL False ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToIgnore string "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL False ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToBurn string "List up to 10 mobs. Use full names i.e. Beget Cube,Helias,Raze or NULL" Null False ${InfoFileName}
    /call LoadIni "${ZoneName}" PullPath string "Place holder for path file. Not yet impletmented." NULL False ${InfoFileName}
    /call LoadIni Pull PullRadiusToUse          int         90
    /call LoadIni Pull PullRoleToggle           int         0
    /call LoadIni Pull ChainPull                int         0
    /call LoadIni Pull ChainPullHP              int         90
    /call LoadIni Pull ChainPullPause           string      30|2
    /call LoadIni Pull PullLevel                string      0|0
    | /call LoadIni Pull PullPath               string      NULL
| ************************* AFKTools ************************************|
    /call LoadIni AFKTools AFKHelp              string      "AFKGMAction=0 Off, 1 Pause Macro, 2 End Macro, 3 Unload MQ2, 4 Quit Game"
    /call LoadIni AFKTools AFKToolsOn           int         1
    /call LoadIni AFKTools AFKGMAction          int         1
    /call LoadIni AFKTools AFKPCRadius          int         500
    /call LoadIni AFKTools CampOnDeath          int         0
    /call LoadIni AFKTools ClickBacktoCamp      int         0
    /if (${Debug}) /echo \atDEBUG Load ini procesed \agLine#: ${Macro.CurLine}
| ************************* Tasks ****************************************|
| Do Not Edit These *****************************************************|
    /declare 1stBuffCheck           int         outer       0
    /declare AddSpam                timer       outer       0
    /declare AddsArray[50,3]        string      outer       NULL
    /declare AdvPullTimer           timer       outer       0
    /declare AdvpathPointNum        int         outer       0
    /declare AdvpathPointX          float       outer       0
    /declare AdvpathPointY          float       outer       0
    /declare AdvpathPointZ          float       outer       0
    /declare AggroOffTimer          timer       outer       0
    /declare AggroTargetID          string      outer
    /declare AggroTargetID2         string      outer       0
    /declare AmmoSwitch             int         outer       0
    /declare Attacking              int         outer       0
    /declare BBWindowOpen           timer       outer       0
    /declare BeginMobID             string      outer
    /declare BPBWindowOpen          timer       outer       0
    /declare BagNum                 int         outer       0
    /declare Banestrike             string      outer
    /declare BardStartTwist         int         outer       0
    /declare BindActive             int         outer       0
    /declare BurnActive             int         outer       0 
    /declare BlockedBuffsCount      int         outer       0
    /declare CampOnDeathTimer       timer       outer       0
    /declare CampZone               int         outer       ${Zone.ID}
    /declare CampfireClickTimer     timer       outer       0
    /declare CampfireTimer          timer       outer       0
    /declare CantHit                int         outer       0
    /declare CantSee                int         outer       0
    /declare CastResult             string      outer
    /declare ChainPullHold          int         outer       0
    /declare ChainPullTemp          string      outer 
    /declare ChainPullTimer         timer       outer       0
    /declare ChainPullTimer2        timer       outer       0
    /declare CleanBuffsTimer        timer       outer       0
    /declare CombatStart            int         outer       0
    /declare CursorID               int         outer       0
    /declare CursorIDCount          int         outer       0
    /declare CursorIDTimer          timer       outer       0
    /declare DMZ                    int         outer       ${Select[${Zone.ID},345,344,202,203,279,151,33506]}
    /declare DontMoveMe             int         outer       0
    /declare DPSCounter             int         outer       0
    /declare DPSLastTime            int         outer       0
    /declare DPSPaused              int         outer       0
    /declare DPSPetTotal            int         outer       0
    /declare DPSSpam                int         outer       0
    /declare DPSTarget              int         outer       0
    /declare DPSTotal               int         outer       0
    /declare DPSTwisting            int         outer       0
    /declare DPSWriteOn             int         outer       0
    /declare DebuffCount            int         outer       0
    /declare DragCorpse             int         outer       0
    /declare DraggedCorpses         string      outer       0
    /declare DurationMod            float       outer       1
    /declare FailCounter            int         outer       0
    /declare FailMax                int         outer       3
    /declare GHCond[10]             string      outer       TRUE
    /declare GMailEvents            string      outer         
    /declare GSent                  int         outer       0
    /declare GoMActive              int         outer       0
    /declare GoMByPass              int         outer       0
    /declare GotHitToggle           int         outer       0
    /declare GlobalIndex            int         outer       0
    /declare GroupHeal[10]          string      outer
    /declare HealAgain              int         outer       0
    /declare IAmDead                int         outer       0
    /declare IniNextTimer           timer       outer       0
    /declare IsTankRoaming          string      outer       0 
    /declare JoinedParty            timer       outer       0
    /declare JustZoned              timer       outer       0
    /declare LastMobPullID          int         outer       0
    /declare LastZone               int         outer       ${Zone.ID}
    /declare LooterAssigned         int         outer       0
    /declare MASitTime              timer       outer       0
    /declare MainAssist             string      outer
    /declare MainAssistClass        string      outer
    /declare MainAssistType         string      outer
    /declare MashArray[10]          string      outer
    /declare MashCond[10]           string      outer       TRUE
    /declare MedStat                string      outer
    /declare MedStat2               string      outer       Endurance
    /declare Medding                int         outer       0
    /declare MercAssisting          int         outer       0
    /declare MercInGroup            int         outer       0
    /declare MezAETimer             timer       outer       0
    /declare MezArray[50,3]         string      outer       NULL
    /declare MezBroke               int         outer       0
    /declare MezImmuneIDs           string      outer
    /declare MezMobAECount          int         outer       0
    /declare MezMobCount            int         outer       0
    /declare MezMobFlag             int         outer       0
    /declare MezMod                 int         outer       0
    /declare MobCount               int         outer       0
    /declare MobFlag                int         outer       1
    /declare MountOn                int         outer       1
    /declare MyAAExp                float       outer       ${Me.PctAAExp}
    /declare MyExp                  float       outer       ${Me.PctExp}
    /declare MyMerc                 string      outer       0
    /declare MyOriginalRole         string      outer
    /declare MyTargetID             int         outer       0
    /declare MyTargetName           string      outer       0
    /declare NamedCheck             int         outer       0
    /declare NeedCuring             int         outer       0
    /declare OrigRanged             string      outer       ${InvSlot[ranged].Item.Name}
    /declare PCsDetected            int         outer       0
    /declare ParseDPSTimer          int         outer       0
    /declare PetActiveState         int         outer       0     
    /declare PetAttack              timer       outer       0
    /declare PetAttackRange         int         outer       0
    /declare PetBuffCheck           timer       outer       0
    /declare PetFollowTimer         timer       outer       60s    
    /declare PetSuspendState        int         outer       0 
    /declare PetTanking             int         outer       0
    /declare PetTauntOn             int         outer       0
    /declare PetTotCount            int         outer       0
    /declare PullAggroTargetID      string      outer
    /declare PullAlertTimer         timer       outer       0
    /declare PullAmmo               string      outer       NULL
    /declare PullIgnore1            string      outer       NULL
    /declare PullIgnore2            string      outer       NULL
    /declare PullIgnore3            string      outer       NULL
    /declare PullItem               string      outer       NULL
    /declare PullMax                int         outer       0
    /declare PullMin                int         outer       0
    /declare PullMob                int         outer       0
    /declare PullMoveUse            string      outer
    /declare PullNavTimer           timer       outer       0    
    /declare PullPathArrayX[999]    float       outer        
    /declare PullPathArrayY[999]    float       outer
    /declare PullPathArrayZ[999]    float       outer
    /declare PullPathWpCount        int         outer       0
    /declare PullRange              int         outer       0
    /declare PullRangeActual        int         outer
    /declare PullTimer              timer       outer       0
    /declare PullTooFar             int         outer       0
    /declare PullWithAlt            string      outer       Melee
    /declare Pulled                 int         outer       0
    /declare Pulling                int         outer       0
    /declare PullXPCheck            int         outer       1     
    /declare RangedSwitch           int         outer       0
    /declare ReMemCast              int         outer       0
    /declare ReMemCastLW            int         outer       0
    /declare ReMemMiscSpell         string      outer       ${Me.Gem[${MiscGem}].Name}
    /declare ReMemMiscSpellLW       string      outer       ${Me.Gem[${MiscGemLW}].Name}
    /declare ReMemWaitLong          string      outer       null
    /declare ReMemWaitShort         string      outer       null
    /declare ReadBuffsTimer         timer       outer       0
    /declare Redguides              int         outer       1
    /declare RememberCamp           int         outer       0
    /declare SHCond[15]             string      outer       TRUE
    /declare SHealPct               int         outer
    /declare SingleHealPoint        int         outer       0
    /declare SingleHealPointMA      int         outer       0    
    /declare SingleHeal[15]         string      outer
    /declare SpamTimer              timer       outer       0
    /declare SpellReadyL            int         outer       0
    /declare StickDist              int         outer       13
    /declare StickDistUW            int         outer       10
    /declare TWbufflist             string      outer
    /declare TankTimer              timer       outer       0
    /declare TaskGiver              string      outer
    /declare TempAmmo               string      outer       ${InvSlot[ammo].Item.Name}
    /declare TempMaxRadius          int         outer       0
    /declare ToClose                int         outer       0
    /declare TributeTimer           timer       outer       0
    /declare Twisting               int         outer       0
    /declare ValidTarget            int         outer       0
    /declare WasTwisting            bool        outer       FALSE
    /declare WaitTimer              timer       outer       0
    /declare WayPointZRange         int         outer       ${MaxZRange}
    /declare WeaveArray[10]         string      outer
    /declare WeaveCond[10]          string      outer       TRUE
    /declare WhoToChase             string      outer
    /declare WriteBuffsMercTimer    timer       outer       0
    /declare WriteBuffsPetTimer     timer       outer       0
    /declare WriteBuffsTimer        timer       outer       0
    /declare XTSlot                 int         outer       0
    /declare XTSlot2                int         outer       0
    /declare ZDist                  float       outer       0
    /if (${Debug}) /echo \atDEBUG Misc Declares Processed \agLine#: ${Macro.CurLine}
    | Set AA DurationMod for various timer from Spell Casting Reinforcement AA
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==1) /varset DurationMod 1.15
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==2) /varset DurationMod 1.3
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==3) /varset DurationMod 1.5
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==4) /varset DurationMod 1.7
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==5) /varset DurationMod 1.9
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==1) /varset DurationMod 1.15
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==2) /varset DurationMod 1.3
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==3) /varset DurationMod 1.5
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==4) /varset DurationMod 1.6
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==5) /varset DurationMod 1.7
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==6) /varset DurationMod 1.8

    | Set AA DurationMod for mez timer from Spell Casting Reinforcement AA
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==1) /varset MezMod 6
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==2) /varset MezMod 12
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==3) /varset MezMod 18
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==4) /varset MezMod 24
    | Compensate for Eyes Wide open AA and Extended Target Window
    /declare n int local
    /declare XSlotTotal int outer 13
    /for n 1 to ${XSlotTotal}
        /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]}) {
            /if (${XTSlot} && !${XTSlot2}) /varset XTSlot2 ${n}
            /if (${XTSlot}==0) /varset XTSlot ${n}
        }
    /next n
    |  Added extra slot check and Error Message
    /if (${XTSlot}==0 || ${ChainPull} && !${XTSlot2}) {
        /echo You need more slots in your Extended Target Window set to Auto.
    /if (${ChainPull}) {
            /echo Please set at least 2 slots to Auto for Chain Pulling and restart KissAssist.
        } else {
            /echo Please set at least 1 slot to Auto and restart KissAssist.
        }
        /end
    }
    | Changed Logic for populating AggroTargetID. This change will include mobs in camp not on XTarget.
    /noparse /varset AggroTargetID ${If[${Me.XTarget[${XTSlot}].ID},${Me.XTarget[${XTSlot}].ID},${If[${AggroTargetID2},${AggroTargetID2},0]}]}
    /noparse /varset PullAggroTargetID ${If[${ChainPull}==0,${Me.XTarget[${XTSlot}].ID},${If[${Me.XTarget[${XTSlot}].ID} && (${Me.XTarget[${XTSlot}].ID}==${MyTargetID} || ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID} || ${Me.XTarget[${XTSlot2}].ID}),${MyTargetID},0]}]}
| ************************* Merc ****************************************|
    /call LoadIni Merc Help                     string      "To use: Turn off Auto Assist in Manage Mercenary Window"
    /call LoadIni Merc MercOn                   int         0
    /call LoadIni Merc MercAssistAt             int         92
    /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
    /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
    /if (${Debug}) /echo \atDEBUG Timers Processed \agLine#: ${Macro.CurLine}
| -------------------------------------------------------------------------------------
| Check if required plugins are loaded and settings
| -------------------------------------------------------------------------------------
    /call CheckPlugin MQ2Cast
    /call CheckPlugin MQ2Exchange
    /if (${UseMQ2Melee}) /call CheckPlugin MQ2Melee
    /call CheckPlugin MQ2Moveutils
    /call CheckPlugin MQ2Posse
    /call CheckPlugin MQ2Rez
    /if (${IAmABard}) /call CheckPlugin MQ2Twist
    /if (!${IAmABard} && !${Bool[${Plugin[mq2twist]}]}) /declare Twist int outer 0
    |  Turn aggro mode off and turn on melee mode in MQ2Melee
    /if (!${UseMQ2Melee} && ${Bool[${Plugin[mq2melee]}]}) /plugin mq2melee unload noauto
    /if (${EQBCOn} && !${Macro.IsTLO[EQBC]}) /plugin mq2eqbc noauto
    /if (${UseMQ2Melee} && ${Bool[${Plugin[mq2melee]}]}) {
        /squelch /melee aggro=0
        /squelch /melee melee=1
        /squelch /melee stickbreak=1
        /squelch /melee petassist=0
        /squelch /melee on
        /squelch /melee stickmode=0
    }
    |  Set MQ2moveutils variables
    /stick set autosave off
    /stick set moveback 12
    /stick set verbflags 0
    /stick set breakonkb on
    /stick set breakonmouse off
    /stick set breakdist ${CampRadiusExceed}
    /stick set breakonwarp on
    /stick set usefleeing on
    /stick set delaystrafe on
    | Set up MQ2rez if RezAcceptOn=1
    /if (${RezAcceptOn.Arg[1,|].Equal[1]}) {
        /squelch /rez accept on
        /squelch /rez loot off
        /if (${Int[${RezAcceptOn.Arg[2,|]}]}>0) /rez pct ${Int[${RezAcceptOn.Arg[2,|]}]}
    } else /squelch /rez accept off
   /if (${Macro.IsTLO[Posse]}) {
       /if (${Select[${AFKToolsOn},1,2]}) {
            /posse radius ${AFKPCRadius}
            /posse friendnotify off
            /posse strangernotify on
            /if (!${Posse.Status})  {
                /posse on
                /posse load
            }
        }
    } else {
	    /varset AFKToolsOn 0
	}
    | Initialize variables for ninjadvloot.inc include file
    /call SetupAdvLootVars
    /if (${HealsOn}) {
        /call SortArray Heals HealsCond 100|100 >
        /call FindSingleHeals
        /call FindGroupHeals
    }
        /call CreateTimersHeals
    /call AlertAddToList 3 "${MobsToIgnore}"
    /call CreateTimersGoM
    /if (${DPSOn}) {
        /call SortArray DPS DPSCond 1|1 <
    } else {
        /call CreateTimersDPS
    }
    /if (${BuffsOn}) {
        /call SortArray Buffs null 100|100 >
    } else {
        /call CreateTimersBuffs
    }
    /if (${AggroOn}) /call SortArray Aggro AggroCond 1|1 >
    /call SortArray Burn BurnCond 1|1 >
    /if (${AutoRezOn}) /call CreateTimersRez
    /if (${MezOn}) /call CreateTimersMez
    /if (!${MezImmune.Find[List up to 10 mobs]}) /call AlertAddToList 4 "${MezImmune}"
    /if (${PullLevel.Find[auto]}) {
       /varcalc PullMin ${Me.Level}-5
       /varcalc PullMax ${Me.Level}+2       
    } else /if (${PullLevel.Equal[0|0]} || ${PullLevel.Equal[0]} || ${PullLevel.Equal[null]} || !${PullLevel.Find[|]}) {
       /varset PullMin 1
       /varset PullMax 200
       /varset PullLevel off
    } else {
       /varset PullMin ${PullLevel.Left[${Math.Calc[${PullLevel.Find[|]}-1]}]}
       /varset PullMax ${PullLevel.Right[${Math.Calc[${PullLevel.Length}-${PullLevel.Find[|]}]}]} 
    }
    /if (${PullMin}>${PullMax} || ${PullMin}==0 || ${PullMax}==0) {
       /echo Invalid Pull Level Settings resetting to default.
       /varset PullMin 1
       /varset PullMax 200
       /varset PullLevel off
    }
    | Checking your ini file for errors
    /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Zone].Length}) {
        /echo Checking your ini file for errors. 
        /delay 10
        /call ScanIni
    }
    /if (${NumParams}) {
        /call PParse 1 ${NumParams}
    }
    /if (${GMailOn}) /call GmailIniParse
| -------------------------------------------------------------------------------------
| Assign Main Tank from command line parameter or targeted player, merc or pet
| -------------------------------------------------------------------------------------
    /if (${ParseDPSTimer}>=1) {
        /target id ${Me.ID}
        /delay 10 ${Target.ID}==${Me.ID}
        /if (${DPSOn}) /varset DPSOn 2
        /varset Role Tank
        /call AssignMainAssist
        /call CheckRoles 1
        /call CheckBuffs
        /call Bind_Parse ${ParseDPSTimer}
    }
    /if (!${MainAssist.Length} || ${MainAssist.Equal[null]}) {
       | Make pet if it isn't up already !!!!
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && !${Me.Pet.ID}) {
            /echo My role is (${Role}), but I have no active pet.
            /echo Making my pet so I can assign it as Main Assist!
            /call DoPetStuff
        }
        /if (!${Target.ID} && ${Select[${Role},tank,pullertank,hunter]}) {
            /target id ${Me.ID}
            /delay 10 ${Target.ID}==${Me.ID}
        }
        /if ((!${Target.ID} || ${Target.ID}!=${Me.ID}) && ${Select[${Role},pettank,pullerpettank,hunterpettank]}) {
            /target id ${Me.ID}
            /delay 10 ${Target.ID}==${Me.ID}
        }
        /call AssignMainAssist
    }
    | Check command line for tank name
    /if (${MainAssist.Length}) {
        /if (${Debug})  /echo ${MainAssist} \agLine#: ${Macro.CurLine}
        /target id ${Spawn[=${MainAssist}].ID}
        /if (${Debug}) /echo targeting ${Spawn[=${MainAssist}].ID} \agLine#: ${Macro.CurLine}
        /delay 30 ${Target.ID}==${Spawn[=${MainAssist}].ID}
        | Target PC instead of familiar or pet
        /if (${Spawn[=${MainAssist}].Type.Equal[Pet]} && !${MainAssist.Find[`s]}) {
            /tar pc ${MainAssist}
            /delay 10 ${Target.ID}==${Spawn[${MainAssist} pc].ID}
        }
        /call AssignMainAssist
    }
    /if ((!${Target.ID} || ${Target.CleanName.NotEqual[${Me.CleanName}]}) && ${Select[${Role},hunter,pullertank]}) {
        /target id ${Me.ID}
        /delay 10 ${Target.ID}==${Me.ID}
    }
    | Targeted myself end macro
    /if (${Target.CleanName.Equal[${Me.CleanName}]} && (${Role.Equal[assist]} || ${Role.Equal[puller]})) {
        /echo ERROR: You cannot assist yourself! Please target Main Tank and restart macro.
        /beep
        /end
    }
    | Error control no tank selected end macro
    /if (!${Target.ID} || !${Select[${Target.Type},Mercenary,PC,Pet]} || ${Me.Type.Equal[corpse]}) {
        /echo ERROR: You have >> ${Target.CleanName} << targeted. Please target a Mercenary, PC or Pet for Main Tank and restart the macro.
        /beep
        /end
    }
    /call CheckRoles 1
    /varset WhoToChase ${MainAssist}
    /varset MyOriginalRole ${Role}
    /echo ================================
    /echo Redguides presents
    /echo ${MacroName} v.${MacroVer} by Maskoi
    /popup ${MacroName} v.${MacroVer} by Maskoi
    /echo ================================
    /doevents
    /if (${Select[${Role},tank]}) {
        /if (${MainAssist.Equal[${Me}]}) {
            /echo I am Tanking & Main Assist
        }
    } else /if (${Select[${Role},puller]}) {
        /echo I am Puller. KissAssisting >> ${MainAssist} << at ${AssistAt}%
        /if (${ChainPull}) /echo  What? I have to chain pull now.
    } else /if (${Select[${Role},pullertank]}) {
        /echo I am Puller & Tank.
    | PetTank set role
    } else /if (${Select[${Role},pettank]}) {
        /echo My Pet >> ${Me.Pet.CleanName} << is Tanking & KissAssisting >> ${MainAssist} <<
    | PullerPetTank set role
    } else /if (${Select[${Role},pullerpettank]}) {
        /echo I am Pulling & my Pet >> ${Me.Pet.CleanName} << is Tanking.
        /echo We are all doomed.
        /delay 10
        /echo DOOMED!
    | HunterPetTank set role
    } else /if (${Select[${Role},hunterpettank]}) {
        /echo I am Hunting & my Pet >> ${Me.Pet.CleanName} << is Tanking.       
    } else /if (${Select[${Role},hunter]}) {
        /echo I am Hunting.
    } else {
        /echo KissAssisting >> ${MainAssist} << at ${AssistAt}%
        /echo ${MainAssist} is a ${MainAssistType} ${Spawn[=${MainAssist}].Class}
    }
    | If I am group leader set Main Assist Tag for Group Check for pet and make master MainAssist
    /if (${Select[${Me},${Group.Leader}]} && (${Spawn[group ${MainAssist}].ID} || (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[group ${Spawn[${MainAssist}].Master.CleanName}].ID}))) { 
        | If Main Assist is someone else than who its suppose to be unset Group tag
        /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
            /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
        }
        /if (!${Group.MainAssist.Name.Length}) {
            /if (${Spawn[${MainAssist}].Type.Equal[pet]}) {
                /call BroadCast ${IRCOn} ${EQBCOn} r "Assigning ${Spawn[${MainAssist}].Master.CleanName} as Main Assist in Group Window"
                /call AssignGroupRole set "${Spawn[${MainAssist}].Master.CleanName}" 2
            } else {
            /call BroadCast ${IRCOn} ${EQBCOn} r "Assigning ${MainAssist} as Main Assist in Group Window"
            /call AssignGroupRole set "${MainAssist}" 2
            }
        }
    } else /if (${Select[${Me},${Group.Leader}]}) {
        /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
            /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
        }
    }
    /squelch /target clear
    /squelch /assist off
    /if (${Role.Find[pull]}) {
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} r "PULL: Path >> ${PullPath} <<  found with ${PullPathWpCount} waypoints."
            /call BroadCast ${IRCOn} ${EQBCOn} r "PULL: Using MQ2AdvPath to Pull with ${PullWith}"
        } else /if (${Bool[${Plugin[MQ2Nav]}]}) {
            /if (${Navigation.MeshLoaded}) {
                | Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
                /varset PullMoveUse nav
                /call BroadCast ${IRCOn} ${EQBCOn} r "PULL: The MQ2Nav mesh for ${Zone} is loaded"
                /call BroadCast ${IRCOn} ${EQBCOn} r "PULL: Using MQ2Nav to Pull with ${PullWith}"
            }   
        } else {   
            /varset PullMoveUse los
            /call BroadCast ${IRCOn} ${EQBCOn} r "PULL: Using Line of Sight to Pull with ${PullWith}"
        }
    } else {
        /if (${Bool[${Plugin[MQ2Nav]}]}) {
            /if (${Navigation.MeshLoaded}) {
                | Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
                /varset PullMoveUse nav
                /echo The MQ2Nav mesh for ${Zone} is loaded
                /echo Using MQ2Nav to Move.
            }
        } else {
            /varset PullMoveUse los
            /echo Using MoveUtil to move with ${PullWith}
        }
    }    
    /if (${LoadSpellSet}) /call LoadSpellSet
    /call WinTitle
| -------------------------------------------------------------------------------------
| Main Loop
| -------------------------------------------------------------------------------------
        /while (1) {
            /doevents
            /if (${ChainPull}!=2) {
                /call CampfireBack
                /if (${AFKToolsOn}) /call AFKTools
                /if (${DPSOn} || ${MeleeOn}) /call CheckForCombat 0 MainLoop1
                /if (${AEOn}) /call AECheck
                /if (${MezOn}) {
                    /varset GoMByPass 1
                    /call DoMezStuff MainLoop
                    /varset GoMByPass 0
                }
                /call WriteDebuffs
                /if (${HealsOn}) /call CheckHealth
                /if (${CuresOn}) /call CheckCures
                /if (${Me.CombatState.NotEqual[COMBAT]}) /call DoWeMove 0 mainloop
                /if (${Me.CombatState.NotEqual[COMBAT]}) /call DoWeChase
                /if (${AutoRezOn}) /call RezCheck
                /if (${CampfireOn} && ${Me.CombatState.NotEqual[COMBAT]}) /call Campfire
                /if (${Select[${Me},${Group.Leader}]}==1 && !${LooterAssigned}) /call AssignLooter
                /call DoMiscStuff
                /call CanIDoStuff
                /if (${MercOn}) /call MercsDoWhat
                /call CastMana MainLoop
                /if (${PetOn}) /call DoPetStuff
                /if (${PetOn}) /call CheckPetBuffs
                /if (${Me.CombatState.NotEqual[COMBAT]}) {
                    /call WriteBuffs
                    /call WriteBuffsMerc
                    /call WriteBuffsPet
                }
                /if (${BuffsOn}) /call CheckBuffs
                /if (${IAmABard}) /call DoBardStuff
                /if (${Me.CombatState.NotEqual[COMBAT]}) /if (${MedOn}) /call DoWeMed
                /if (${Me.CombatState.NotEqual[COMBAT]}) /if (${GroupWatchOn}) /call GroupWatch
            } else {
                /call AFKTools
            }
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
                /if (!${PullMob}) /call FindMobToPull 1
                /call PullCheck 
                /varset PullMob 0
            }
            /if (${DPSOn} || ${MeleeOn}) {
                /call CheckForCombat 0 MainLoop2
            } else {
                /call CheckForCombat 1 MainLoop3
            }
            /if (${LootOn}) /call LootStuff
            /if (${DebugHeal}) /delay 5 
            /delay 1
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: PParse Parse passed command line parameters
| -------------------------------------------------------------------------------------    
    Sub PParse(int iniLoaded, int nump)
        /if (${Debug}) /echo \atDEBUG PParse: iniLoaded: ${iniLoaded} NumP: ${nump} \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare j int local 0
        /declare k int local 0
        /declare TempPathX float local 0
        /declare TempPathY float local 0
        /declare TempPathZ float local 0
        /declare ipa int local 0
        /declare ipb int local 0
        | Command Line Passed Parameterss start with the number 0. 0 is the first param and is counted as 1 param even though the loop is 0 to 0.
        /for i 0 to ${nump}
            /if (${Debug}) /echo \atDEBUG PParse: ${i}. ${Defined[PParam${i}]} P${i}: ${PParam${i}} \agLine#: ${Macro.CurLine}
            /if (${Defined[PParam${i}]}) {
                | ipa increases the param counter by 1 so we can assign the variable after the current parma. 
                | /mac kissassist assist ma bob - if Param1 is ma for mainassist the next param is bob
                /varcalc ipa ${i}+1
                /varcalc ipb ${i}-1
                /if (${PParam${i}.Equal[ini]} && ${Defined[IniFileName]}) {
                    /varset IniFileName ${PParam${ipa}}
                    /echo Ini file has been set to >> ${PParam${ipa}} <<
                    /varset PIniSet 1
                }
                /if (${Select[${PParam${i}},assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
                    /if (!${Defined[Role]}) /declare Role string outer
                    /varset Role ${PParam${i}}
                }
                /if (${PParam${i}.Equal[ma]} && ${Defined[MainAssist]}) {
                    /if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
                    /varset MainAssist ${PParam${ipa}}
                }
                /if (${Select[${PParam${i}},parse,assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank]}==0 && ${Int[${PParam${i}}]}==0 && !${PParam${i}.Find[.ini]} && ${Defined[MainAssist]}) /varset MainAssist ${PParam${i}}
                /if (${PParam${i}.Equal[assistat]} && ${Defined[AssistAt]}) {
                    /if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
                    /varset AssistAt ${PParam${ipa}}
                }
                /if (${Defined[PParam${ipb}]}) {
                    /if (${PParam${ipb}.NotEqual[parse]}) {
                        /if (${Int[${PParam${i}}]} >= 1 && ${Int[${PParam${i}}]} <= 100 && ${Defined[AssistAt]}) {
                            /varset AssistAt ${PParam${i}}
                        }
                    }
                }
                /if (${Defined[PullPathWpCount]}) {
                    /if (${PParam${i}.Equal[path]} && ${Defined[PullPath]}) {
                        /call CheckPlugin MQ2AdvPath
                        /if (${Bool[${Plugin[MQ2AdvPath]}]}) {
                            /delay 20 ${AdvPath.Active}
                            | Play path on pause to load info . Only way we can grab info from advpath
                            /if (${AdvPath.PathList[${PParam${ipa}}]}) {
                                /play ${PParam${ipa}} pause
                                /varset PullPath ${PParam${ipa}}
                                /delay 10
                                | Set PullPathWpCount with total amount of waypoints in path
                                /varset PullPathWpCount ${AdvPath.Waypoints}    
                                | Load path points into array
                                /for k 1 to ${PullPathWpCount} 
                                    /if (${Debug}) /echo \atDEBUG PParse WP#: ${Int[${Math.Calc[${k}-1]}]}-${k} Distance Between: ${Math.Distance[${TempPathY},${TempPathX}:${AdvPath.Y[${k}]},${AdvPath.X[${k}]}]} \agLine#: ${Macro.CurLine}
                                    /varset PullPathArrayX[${k}] ${AdvPath.X[${k}]}
                                    /varset PullPathArrayY[${k}] ${AdvPath.Y[${k}]}
                                    /varset PullPathArrayZ[${k}] ${AdvPath.Z[${k}]}
                                    /varset TempPathX ${PullPathArrayX[${k}]}
                                    /varset TempPathY ${PullPathArrayY[${k}]}
                                    /varset TempMaxRadius ${Math.Distance[${CampYLoc},${CampXLoc}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                                    /if (${TempMaxRadius}>${MaxRadius}) /varset MaxRadius ${TempMaxRadius}
                                    /if (${Debug}) /echo \atDEBUG PParse: WP: ${k} WPX: ${PullPathArrayX[${k}]} WPY: ${PullPathArrayY[${k}]} \agLine#: ${Macro.CurLine}
                                /next k    
                                /varset TempMaxRadius ${MaxRadius}
                                /play off
                                | Tell Kiss were are using MQ2advpath for pulling
                                /varset PullMoveUse advpath
                            }
                        } else {
                            /echo Path ${PParam${ipa}} not found.
                            /varset PullMoveUse 
                            /varset PullPathWpCount 0
                            /varset UseWayPointZ 0
                        }
                    }
                }
                /if (${PParam${i}.Equal[parse]} && ${Defined[ParseDPSTimer]}) {
                    /if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
                    /varset ParseDPSTimer ${PParam${ipa}}
                }    
                /if (${PParam${i}.Equal[scanini]}) {
                    /ini "KissAssist_Buffs.ini" ${Me.ID} Zone NULL
                }
                /varset ipa 0
                /varset ipb 0
            }
        /next i
        /if (${iniLoaded}) {
            /if (${Select[${PullMoveUse},los,nav]}>=1) /varset UseWayPointZ 0
        }
        /if (${Debug}) {
            |these are not set when this sub gets called first time so in practice we cant echo them...
            /if (${iniLoaded}) {
                /echo \atDEBUG PParse Leave Role: ${Role} MA:${MainAssist} AssistAt:${AssistAt} INI:${IniFileName} PullPath:${PullPath} Parse:${ParseDPSTimer} \agLine#: ${Macro.CurLine}
            } else {
                /echo \atDEBUG PParse Leave
            }
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckForCombat Used to help with controlling combat
| -------------------------------------------------------------------------------------
    Sub CheckForCombat(int SkipCombat, string FromWhere)
        /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat Enter SkipCombat: ${SkipCombat} ChainPull: ${ChainPull} Role: ${Role} ${FromWhere} \agLine#: ${Macro.CurLine}
        |/if (${SkipCombat}) /goto :SkipMelee
        :CombatTop
        /while (1) {
            /if (${SkipCombat}==0) {
                /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0) ) /varset IAmDead 0
                /call MobRadar ${MeleeDistance} CheckForCombat
                /if (${Debug}) /delay 10
                /if ((${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Hovering} || (${IAmDead} && !${AggroTargetID}) || (!${MobCount} && !${AggroTargetID}) || (!${DPSOn} && !${MeleeOn})) /return
                /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat: Assist/Combat Begin ${FromWhere}  \agLine#: ${Macro.CurLine}
                /call Assist
                /call Combat 
                /if (${Debug} || ${DebugCombat}) /echo \atDEBUG  CheckForCombat: Assist/Combat End ${FromWhere}  \agLine#: ${Macro.CurLine}
                /if (${ChainPull}==2) /return
            }
            |:SkipMelee
            /if (${MezOn}) {
                /varset MezBroke 0
                /doevents MezBroke
                /if (!${MezBroke}) {
                    /varset GoMByPass 1
                    /call DoMezStuff CheckForCombat
                    /varset GoMByPass 0
                }
            }
            /while (${SkipCombat}==1 || (${DPSOn} && ${HealsOn} && !${Spawn[${MyTargetID}].LineOfSight}) && ${MyTargetID}) {
                /if (${AggroTargetID}) {
                    /if (${HealsOn}) /call CheckHealth
                    /if (${CuresOn}) /call CheckCures
                    /if (${AutoRezOn}) /call RezCheck
                    /call CastMana CheckForCombat
                    /call WriteDebuffs
                    |/goto :SkipMelee
                } else {
                    /return
                }
            }
            /call CheckForAdds CheckForCombat
            /if (${Role.Equal[tank]} || ${Role.Equal[pullertank]}) {
                | If tank is assisting puller and in chase mode
                /if (${MainAssist.NotEqual[${Me}]} && ${ChaseAssist}) /call DoWeChase
                /if (${ReturnToCamp} && ((!${MobCount} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>15) || (${MobCount}==1 && ${AggroTargetID} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>75))) /call DoWeMove 1 checkforcombat
                /if (${MobCount} && ${AggroTargetID}) /continue
                /if (${BuffsOn}) {
                    /for GlobalIndex 1 to ${BuffsSize}
                        /if (${Buffs[${GlobalIndex}].Arg[2,|].NotEqual[end]}) /break 
                        /if (${Me.PctEndurance}<=${Buffs[${GlobalIndex}].Arg[3,|]} && ((${Me.CombatAbilityReady[${Buffs[${GlobalIndex}].Arg[1,|]}]} && !${Me.ActiveDisc.ID}) || ${Me.AltAbilityReady[${Buffs[${GlobalIndex}].Arg[1,|]}]})) /call CheckEndurance "${Buffs[${GlobalIndex}].Arg[1,|]}" ${Buffs[${GlobalIndex}].Arg[3,|]} ${Buffs[${GlobalIndex}].Arg[4,|]}
                    /next GlobalIndex
                }    
                /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat MobCount: ${MobCount} AggroTargetID: ${AggroTargetID} ChainPull: ${ChainPull} ${SkipCombat} \agLine#: ${Macro.CurLine}
                /if (${TankTimer}) /continue
            }
            /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat MobCount: ${MobCount} AggroTargetID: ${AggroTargetID} ChainPull: ${ChainPull} ${SkipCombat} \agLine#: ${Macro.CurLine}
            /if ((!${AggroTargetID} && (!${MezMobFlag} || !${MobCount}) && !${ChainPull}) || (${MobCount}<2 && ${ChainPull})) /break
        }
        /if (${MobCount}==1 && ${ChainPull} && ${MyTargetID} && ${Spawn[${MyTargetID}].PctHPs}<=${ChainPullHP}) /return
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
            /if (${MainAssist.NotEqual[${Me}]}) /delay ${Math.Calc[${Math.Rand[1]}+1]}s
            /if (${MobCount}<=0) /call DoWeMove 0 checkforcombat
        }
        /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat leave. \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Assist - Get Main Tank's target
| -------------------------------------------------------------------------------------
    Sub Assist
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (!${MeleeOn} && !${DPSOn} && !${MezOn}) /return
        /if (${DPSPaused}) /return
        /if (${Me.Hovering}) /return
        /if (${Pulled} && ${MyTargetID} && ${MainAssist.Equal[${Me}]}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare n int local
        /declare ClosestMobID int local 0
        /declare BlurredMobID int local 0
        /declare XTDistance float local 0
        /declare TempTargetID int local
        /declare skipFlag int local 0
        /doevents
        /call MobRadar ${MeleeDistance} Assist
            | Normal assist check
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist0: ${Me} ${MainAssist} ${Spawn[=${MainAssist}].Distance} ${MobCount} ${AggroTargetID} ${Target.ID} ${MyTargetID} ${Me.Combat} \agLine#: ${Macro.CurLine}
            /if (${MainAssist.NotEqual[${Me}]} && (${MobCount} || ${AggroTargetID})) {
                /if (${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Distance}<200) {
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist1: ${Me} ${MainAssist} ${Group.MainAssist.ID} ${Spawn[=${MainAssist}].Distance} ${MobCount} ${AggroTargetID} ${Me.XTarget[${XTSlot}].ID} ${Me.XTarget[${XTSlot2}].ID} \agLine#: ${Macro.CurLine}
                    /if (${Group.MainAssist.ID}) {
                        /if (${Bool[${Me.GroupAssistTarget.ID}]}==TRUE) {
                            /target id ${Me.GroupAssistTarget.ID}
                            /delay 10 ${Me.GroupAssistTarget.ID}==${Target.ID}
                        }
                    } else {
                        /assist ${MainAssist}
                        /delay 5s ${Me.AssistComplete}==TRUE
                    }
                    | Target mob when assisting puller and they are targeting Tank
                    /if (${Target.CleanName.Equal[${Me}]} && (${MobCount} || ${AggroTargetID})) {
                        /squelch /target clear
                        /squelch /target id ${AggroTargetID}
                        /delay 10 ${AggroTargetID}==${Target.ID}
                    }
                    /goto :validatetarget
                | If the tank is dead and aggro mob in camp target 1st mob on autohater in xtarget
                } else /if (!${Spawn[=${MainAssist}].ID} && ${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<=${CampRadius}) {
                    /squelch /target id ${AggroTargetID}
                    /delay 10
                    /goto :validatetarget
                }   
            }
            /if (${MainAssist.Equal[${Me}]}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist2: MainAssist.Equal[${Me}] is ${MainAssist.Equal[${Me}]} OR my role is ${Role} MobCount = ${MobCount} \agLine#: ${Macro.CurLine}
                /if (${Target.CleanName.Equal[${Me}]} && (${MobCount} || ${AggroTargetID})) /squelch /target clear
                | I am tank with a single mob wait for it then validate and attack.
                /if (${MobCount}==1 && (!${XTSlot2} || (${XTSlot2} && !${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID}) {
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist: ${MobCount}==1 && ${AggroTargetID} \agLine#: ${Macro.CurLine}
                    /squelch /target id ${AggroTargetID}
                    /delay 10 ${Target.ID}==${AggroTargetID}
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist: Single target: ${AggroTargetID} ${Spawn[${AggroTargetID}].CleanName} \agLine#: ${Macro.CurLine}
                    /goto :validatetarget
                }
                | More than one mob
                /if ((${MobCount}>=2 || (${XTSlot2} && ${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID}) {
                    | Check if named incoming an target if true else assign closest target.
                    /for n 1 to ${XSlotTotal}
                        /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${n}].ID}) {
                            /if (${Me.XTarget[${n}].Named}) {
                                /squelch /target id ${Me.XTarget[${n}].ID}
                                /delay 10 ${Target.ID}==${Me.XTarget[${n}].ID}
                                /varset skipFlag 1
                                |/goto :validatetarget
                            }
							/if (${skipFlag}) /break
                            | Tank mez immune mobs first.
                            /if (${Alert[4].Size}) {
                                /for j 0 to ${Alert[4].Size}
                                    /if (${Alert[4].List[${j}].Name.Equal[${Me.XTarget[${n}].CleanName}]} && ${Alert[4].List[${j}].Name.Length}) {
                                        /call BroadCast ${IRCOn} ${EQBCOn} y "Grabbing MEZ Immune -> ${Me.XTarget[${n}].CleanName} <- ID:${Me.XTarget[${n}].ID} "
                                        /squelch /target id ${Me.XTarget[${n}].ID}
                                        /delay 10 ${Target.ID}==${Me.XTarget[${n}].ID}
                                        /varset skipFlag 1
                                    }
									/if (${skipFlag}) /break
                                /next j
                            }
                                /if (${skipFlag}) /break
                            /if (!${ClosestMobID}) /varset ClosestMobID ${Me.XTarget[${n}].ID}
                            /if (${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]}>${Math.Distance[${Me.XTarget[${n}].Y},${Me.XTarget[${n}].X}:${CampYLoc},${CampXLoc}]}) /varset ClosestMobID ${Me.XTarget[${n}].ID}
                        }
                    /next n
                    /if (${skipFlag}) /goto :validatetarget
                    | Don't need to target mob on incoming and out of meleedistance'
                    /if (${Target.ID}!=${ClosestMobID} && ${MobCount}) {
                        /squelch /target id ${ClosestMobID}
                        /delay 10 ${Target.ID}==${ClosestMobID}
                    }
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT ClasestMobID: ${ClosestMobID} Distance: ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} XTarget[${XTSlot2}] ID: ${Me.XTarget[${XTSlot2}].ID} Distance: ${Math.Distance[${Me.XTarget[${XTSlot2}].Y},${Me.XTarget[${XTSlot2}].X}:${CampYLoc},${CampXLoc}]} AgroTargetID: ${AggroTargetID} \agLine#: ${Macro.CurLine}
                    /goto :validatetarget
                }
                | Check for memblurred mobs in camp when nothing left on xtarget. Check only for 5 secs after last mob.
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist3: ${AggroTargetID} ${MobCount} ${MezMobFlag} \agLine#: ${Macro.CurLine}
                /if (!${AggroTargetID} && ${MobCount} && ${MezMobFlag}==1) {
                    /varset BlurredMobID ${NearestSpawn[1,npc targetable los radius ${MeleeDistance} zradius 50 noalert 3].ID}
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist4: ${BlurredMobID} ${Math.Distance[${Spawn[${BlurredMobID}].Y},${Spawn[${BlurredMobID}].X}:${CampYLoc},${CampXLoc}]} ${MeleeDistance} \agLine#: ${Macro.CurLine}
                    /if (${BlurredMobID} && ${Math.Distance[${Spawn[${BlurredMobID}].Y},${Spawn[${BlurredMobID}].X}:${CampYLoc},${CampXLoc}]}<${MeleeDistance}) {
                        /target ID ${BlurredMobID}
                        /varset MezMobFlag 0
                        /delay 10 ${Target.ID}==${BlurredMobID}
                        /delay 30 ${Target.Mezzed.ID}
                        /if (${Target.Mezzed.ID}) {
                            /call BroadCast ${IRCOn} ${EQBCOn} y "Found Mezzed Mob: ${Spawn[${BlurredMobID}].CleanName} <- ID:${BlurredMobID}"
                            /echo MEZ >> Found a Mezzed mob in Camp. <<
                            /varset AggroTargetID2 ${BlurredMobID}
                            /varset MyTargetID ${Target.ID}
                            /varset MyTargetName ${Target.CleanName}
                        } else {
                            /if (${Target.ID}) /squelch /alert add 3 id ${Target.ID}
                        }
                        /return
                    }
                }
                /varset MezMobFlag 0
            }
        :validatetarget
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist: validatetarget ID:${Target.ID} \agLine#: ${Macro.CurLine}
        /if (!${Target.ID}) {
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist: Validate Target - No target return \agLine#: ${Macro.CurLine}
            /return
        }
        | 3 sec delay to be able to target toons for buffs
        /if (${Target.Type.Equal[pc]} || ${Target.Type.Equal[mercenary]} || ${Target.Type.Equal[npc]} && !${AggroTargetID}) /delay 30
        /varset TempTargetID ${Target.ID}
        /call ValidateTarget
        | If target is not valid return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist Target:${Target.CleanName} ValidTarget:${ValidTarget} Marco Return:${Macro.Return} \agLine#: ${Macro.CurLine}
        /if (${ValidTarget}==0) {
            /if (${Target.ID}) /squelch /alert add 2 id ${Target.ID}
            /varset MyTargetID 0
            /varset MyTargetName
            /return
        }
        /if (${ValidTarget}) {
            /if (${Target.ID}!=${TempTargetID}) {
               /squelch /target clear
               /delay 10 !${Target.ID}
               /target id ${TempTargetID}
               /delay 10 ${Target.ID}
            }
           /varset MyTargetID ${Target.ID}
           /varset MyTargetName ${Target.CleanName}
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist MyTargetName:${MyTargetName} ID:${MyTargetID} \agLine#: ${Macro.CurLine}
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist Leave \agLine#: ${Macro.CurLine}
    /return   
| -------------------------------------------------------------------------------------
| SUB: Validate Target Combined Spawn and Target
| -------------------------------------------------------------------------------------
    Sub ValidateTarget(int SpawnID)
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Enter Target Name:${Target.CleanName} ID:${Target.ID} Spawn Name: ${Spawn[${SpawnID}].CleanName} ID:${SpawnID} \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare k int local
        /declare n int local
        /declare XTValid int local 0
        /declare PullValid int local 0
        /declare MobID int local 0
        /declare MobName string local
        /declare MobType string local
        /declare MeleeDistanceCheck int local ${MeleeDistance}       
        /varset ValidTarget 0
        /if (${SpawnID}) {
           /varset MobID ${Spawn[${SpawnID}].ID}
           /varset MobName ${Spawn[${SpawnID}].CleanName}
           /varset MobType ${Spawn[${SpawnID}].Type}
        } else {
           /varset MobID ${Target.ID}
           /varset MobName ${Target.CleanName}
           /varset MobType ${Target.Type}
        }
        /if (!${MobID}) /return NoTarget
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 1 \agLine#: ${Macro.CurLine}
        /if (${Select[${MobType},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,TRIGGER,TRAP,TIMER,MOUNT,Mercenary]}) /return BadTargetType
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 2 \agLine#: ${Macro.CurLine}
        | If mob found on ignore and not on xtarget skip
        /if (${MobsToIgnore.Find[${MobName}]} && ${Select[${MobID},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]}==0) /return MobOnIgnoreList
        | Check if target is somewhere on my extended target.        
        /if (${Select[${Role},tank]} && ${MobCount}<=${XSlotTotal} && ${Spawn[${MainAssist} ${MainAssistType} group].ID}) {
            /for n 1 to ${XSlotTotal}
                /if (${MobID}==${Me.XTarget[${n}].ID}) {
                    /varset XTValid 1
                    /break
                }
            /next n
            |:XTValidSkip
            /if (!${XTValid}) /return NotOnXTarget
        }
        /if (${Spawn[id ${MobID}].MaxRangeTo}>${MeleeDistance}) /varcalc MeleeDistanceCheck ${Spawn[id ${MobID}].MaxRangeTo}+5
        /if (${ReturnToCamp} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${CampYLoc},${CampXLoc}]}>${MeleeDistanceCheck} && !${Pulling} && ${Select[${Role},tank,pullertank,pettank,pullerpettank]}) /return OutofCampRadius
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 3 \agLine#: ${Macro.CurLine}
        | Only valid when pulling
        /if (${Pulling} && !${Pulled} ) {
            /if ((${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) /return OutofRadius
            /if (${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${MobID}].LineOfSight} && ${PullMoveUse.Equal[los]}) /return NoLOS            
            /if (${SpawnCount[loc ${Spawn[${MobID}].X} ${Spawn[${MobID}].Y} radius 12 pc]}>=1 && ${Pulling} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${Me.Y},${Me.X}]}>=16) /return PCNear
            /if (${Spawn[${MobID}].PctHPs}<=99) /return PullNotFullHealth
            /if (${Spawn[${MobID}].Level}<${PullMin} || ${Spawn[${MobID}].Level}>${PullMax}) /return BadLevel 
            /if (${Window[TargetOfTargetWindow].Open} && ${Target.ID}==${MobID}) {
            | - If mob I'm pulling is aggroed already by non damaging spell by someone else.
               /delay 10
               /if (${Me.TargetOfTarget.Type.Equal[PC]} && ${Me.TargetOfTarget.Name.NotEqual[${Me}]} && ${Group.Member[${Me.TargetOfTarget.Name}].Index}<1) /return PullToTTNotPuller
               /if (${Me.TargetOfTarget.Type.Equal[PET]} && ${Me.TargetOfTarget.Name.NotEqual[${Me.Pet.CleanName}]}) /return PullToTTNotMyPet
            }
            /if (${DebugPull} && !${MobsToPull.Find[null]}) /echo \atDEBUGPULL ValidateTarget ${MobsToPull} \agLine#: ${Macro.CurLine}
            /if (${MobsToPull.Find[ALL for all]} || ${MobsToPull.Equal[ALL]}) {
                /varset PullValid 1
            } else {
                /for j 1 to 25
                    /if (${DebugPull}) /echo \atDEBUGPULL ValidateTarget ${j} ${MobsToPull.Arg[${j},,]} ${MobName.Find[${MobsToPull.Arg[${j},,]}]} \agLine#: ${Macro.CurLine}
                    /if (${MobName.Find[${MobsToPull.Arg[${j},,]}]}) {
                        /varset PullValid 1
                        /break
                    }
                /next j
            }
            /if (!${PullValid}) /return PullMobNotonList
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 4 \agLine#: ${Macro.CurLine}
        /if (${MobName.Find[eye of]} && ${SpawnCount[pc ${MobName.Right[${Math.Calc[${MobName.Length}-7]}]}]}) /return Spell-Eye-PC        
        /if (${MobType.Equal[Pet]} && ${Spawn[${MobID}].Master.Type.Equal[PC]}) /return PET-PC
        /if (!${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) /return PC
        | This prevents characters on the Zek server from attacking PC targets in their group
        /if (${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) {
            /for i 0 to 5
                /if (${MobID}==${Group.Member[${i}].ID}) /return GroupMember
            /next i
            /if (${MobID}==${Spawn[=${MainAssist}].ID}) /return MA
        }
        /varset ValidTarget 1
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Leave \agLine#: ${Macro.CurLine}
    /return ${ValidTarget}
| -------------------------------------------------------------------------------------
| SUB: Combat
| -------------------------------------------------------------------------------------
    Sub Combat
        /doevents
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius} && ${Pulling}) /return
        /if (!${MyTargetID}) /return
        /if (!${Target.ID}) /return
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        /if (!${Target.LineOfSight}) /return
        /if (${DPSPaused} ) /return
        /if (${Me.Song[Rallying Call].ID} && !${Select[${Role},tank,pullertank]}) /return
        | Check if mob mezzed
        /if (${Group.MainAssist.ID} && ${Group.MainAssist.ID}!=${Me.ID} && ${Target.Mezzed.ID}) {
            /if (${Target.Mezzed.ID}) /echo Mob is mezzed ->> ${Target.CleanName} <<- I am not going to wake it since I am on assist.
            /delay 10
            /return
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat Enter \agLine#: ${Macro.CurLine}
        /if (${HealsOn}) /call CheckHealth
        /if (${ChaseAssist}) /call DoWeChase
        /declare CombatRadius int local ${If[${Spawn[id ${MyTargetID}].MaxRangeTo}>${MeleeDistance},${Math.Calc[${Spawn[id ${MyTargetID}].MaxRangeTo}+5]},${MeleeDistance}]}
        /declare SpamTankWait int local 1
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) {
                /varset GoMByPass 1
                /call DoMezStuff Combat1
                /varset GoMByPass 0
            }
        }
        | Check Target Hps and type NPC or NPC Pet
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat ${Spawn[${MyTargetID}].Name} PctHPs = ${Spawn[${MyTargetID}].PctHPs} AssistAt=${AssistAt} Distance = ${Spawn[${MyTargetID}].Distance} CombatRadius = ${CombatRadius} \agLine#: ${Macro.CurLine}
        | PullerPetTank and PetTank send in pet if mob in range
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Spawn[${MyTargetID}].Distance}<${PetAttackRange}) /call CombatPet
        /if (${AggroOn} && ${MainAssist.NotEqual[${Me}]} && ${Select[${Role},Tank]} && ${Spawn[${MyTargetID}].Distance}>${CombatRadius}) /call AggroCheck
        /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]} && ${Spawn[${MyTargetID}].PctHPs}<=${AssistAt} && (${Spawn[${MyTargetID}].Distance}<${CombatRadius} || ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius})) {
            /if (!${CombatStart}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat Setting CombatStart to 1  \agLine#: ${Macro.CurLine}
                /if (${Cursor.ID}) /call CheckCursor Combat
                /varset MercAssisting 0
                /varset CombatStart 1
                /echo  ATTACKING -> ${Spawn[${MyTargetID}].CleanName} <-
                /if (${IAmABard}) /call DoBardStuff
                /if (${Select[${Role},Tank,PullerTank,Hunter]}) /call BroadCast ${IRCOn} ${EQBCOn} y "TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
                /if (${Select[${Role},petTank,pullerpettank,hunterpettank]}) /call BroadCast ${IRCOn} ${EQBCOn} y "${Me.Pet.CleanName} is TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
                | Moloing as as puller turn off puller tag in group so tank merc attacks and doesn't wait for me to get 2 feet near them.
                /if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<${CampRadius}) /call AssignGroupRole unset "${Me.CleanName}" 3
            }
            /if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID})) /face ${If[${FaceMobOn}==1,fast nolook,nolook]}
            /if (!${Me.FeetWet}) /look 0
            /if (${Select[${Role},pettank,pullerpettank]} && !${Attacking}) { 
                /pet attack
                /pet swarm
                /varset Attacking 1
            }    
            /if (${MeleeOn} && !${Attacking}) {
                /varset Attacking 1
                /if (${Me.Sitting}) /stand
                /if (!${AutoFireOn}) {
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat Attack On \agLine#: ${Macro.CurLine}
                    | Speed up tanks attacking inc mobs MQ2Melee /killthis can cause a delay
                    /if (${Select[${Role},tank,pullertank,hunter]}) {
                        /if (${Me.Ability[Taunt]} && ${Me.AbilityReady[Taunt]})  /doability Taunt
                        /if (!${Me.Combat} && ${Target.ID}) /attack on
                        /if (${Me.FeetWet}) {
                            /stick uw ${StickHow} ${StickDistUW} id ${MyTargetID}
                        } else {
                            /stick ${StickHow} ${StickDist} id ${MyTargetID}
                        }
                    }
                    | Use zerker kick in the teeth line before melee
                    /if (${Defined[BeforeCombat]} && !${BeforeCombat.Find[disc]} && ${Me.CombatAbilityReady[${Spell[${BeforeCombat}].RankName}]} && !${Me.Combat}) {
                        /call CastWhat "${BeforeCombat}" ${MyTargetID} Combat
                        /delay 2
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo ** ${BeforeCombat} on >> ${Spawn[${MyTargetID}].CleanName}
                    }
                    /if (${StickHow.NotEqual[0]} && ${StickHow.NotEqual[null]}) {
                        /if (${Me.FeetWet}) {
                            /stick ${StickDistUW} uw ${StickHow} id ${MyTargetID}
                        } else {
                            /stick ${StickDist} ${StickHow} id ${MyTargetID}
                        }
                    } else /if (${Spawn[${MyTargetID}].Distance}>13) {
                        /if (${Me.FeetWet}) {
                            /moveto id ${MyTargetID} uw mdist 13
                        } else {
                            /moveto id ${MyTargetID} 
                        }
                    }
                    /if (!${UseMQ2Melee} && ${MeleeOn}) {
                        |/if (${Spawn[${MyTargetID}].Distance}>13) /moveto id ${MyTargetID}
                        /if (${Target.ID}) /attack on
                    } else {
                        /killthis
                    }
                    | Move closer if Z distance more than 4 due to levitation
                    /call ZAxisCheck ${ZDist} 4.1
                }
            }
            /varset  MyExp ${Me.PctExp}
            /varset  MyAAExp ${Me.PctAAExp}
            | Turn on check for mez mob in camp that has been mem blurred if i am a tank type
            /if (${Select[${Role},tank,pullertank,pettank,pullerpettank]}) /varset MezMobFlag 1
            :Attack
                /doevents
                |/if (${DPSMeter}) /doevents YouHit
                /if (${MercOn} && !${MercAssisting} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
                /if (!${UseMQ2Melee} && ${Spawn[${MyTargetID}].Distance}>13 && ${MeleeOn}) /moveto id ${MyTargetID}
                /if (${MezOn}) {
                    /varset MezBroke 0
                    /doevents MezBroke
                    /if (!${MezBroke}) {
                        /varset GoMByPass 1
                        /call DoMezStuff Combat2
                        /varset GoMByPass 0
                    }
                }
                /if (${AEOn}) /call AECheck
                /if (${AggroOn}) /call AggroCheck
                /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && ${PetOn} && ${PetCombatOn}) /call CombatPet
                /if (${HealsOn}) /call CheckHealth
                /if (${CuresOn}) /call CheckCures
                /if (${AutoRezOn}) /call RezCheck
                /if (!${NamedCheck} && ${BurnAllNamed}) /call NamedWatch
                /if (${DebuffAllOn} && (!${Role.Equal[puller]} || !${ChainPull})) {
                   | Debuff stuff
                   /call DoDebuffStuff ${MyTargetID}
                   |When returning the mob you were started on could be dead, so don't keep trying to kill a corpse.
                   /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                       /call CombatReset 0 combat
                       /return
                   }
                }
                /if (${DPSOn} && (!${Role.Equal[puller]} || !${ChainPull})) /call CombatCast
                /call CastMana Combat
                /call WriteDebuffs
                /if (${IAmABard}) /call DoBardStuff
                /if (${DPSOn} || ${MeleeOn} || ${PetOn}) /call CombatTargetCheck
                /if (${Attacking} && ${MeleeOn} && ${Target.PctHPs}<=${Math.Calc[${AssistAt}-5]} && ${Target.Distance}<${CombatRadius} && !${AutoFireOn}) {
                    /if (!${Me.Combat}) {
                        /if (${Me.Sitting}) /stand
                        /if (!${UseMQ2Melee}) {
                            /if (${Me.FeetWet}) {
                                /stick ${StickDistUW} uw ${StickHow} id ${MyTargetID}
                            } else {
                                /stick ${StickDist} ${StickHow} id ${MyTargetID}
                            }
                            /if (${Target.ID}) /attack on
                        } else {
                            /killthis
                        }
                    }
                    |/if (${StickHow.NotEqual[0]} && !${Stick.Active} && ${Target.Distance}>15) {
                    /if (${StickHow.NotEqual[0]} && ${StickHow.NotEqual[null]} && !${Stick.Active}) {
                        /if (${Me.FeetWet}) {
                            /stick uw ${StickHow} id ${MyTargetID}
                        } else {
                            /stick ${StickHow} id ${MyTargetID}
                        }
                    }
                } else /if (${Attacking} && ${MainAssist.Equal[${Me}]} && !${Me.Combat} && ${MeleeOn}) {
                    /if (${DebugCombat}) { 
                        /beep
                        /echo \atDEBUGCOMBAT im in the :Attack loop but attack is not on Attacking=${Attacking} MeleeOn=${MeleeOn} Target.PctHPs=${Target.PctHPs} Math.Calc[AssistAt-5]=${Math.Calc[${AssistAt}-5]} Target.Distance=${Target.Distance} CombatRadius=${CombatRadius} AutoFireOn=${AutoFireOn} \agLine#: ${Macro.CurLine}
                    }
                    /if (${Target.ID}) /attack on
                }
                /if (${CombatStart} && ${AutoFireOn}) {
                    /if (${Target.ID}==${MyTargetID} && !${Bool[${Target.Mezzed.ID}]}) /range
                }
                /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                    /call CombatReset 0 combat
                    /return
                }
                /if (${Role.Equal[puller]} && ${ChainPull}) {
                   /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=75) {
                        /if (!${ChainPullHold} && ${MobCount}<2 && !${Me.XTarget[${XTSlot2}].ID} && ${If[${Target.Named},0,1]}==1) {
                            /if (${Target.ID} && ${Target.PctHPs} < ${ChainPullHP}) {
                                /call FindMobToPull 0
                                /if (${Macro.Return}>0 && (!${PullXPCheck} || (${Spawn[${ChainPullTemp}].Distance}<${Math.Calc[${PullRange}+400]} && ${PullXPCheck})) && ${Me.TargetOfTarget.Name.NotEqual[${Me.CleanName}]} && ${Me.PctAggro}<50) {
                                    /varset PullMob ${Macro.Return}
                                    /if (${UseMQ2Melee}) /squelch /melee melee=0
                                    /if (${Stick.Active}) /squelch /stick off 
                                    /squelch /attack off
                                    /delay 10
                                    /if (${UseMQ2Melee}) /squelch /melee melee=1
                                    /varset ChainPull 2
                                    /varset MyTargetID 0
                                    /varset Attacking 0
                                    /return
                                }
                            }
                        }
                    } else /if (${SpamTankWait}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} r "Holding Pulls. Tank to far from camp."
                        /varset SpamTankWait 0 
                    }
                }   
                /if (${Role.Equal[puller]} && ${ChainPull} && ${DebuffAllOn}) /call DebuffCast ${MyTargetID} 1 
                /if (${Role.Equal[puller]} && ${ChainPull} && ${DPSOn}) /call CombatCast     
                /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]} || ${Spawn[${MyTargetID}].ID} || !${Me.Feigning}) /goto :Attack
        } else /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && (${Spawn[${MyTargetID}].Distance}<${CombatRadius} || ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius})) {
            /if (${PetOn} && ${PetCombatOn} && !${PetAttack} && !${DPSPaused}) /call CombatPet
        } else {
            /if (${MezOn}) {
                /varset MezBroke 0
                /doevents MezBroke
                /if (!${MezBroke}) {
                    /varset GoMByPass 1
                    /call DoMezStuff Combat3
                    /varset GoMByPass 0
                }
            }
            /if (${DebuffAllOn}==2 && ${MyTargetID} && ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius} && ${AggroTargetID}) /call DoDebuffStuff ${MyTargetID}
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CombatTargetCheck
| -------------------------------------------------------------------------------------
    Sub CombatTargetCheck
        | If mob is dead return
        /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) /return 
        | Check target matches MA if group mainassist assigned and MA is in group
        /if (${Spawn[=${MainAssist}].ID} && ${Group.MainAssist.ID} && ${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID}) {
            /if (${Target.ID}!=${Me.GroupAssistTarget.ID} && ${Group.MainAssist.ID}!=${Me.ID}) {
                /if (${MyTargetID}!=${Me.GroupAssistTarget.ID} && ${Spawn[id ${Me.GroupAssistTarget.ID} npc].ID}) {
                    /echo My target does not match MA's. Switching to new target.
                    /varset MyTargetID ${Me.GroupAssistTarget.ID}
                    /varset MyTargetName ${Spawn[id ${Me.GroupAssistTarget.ID}].CleanName}
                }
            }
        }
        /if (${Target.ID}!=${MyTargetID} && ${Spawn[${MyTargetID}].ID}) {
            /squelch /target id ${MyTargetID}
            /delay 10 ${Target.ID}==${MyTargetID}
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Combat Cast
| -------------------------------------------------------------------------------------
    Sub CombatCast
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast Enter \agLine#: ${Macro.CurLine}
        /declare i           int      local 0
        /declare DPSStart    int      local ${Math.Calc[${DebuffCount}+1]}
        /if (${DPSStart}>${DPS.Size}) /return
        /declare DPSAt       int      local ${AssistAt}
        /declare DPSTargetID int      local ${MyTargetID}
        /declare DPSItem     string   local
        /declare DPSPart1    string   local 
        /declare DPSPart2    string   local 
        /declare DPSPart3    string   local 
        /declare DPSPart4    string   local 
        /declare DPSPart5    string   local
        /declare WeaveCheck  int      local 0
        /call WriteDebuffs
        /for i ${DPSStart} to ${DPS.Size}       
            /doevents
            /call CombatTargetCheck
            /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                /if (${DebugCombat}) /echo CombatCast: Return from CombatCast cause my target is a corpse or dead or DPSPaused ${DPSPaused}. \agLine#: ${Macro.CurLine}
                /return
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast ${Spell[${DPS[${i}].Arg[1,|]}].RankName} ${DPS[${i}].Arg[1,|]} !${Me.SpellReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AltAbilityReady[${DPS[${i}].Arg[1,|]}]} && !${Me.CombatAbilityReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AbilityReady[${DPS[${i}].Arg[1,|]}]} \agLine#: ${Macro.CurLine}
            /if (!${Cast.Ready[${DPS[${i}].Arg[1,|]}]} && !${Me.SpellReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AltAbilityReady[${DPS[${i}].Arg[1,|]}]} && !${Me.CombatAbilityReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AbilityReady[${DPS[${i}].Arg[1,|]}]})  /goto :skipcast
            |--- only call code for GroupEscape kick off.
            /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
            /if (${MezOn}) {
                /varset MezBroke 0
                /doevents MezBroke
                /if (!${MezBroke}) {
                    /varset GoMByPass 1
                    /call DoMezStuff CombatCast
                    /varset GoMByPass 0
                }
            }
            /if (${HealsOn}) /call CheckHealth
            /if (${CuresOn}) /call CheckCures
            /if (${Cursor.ID}) /call CheckCursor CombatCast
            /if (${Int[${DPS[${i}].Arg[2,|]}]} > 0 && ${DPS[${i}].Arg[3,|].NotEqual[null]}) {
                /varset DPSPart1 ${DPS[${i}].Arg[1,|]}
                /varset DPSPart2 ${DPS[${i}].Arg[2,|]}
                /if (${Select[${DPS[${i}].Arg[3,|]},if,ifme,notif,notifme]}>0) {
                   /if (${DPS[${i}].Arg[5,|].NotEqual[null]}) /varset DPSPart3 ${DPS[${i}].Arg[5,|]}
                   /varset DPSPart4 ${DPS[${i}].Arg[3,|]}
                   /varset DPSPart5 ${DPS[${i}].Arg[4,|]}
                } else {
                   /varset DPSPart3 ${DPS[${i}].Arg[3,|]}
                   /varset DPSPart4 ${DPS[${i}].Arg[4,|]}
                   /varset DPSPart5 ${DPS[${i}].Arg[5,|]}
                }
            } else {
                /varset DPSPart1 ${DPS[${i}].Arg[1,|]}
                /varset DPSPart2 ${DPS[${i}].Arg[2,|]}
                /varset DPSPart3
                /varset DPSPart4
                /varset DPSPart5
            }
            /if (${ConditionsOn} && ${DPSCOn} && ${If[${DPSCond[${i}]},0,1]}) /goto :skipcast
            /if (${Select[${DPSPart3},Me,MA]}==0 && (${Me.CombatAbility[${DPSPart1}]} || ${Me.Ability[${DPSPart1}]})) {
                 /call CastWhat "${DPSPart1}" ${DPSTargetID} DPS
                 /goto :MeleeCast
            }
            /if (${Target.Mezzed.ID} && ${MainAssist.NotEqual[${Me}]} && ${Spell[${DPSPart1}].Category.NotEqual[Utility Detrimental]}) {
                /if (${DebugCombat}) /echo Skipping spell in CombatCast because target is mezzed and I'm not mainassist and it will wake up the mob. \agLine#: ${Macro.CurLine}
                /goto :skipcast
            }
            /if (!${DPS[${i}].Length}) {
                /if (${DebugCombat}) CombatCast: /echo im skipping in CombatCast cause there is no spell: DPS${i}  \agLine#: ${Macro.CurLine}
                /goto :skipcast    
            }
            /if (${Spell[${DPSPart1}].Subcategory.Equal[Mana Drain]} && ${MyTargetID} && !${Spawn[${MyTargetID}].Class.CanCast}) {
                    /if (${DebugCombat}) /echo  CombatCast: I'm skipping ${Spell[${DPSPart1}]} on ${Spawn[${MyTargetID}]} in CombatCast cause we shouldnt try to mana drain non caster mobs \agLine#: ${Macro.CurLine}
                    /goto :skipcast            
            }
            /if (${MercOn} && !${MercAssisting} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
            /if (${AEOn}) /call AECheck
            /if (${AggroOn}) /call AggroCheck
            /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && ${PetOn} && ${PetCombatOn}) /call CombatPet
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast ${DPS[${i}]} ${DPSPart1} ${DPSPart2} ${DPSPart3} ${DPSPart4} ${DPSPart5} \agLine#: ${Macro.CurLine}
            | - Check for 2nd value in dps for mob health
            /if (${DPSPart2.Length} && ${Int[${DPSPart2}]}>0) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast ${DPSPart1} \agLine#: ${Macro.CurLine}
                /varset DPSAt ${DPSPart2}
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast ${DPSAt} \agLine#: ${Macro.CurLine}
                /if (${DPSPart3.Equal[MA]}) /varset DPSTargetID ${Spawn[=${MainAssist}].ID}
                /if (${DPSPart3.Equal[Me]} || ${DPSPart3.Equal[Feign]}) /varset DPSTargetID ${Me.ID}
                | Check if self combat buff is active
                /if (${DPSPart3.Equal[Me]}) {
                    /if (${DPSPart4.Length} && ${DPSPart4.NotEqual[null]}) {
                        /if (${Select[${DPSPart4},if,ifme]}>0 && !${Me.Buff[${DPSPart5}].ID} && !${Me.Song[${DPSPart5}].ID}) /goto :skipcast
                        /if (${Select[${DPSPart4},notif,notifme]}>0 && (${Me.Buff[${DPSPart5}].ID} || ${Me.Song[${DPSPart5}].ID})) /goto :skipcast
                    } else /if (${Me.Buff[${DPSPart1}].ID} || ${Me.Song[${DPSPart1}].ID}) {
                        /goto :skipcast
                    }
                }
            }
            /if (${Me.Class.Name.Equal[Cleric]} && ${DPSPart1.Find[Hammer]} && ${Me.Pet.ID}) /goto :skipcast
            /if (${Me.Class.Name.Equal[Wizard]} && ${Me.Pet.ID} && (${DPSPart1.Find[sword]} || ${DPSPart1.Find[blade]})) /goto :skipcast
            /if (${Spawn[${DPSTargetID}].PctHPs}<${DPSSkip}) /goto :skipcast
            /if (${DPSPart1.Equal[NULL]}) /goto :skipcast
            /if (${ABTimer${i}}) /goto :skipcast
            /if (${DPSTimer${i}}) /goto :skipcast
            /if (${FDTimer${i}}) /goto :skipcast
            /if (!${Select[${EverQuest.Server},zek]} && ${Spawn[${DPSTargetID}].Type.NotEqual[NPC]} && ${Spawn[${DPSTargetID}].Master.Type.NotEqual[NPC]}) /goto :skipcast
            /if (${Spawn[${DPSTargetID}].PctHPs}>${DPSAt} && ${DPSOn}==1) /goto :skipcast
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast Spell: ${DPSPart1} Target: ${DPSTargetID}=${Target.ID} Timer: ${DPSTimer${i}} DPSOn: ${DPSOn} \agLine#: ${Macro.CurLine}
            /if (${Select[${DPSPart3},Me,MA]} && ${Me.Combat} && ${MainAssist.NotEqual[${Me}]}) {
                /attack off
                /delay 10 !${Me.Combat}
            }
            /if (${DPSPart4.Length} && ${DPSPart4.NotEqual[null]}) {
                /if (${Select[${DPSPart4},if,notif]}>0) {
                    /if (${DPSTargetID}!=${Target.ID}) {
                        /target id ${DPSTargetID}
                        /delay 2s ${Target.ID}==${DPSTargetID} && ${Target.BuffsPopulated}==TRUE
                    }
                    /if (${DPSPart4.Equal[if]} && !${Target.Buff[${DPSPart5}].ID}) /goto :skipcast
                    /if (${DPSPart4.Equal[notif]} && ${Target.Buff[${DPSPart5}].ID}) /goto :skipcast
                } else /if (${Select[${DPSPart4},ifme,notifme]}>0) {
                    /if (${DPSPart4.Equal[ifme]} && !${Me.Buff[${DPSPart5}].ID} && !${Me.Song[${DPSPart5}].ID}) /goto :skipcast
                    /if (${DPSPart4.Equal[notifme]} && (${Me.Buff[${DPSPart5}].ID} || ${Me.Song[${DPSPart5}].ID})) /goto :skipcast
                } else {
                    /echo What The! I wasn't aware there was a ${DPSPart4} paramater. You may want to check your settings.
                }
            }
            | Only cast spells with weave tag during global cooldown
            /if (${WeaveArray.Size}>=1 && ${Me.SpellInCooldown}) {
                /call WeaveStuff ${DPSTargetID}
                /varset WeaveCheck 1
                /goto :skipcast
            } else {
                /call CastWhat "${DPSPart1}" ${DPSTargetID} DPS
            }    
            /if (${DebugCombat}) /echo DEBUGCOMBAT CombatCast MacroReturn: ${Macro.Return} \agLine#: ${Macro.CurLine}
            :MeleeCast
            /if (${Macro.Return.Equal[CAST_RESIST]}) {
                /echo ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} << - RESISTED
                /if (${DPSPart3.Length} && ${DPSPart3.Equal[once]}) {
                    /varset DPSTimer${i} 5m
                    /goto :skipcast
                }
            }
            /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
                /echo ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} << - DID NOT TAKE HOLD
                /varset DPSTimer${i} 5m
                /goto :skipcast
            }
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} <<
                | Set timer for spells labeled once 5m
                /if (${DPSPart3.Length} && ${DPSPart3.Equal[once]}) {
                    /varset DPSTimer${i} 5m
                    /goto :skipcast
                | Timers for items    
                } else /if (${FindItemCount[=${DPSPart1}]}) {
                    /varcalc DPSTimer${i} ${FindItem[=${DPSPart1}].Spell.Duration.TotalSeconds}*10
                    /goto :skipcast
                | FD to lose aggro
                } else /if (${Select[${Me.Class.ShortName},BST,MNK,NEC,SHD]} && ${DPSPart3.Equal[Feign]}) {
                    /delay 30 ${Me.State.Equal[FEIGN]}
                    /varset FDTimer${i} 60s
                    /delay 10s ${Me.State.NotEqual[FEIGN]}
                    /if (${Me.State.Equal[FEIGN]} && !${Me.Sitting}) /stand
                | Timers for spells
                } else /if (${Me.Book[${DPSPart1}]}) {
                    | - Attack Buff Timers are seperate. DPS timers are cleared after every fight.
                    /if (${Select[${DPSTargetID},${Me.ID},${Spawn[=${MainAssist}].ID}]}) {
                        /varcalc ABTimer${i} (${Spell[${DPSPart1}].Duration.TotalSeconds}*${DurationMod})*10
                        /if (${DebugCombat}) /echo DEBUGCOMBAT CombatCast Spell: ${DPSPart1} Timer: ABTimer${i} ${ABTimer${i}} Line#: ${Macro.CurLine}
                        /goto :skipcast
                    | - Custom timer for counterbias
                    } else /if (${Me.Class.Name.Equal[Shaman]} && ${DPSPart1.Find[counterbias]}) {
                        /varset DPSTimer${i} 1.5m
                        /goto :skipcast
                    | Custom timer for Chanter suffocation
                    } else /if (${Me.Class.Name.Equal[enchanter]} && ${DPSPart1.Find[suffocation]}) {
                        /varset DPSTimer${i} 1m
                        /goto :skipcast
                    | Custom timer for Beastlord Feralgia Timer
                    } else /if (${Me.Class.Name.Equal[Beastlord]} && ${DPSPart1.Find[feralgia]}) {
                        /varset DPSTimer${i} 1.5m
                        /goto :skipcast
                    | Regular spells
                    } else /if (${Spell[${DPSPart1}].Duration.TotalSeconds}>0) {
                        /varcalc DPSTimer${i} ${Spell[${DPSPart1}].Duration.TotalSeconds}*10
                        /goto :skipcast
                    | Spells with no timers assign DPS interval
                    } else {
                        /varset DPSTimer${i} ${DPSInterval}s
                        /goto :skipcast
                    }
                | AA and disc timers
                } else /if (${Spell[${DPSPart1}].Duration}>0 && (${Me.AltAbility[${DPSPart1}]} || ${Me.CombatAbility[${DPSPart1}]})) {
                    /varcalc DPSTimer${i} ${Spell[${DPSPart1}].Duration.TotalSeconds}*10
                    /goto :skipcast
                | AA and disc with no timers assign DPS interval
                } else {
                    /varset DPSTimer${i} ${DPSInterval}s
                    /goto :skipcast
                }
            }
            :skipcast
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast ${DPS[${i}].Arg[1,|]} ${Macro.Return} DPSTimer${i} ${DPSTimer${i}} \agLine#: ${Macro.CurLine}
            /if (${Select[${DPSPart3},Me,MA]}) /call CombatTargetCheck
            | Reset values if 2nd value in dps for mob health exists
            /if (${DPSPart2.Length} && ${DPSPart2.NotEqual[null]}) {
                /varset DPSAt ${AssistAt}
                /varset DPSTargetID ${MyTargetID}
            }
            /if (${WeaveArray.Size}>=1 && (${Me.SpellInCooldown} || !${WeaveCheck})) {
                /call WeaveStuff ${DPSTargetID}
            }
            /if (${MashArray.Size}>=1) /call MashButtons
            /varset WeaveCheck 0
        /next i
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast: Leave \agLine#: ${Macro.CurLine}
    /return 
| -------------------------------------------------------------------------------------
| SUB: WeaveStuff
| -------------------------------------------------------------------------------------    
    Sub WeaveStuff(TarID)
        /declare i int local
        /declare DPSat1 int Local 0
        /declare DPSWeaveSpell string local 
        /for i 1 to ${WeaveArray.Size}
            /varset DPSat1 ${Int[${WeaveArray[${i}].Arg[2,|]}]}
            /varset DPSWeaveSpell ${WeaveArray[${i}].Arg[1,|]}
            /if (${Debug}) /echo \at Cast DPSWeaveSpell:(${DPSWeaveSpell}) at (${DPSat1}%) \agLine#: ${Macro.CurLine}
            /if (${DPSat1}==0) /return 
            /if (!${ConditionsOn} || !${DPSCOn} || ${If[${WeaveCond[${i}]},1,0]}) {
                /if (${Me.AltAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.ItemReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.CombatAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} ||  ${Me.AbilityReady[${WeaveArray[${i}].Arg[1,|]}]}) {
                    /if (${Spawn[${TarID}].PctHPs}<=${DPSat1}) {
                        /call CastWhat "${DPSWeaveSpell}" ${TarID}
                        /if (${Macro.Return.Equal[CAST_SUCCESS]})  {
                            /echo -- Weaving: ${DPSWeaveSpell}
                            /delay 5
                            /return
                        }
                    }
                } 
            }
        /next i
    /return 0
| -------------------------------------------------------------------------------------
| SUB: Mash Buttons
| -------------------------------------------------------------------------------------    
    Sub MashButtons(TarID)
        /declare i int local
        /declare MashThis string local
        /for i 1 to ${MashArray.Size}
            /doevents
            /varset MashThis ${MashArray[${i}].Arg[1,|]}
            /if (${MashThis.Length}==0 || ${MashThis.Equal[null]}) /return 
            /if (!${ConditionsOn} || !${DPSCOn} || ${If[${MashCond[${i}]},1,0]}) {
                /if (${FindItem[=${MashThis}].ID} && ${Me.ItemReady[${MashThis}]}) {
                    /useitem "${MashThis}"
                    /echo ## Mashing >> ${MashThis} <<
                } else /if (${Me.AltAbility[${MashThis}]} && ${Me.AltAbilityReady[${MashThis}]} && ${Me.AltAbility[${MashThis}].Type}!=5 && ${MashThis.NotEqual[twincast]})  { 
                    /alt act ${Me.AltAbility[${MashThis}].ID}
                    /echo ## Mashing >> ${MashThis} <<
                } else /if (${Me.CombatAbility[${MashThis}]} && !${Me.CombatAbilityTimer[${MashThis}]} && ${Me.CombatAbilityReady[${MashThis}]} && ${Spell[${MashThis}].EnduranceCost}<${Me.Endurance}) {
                    /disc ${Me.CombatAbility[${Me.CombatAbility[${MashThis}]}].ID}
                    /echo ## Mashing >> ${MashThis} <<
                } else /if (${Me.Ability[${MashThis}]} && ${Me.AbilityReady[${MashThis}]}) {
                    /doability "${MashThis}"
                    /echo ## Mashing >> ${MashThis} <<
                }
                /delay 3
            }
        /next i
    /return 0
| -------------------------------------------------------------------------------------
| SUB: CombatPet
| -------------------------------------------------------------------------------------
    Sub CombatPet
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatPet: Enter \agLine#: ${Macro.CurLine}
        /if (${PetAttack} || ${DPSPaused}) /return
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Me.Pet.ID} && !${Me.Pet.Combat}) /pet attack 
        /if (${Me.Pet.ID} && (${PetAttack} || ${Me.Pet.Combat})) /return
        /call CombatTargetCheck
        /if (!${Target.Mezzed.ID} && !${Me.Pet.Combat}) {
            /if (${Select[${Role},pettank,pullerpettank]}) {
                /if ((${Me.Pet.Stance.NotEqual[FOLLOW]}) && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) || (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius})) /pet follow            
            }
            /pet attack
            /pet swarm
            /delay 10
            | Set timer to check if pet is attacking every 3s 
            /varset PetAttack 30
        } else {
            /if (${Target.Mezzed.ID} && ${Select[${Role},pettank,pullerpettank]} && ${PetBreakMezSpell.NotEqual[null]}) /call BreakMez
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatPet: Leave \agLine#: ${Macro.CurLine}
    /return  
| -------------------------------------------------------------------------------------
| SUB: BreakMez - Writtten by Trehuggindruid for KissAssist
| -------------------------------------------------------------------------------------
    Sub BreakMez   
        /if (${PetBreakMezSpell.Equal[null]}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT BreakMez: Enter \agLine#: ${Macro.CurLine}
        /declare PetBreakMezTargetID int local ${MyTargetID}
        /echo ATTEMPTING TO BREAK MEZ ON: (${Target.CleanName}) ID:(${PetBreakMezTargetID})
        /while (${Target.Mezzed.ID}) {
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT Break Mez with: - ${PetBreakMezSpell} \agLine#: ${Macro.CurLine}
            /call CastWhat "${PetBreakMezSpell}" ${PetBreakMezTargetID} BreakMez        
            |--- DO NOT CHANGE THIS CONDITION!!!!!!
            /if (${Target.Mezzed.ID}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT Mez NOT broken, trying again! \agLine#: ${Macro.CurLine}
            } 
        }
        /varset PetAttack 0
        /echo + Mez broken !
        /if (${Me.Pet.ID} && !${Me.Pet.Combat}) /pet attack
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT BreakMez: Leave \agLine#: ${Macro.CurLine}
    /return 
| -------------------------------------------------------------------------------------
| SUB: CombatReset
| -------------------------------------------------------------------------------------
    Sub CombatReset(int SFlag, string CalledFrom)
        /if (${DPSMeter}) /doevents YouHit
        /declare DPSCalc string local
        /declare DPSTCalc string local
        /declare DPSMyDam string local
        /declare DPSPCalc string local
        /declare DPSPTCalc string local
        /declare DPSMyPetDam string local
        /declare DPSMeAndPetDam string local
        /declare DPSMPCalc string local
        /declare DPSMPTCalc string local
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatReset: Enter ${SFlag} ${CalledFrom} \agLine#: ${Macro.CurLine}
        /if (${MyTargetID} && ${CombatStart} && ${DPSMeter} && !${SFlag}) {
            /echo SLAIN >> ${MyTargetName} << 
            /echo EXP: ${If[${Me.PctExp}<${MyExp},${Math.Calc[100-${MyExp}+${Me.PctExp}]},${Math.Calc[${Me.PctExp}-${MyExp}]}]}% AAEXP: ${If[${Me.PctAAExp}<${MyAAExp},${Math.Calc[100-${MyAAExp}+${Me.PctAAExp}]},${Math.Calc[${Me.PctAAExp}-${MyAAExp}]}]}%
            /popup SLAIN >> ${MyTargetName} << EXP: ${If[${Me.PctExp}<${MyExp},${Math.Calc[100-${MyExp}+${Me.PctExp}]},${Math.Calc[${Me.PctExp}-${MyExp}]}]}% AAEXP: ${If[${Me.PctAAExp}<${MyAAExp},${Math.Calc[100-${MyAAExp}+${Me.PctAAExp}]},${Math.Calc[${Me.PctAAExp}-${MyAAExp}]}]}%
            /if (!${DPSLastTime}) {
                /echo DPS Meter: Was a timing error skipping DPS Meter
            } else {
                | My damage calculation
                /varset DPSCalc ${Math.Calc[${DPSTotal}/${DPSLastTime}]}
                /call CommaMeBro ${DPSCalc}
                /if (${Macro.Return.Length}) /varset DPSMyDam ${Macro.Return}
                /call CommaMeBro ${DPSTotal}
                /if (${Macro.Return.Length}) /varset DPSTCalc ${Macro.Return}
                /echo \aw DPS Meter - \ay Your Total Damage: \at ${DPSTCalc} - \ay Fight Time: \aw ${DPSLastTime}s - \ay DPS: \ag ${DPSMyDam}
                |/bc DPS Meter - ${Me} - Total Damage: ${DPSTCalc} - Fight Time: ${DPSLastTime}s - DPS:  ${DPSMyDam}
                | My pet damage calculation
                /if (${DPSPetTotal}) {
                    /varset DPSPCalc ${Math.Calc[${DPSPetTotal}/${DPSLastTime}]}
                    /call CommaMeBro ${DPSPCalc}
                    /if (${Macro.Return.Length}) /varset DPSMyPetDam ${Macro.Return}
                    /call CommaMeBro ${DPSPetTotal}
                    /if (${Macro.Return.Length}) /varset DPSPTCalc ${Macro.Return}
                    /echo \aw DPS Meter - \ay Pet Total Damage: \at ${DPSPTCalc} \ay - Pet DPS: \ag ${DPSMyPetDam}
                    | Me + pet damage calculation
                    /varset DPSMPCalc ${Math.Calc[(${DPSTotal}+${DPSPetTotal})/${DPSLastTime}]}
                    /call CommaMeBro ${DPSMPCalc}
                    /if (${Macro.Return.Length}) /varset DPSMeAndPetDam ${Macro.Return}
                    /call CommaMeBro ${Math.Calc[${DPSTotal}+${DPSPetTotal}]}
                    /if (${Macro.Return.Length}) /varset DPSMPTCalc ${Macro.Return}
                    /echo \aw DPS Meter - \ay You + Pet Total Damage: \at ${DPSMPTCalc} \ay - DPS: \ag ${DPSMeAndPetDam}
                }
                /popup Total Damage: ${DPSTCalc} - Fight Time: ${DPSLastTime}s - DPS: ${DPSMyDam}
                /if (${Defined[ParseDPS]} || ${DPSWriteOn}) {
                    /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-${Me.Class}-${Me.Level}" "Total Damage: ${DPSTCalc} - Fight Time: ${DPSLastTime}s - DPS: ${DPSMyDam}"
                    /if (${DPSPetTotal}) {
                        /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-MyPet" "My Pet Total Damage: ${DPSPTCalc} - Pet DPS: ${DPSMyPetDam}"
                        /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-Combined" "Me + Pet Total Damage: ${DPSMPTCalc} - Combined DPS: ${DPSMeAndPetDam}"
                    }
                }
            }
        }
        /declare i int local
        /declare j int local
        /call MobRadar ${MeleeDistance} CombatReset
        /for j 1 to 50
            /if (${AddsArray[${j},1].Equal[${MyTargetID}]}) /call RemoveFromArray AddsArray ${j}
            /if (${MobCount}==0) /call RemoveFromArray AddsArray ${j}
            /if (${MezOn} && ${j}<=13) {
                /if (${MezArray[${j},1].Equal[${MyTargetID}]}) /call RemoveFromArray MezArray ${j}
                |/if (${MezCount[${j}]}==0) /call RemoveFromArray MezArray ${j}
            }
        /next j
        /if (${MezOn}) {
            /if (${MezImmuneIDs.Find[|${MyTargetID}]}) /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MyTargetID},]}
            /varset j 1
            /while (${Bool[${MezImmuneIDs.Arg[${j},|].Length}]}) {
                /if (!${Bool[${Spawn[${MezImmuneIDs.Arg[${j},|]}].ID}]} || ${Spawn[${MezImmuneIDs.Arg[${j},|]}].Type.Equal[corpse]} ) {
                    /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MezImmuneIDs.Arg[${j},|]},]}
                } else {
                    /varcalc j ${j}+1
                }
            }
        }
        /varset AggroTargetID2 0
        /varset MyTargetID 0
        /varset MyTargetName
        /varset ValidTarget 0
        /varset MercAssisting 0
        /varset CombatStart 0
        /varset Pulled 0
        /varset NamedCheck 0
        /call PullReset
        /if (${UseMQ2Melee}) /squelch /melee melee=0
        /squelch /attack off
        /squelch /target clear
        /varset Attacking 0
        /if (${DPSOn}) {
            /for i 1 to ${DPS.Size}
                /if (${Int[${DPS[${i}].Arg[2,|]}]}<101) { 
                    /varset DPSTimer${i} 0
                    /varset FDTimer${i}  0
                }
            /next i
        }
        /if (${Me.Pet.ID}) {
            /varset PetAttack 0
            /pet back off
            /if (${PetHoldOn}) /pet ${PetHold} on
        }
        /if (${DebuffAllOn} && ${DebuffCount}) {
            /varset j 0
            /for i 1 to ${XSlotTotal}
                /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.NotEqual[Corpse]} && ${Me.XTarget[${i}].Distance}<=${MeleeDistance}) /varcalc j ${j}+1
            /next i
            /if (${j}==0) {
                /for i 1 to ${DebuffCount}
                    /varset DBOTimer${i} 0
                    /varset DBOList${i}
                /next i
            }
        }
        /if (${Defined[DPSTimeStart${MyTargetID}]}) /deletevar DPSTimeStart${MyTargetID}
        /varset DPSLastTime 0
        /varset DPSTotal 0
        /varset DPSTarget 0
        /varset DPSPetTotal 0
        /varset DPSCounter 0
        /varset BurnActive 0
        /if (!${TwistOn} && ${MeleeTwistOn}) /varset DPSTwisting 0
        /if (${LootOn}) {
            /delay 10
            /call LootStuff
            /if (${IAmABard}) {
                /squelch /twist off
                /stopsong
                /delay 20 !${Twist}
            }
        }
        /if (${IAmABard}) /call DoBardStuff
        /call AlertClearList 2 CombatReset
        /varset TankTimer 30s
        /squelch /target clear
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatReset: Leave \agLine#: ${Macro.CurLine}
        /varset PetFollowTimer 60s
        /doevents flush
        /if (${Stick.Active} && ${Stick.StickTarget}!=${If[${Spawn[=${WhoToChase}].Type.Equal[Pet]},${Spawn[=${WhoToChase}].Master.ID},${Spawn[=${WhoToChase}].ID}]}) /stick off
        /if (${UseMQ2Melee}) /squelch /melee melee=1
        /if (${Select[${Me.Class.ShortName},ROG]}) /call Roguestuff
    /return
| -------------------------------------------------------------------------------------
| SUB: Check for Adds
| -------------------------------------------------------------------------------------
    Sub CheckForAdds(CalledFrom)
        /if (${Debug}) /echo \atDEBUG  CheckForAdds: Enter from ${CalledFrom} \agLine#: ${Macro.CurLine}
        /call MobRadar ${MeleeDistance} CheckForAdds
        /if (${Debug}) /echo \atDEBUG MobCount:${MobCount} \agLine#: ${Macro.CurLine}
        | If no mobs, in a DMZone or pulling Leave
        /if (${MobCount}<=1)  /return  
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Pulling}) /return
        /if (!${DPSOn} && !${MeleeOn}) /return
        /if ((${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius})) /return
        /if (${IAmDead}) /return        
        /if (${ChainPull}==2 || ${DPSPaused}) /return
        | If I have a valid living target in camp radius Leave
        /if (!${Target.ID} && ${MyTargetID} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance}<${CampRadius}) {
            /target id ${MyTargetID}
            /return
        }
        | Spam Adds in camp
        /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<=${CampRadius} && !${MyTargetID} && !${AddSpam}) {
            /popup Add(s) in camp detected          
            /if ((${MainAssist.Equal[${Me}]} || ${Select[${Role},tank,pullertank,pettank,pullerpettank]})) /call BroadCast ${IRCOn} ${EQBCOn} r "Add(s) in camp detected"      
            /if (${Select[${Role},pullertank,pullerpettank]}) /varset Pulled 0
            /varset AddSpam 5s
        }
        | Prevent puller from stalling if adds in camp and still returning from pulling mob.
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Pulled} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=15) /return
        /if (!${Target.ID} && ${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]}) /squelch /target ID ${Spawn[${AggroTargetID}].ID}
        /if (${Target.Type.NotEqual[npc]}) {
            /squelch /target clear
            /return
        }
        /if (${Debug}) /echo \atDEBUG CheckForAdds: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: AggroCheck
| -------------------------------------------------------------------------------------
    Sub AggroCheck
        /if (!${Me.HaveExpansion[Rain of Fear]}) /return
        /if (${Target.Type.Equal[corpse]}) /return
        /if (${Defined[ParseDPS]}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AggroCheck Enter  \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare AggroSpell string local
        /declare AggroGLT string local
        /declare AggroPCT int local    
        /declare AggroTarget string local
        /declare AggroTID int local
        /for i 1 to ${Aggro.Size}
            /varset AggroSpell ${Aggro[${i}].Arg[1,|]}
            /varset AggroPCT ${Aggro[${i}].Arg[2,|]}
            /varset AggroGLT ${Aggro[${i}].Arg[3,|]}
            /varset AggroTarget ${Aggro[${i}].Arg[4,|]}
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT AggroCheck ${Me.PctAggro} ${AggroGLT} ${AggroPCT} ${AggroSpell} \agLine#: ${Macro.CurLine}
            /if (${ConditionsOn} && ${DPSCOn} && ${If[${AggroCond[${i}]},0,1]}) /continue
            /if ((${AggroGLT.Equal[<]} && ${Me.PctAggro}<${AggroPCT}) || (${AggroGLT.Equal[>]} && ${Me.PctAggro}>${AggroPCT}) && (${Cast.Ready[${AggroSpell}]} || ${Me.AbilityReady[${AggroSpell}]} || (${Me.CombatAbilityReady[${AggroSpell}]} && !${Me.ActiveDisc.ID}))) {
                /echo Trying to control Aggro: ${Me.PctAggro} ${AggroGLT} ${AggroPCT} ${AggroSpell} 
                /if (${Select[${AggroTarget},null,Mob]} || ${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}>${MeleeDistance}) /varset AggroTID ${MyTargetID}
                /if (${AggroTarget.Equal[Me]}) /varset AggroTID ${Me.ID}
                /if (${AggroTarget.Equal[MA]}) /varset AggroTID ${Spawn[=${MainAssist}].ID}
                /if (${AggroTarget.Equal[Pet]}) /varset AggroTID ${Me.Pet.ID}
                /if (${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}<${MeleeDistance}) /continue
                /call CastWhat "${AggroSpell}" ${AggroTID} Aggro
                /delay 10
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting >> ${AggroSpell} << to control AGGRO on ${Spawn[${AggroTID}].CleanName}.
                    /if (${AggroGLT.Equal[>]}) {
                        /if (!${AggroOffTimer}) {
                           /if (${Me.Feigning} || ${Me.Invis}) /varset AggroOffTimer 20
                        }
                    }
                    /return
                }  
            }
        /next i
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AggroCheck Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CastReady
|*****************************************************************************************************************************************|
    Sub CastReady(string castWhat,string sentFrom)
        /if (!${Bool[${castWhat}]}) /return 0
        /if (${sentFrom.Equal[rezwithready]}) {
            /if (${Select[TRUE,${Me.AltAbilityReady[${castWhat}]},${Me.ItemReady[=${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]}]}==0) {
                /if (${Me.Book[${castWhat}]}) {
                    /if (!${Me.Gem[${castWhat}]}) {
                        /return 5
                    }
                }
            }
        } else /if (${sentFrom.Equal[singleheal]}) {
            /if (${Me.Gem[${castWhat}]}) {
                /while (${Me.SpellInCooldown}) {
                    /delay 2
                }
            }
        }
    /return ${Select[TRUE,${Me.AltAbilityReady[${castWhat}]},${Me.ItemReady[=${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]},${Me.SpellReady[${castWhat}]}]}
| -------------------------------------------------------------------------------------
| SUB: CastWhat
|*****************************************************************************************************************************************|
    Sub CastWhat(string castWhat,int WhatID,string sentFrom)
        /if (${Debug}) /echo CastWhat Enter Line#: ${castWhat} ${WhatID} ${sentFrom} ${Macro.CurLine}
        /declare ReadyToCast int local 0
        /varset CastResult CAST_NO_RESULT
        /if (${Me.AltAbility[${castWhat}]} || ${Me.CombatAbility[${castWhat}]} || ${FindItem[=${castWhat}].ID} || ${Me.Ability[${castWhat}]} || ${Me.Book[${castWhat}]}) { 
            /varset ReadyToCast ${Select[TRUE,${Me.AltAbilityReady[${castWhat}]},${Me.ItemReady[=${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]},${Me.SpellReady[${castWhat}]}]} 
            /if (${ReadyToCast}) {
                /if (${ReadyToCast}==1 && ${Me.AltAbilityReady[${castWhat}]}) /call CastAA "${castWhat}" ${WhatID}
                /if (${ReadyToCast}==2 && ${Me.ItemReady[=${castWhat}]}) /call CastItem "${castWhat}" ${WhatID}
                /if (${ReadyToCast}==3 && ${Me.CombatAbilityReady[${castWhat}]}) /call CastDisc "${castWhat}" ${WhatID}
                /if (${ReadyToCast}==4 && ${Me.AbilityReady[${castWhat}]}) /call CastSkill "${castWhat}" ${WhatID}
                /if (${ReadyToCast}==5 && ${Me.SpellReady[${castWhat}]} && ${Me.Book[${castWhat}]} && ${Spell[${castWhat}].Mana}<${Me.CurrentMana}) /call CastSpell "${castWhat}" ${WhatID} ${sentFrom}
            } else {
                /if (${Me.Book[${castWhat}]} && !${Me.Gem[${castWhat}]} && ${ReadyToCast}==0) {
                    /call CastMem "${castWhat}" ${sentFrom}
					/if (${Macro.Return.NotEqual[notready]} && ${Me.Gem[${castWhat}]}!=0) { 
                        /varset ReadyToCast 6
                        /call CastSpell "${castWhat}" ${WhatID} ${sentFrom}
                    }
                }
            }    
        }    
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) /doevents
        |Remem spell originally in Miscgem slot except if combat or just rezd
        /if (${MiscGemRemem} && ${ReadyToCast}==6) /call CastReMem
        /if (${Debug}) /echo CastWhat Leave Line#: ${Macro.CurLine}
    /return ${CastResult}
|--------------------------------------------------------------------------------------------------------------|
    Sub CastAA(string WhatAA,int WhatID)
        /if (${Debug}) /echo CastAA Enter Line#: ${Macro.CurLine}
        /if (${Select[${WhatAA},Banestrike,15073]} && !${Banestrike.Find[|${Target.Race}|]} && ${Spawn[${MyTargetID}].Distance3D}>70 && ${CombatStart}) /return
        /if (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID}) /call CastTarget ${WhatID}
        /alt act ${Me.AltAbility[${WhatAA}].ID}
        /call CastWait "${WhatAA}"
        /delay 5
        /if (${Me.AltAbilityReady[${WhatAA}]}) {
            /varset CastResult CAST_RECOVER
        } else {
            /varset CastResult CAST_SUCCESS
        }
        /if (${Debug}) /echo CastAA Leave Line#: ${Macro.CurLine}
    /return ${CastResult}
|--------------------------------------------------------------------------------------------------------------|
    Sub CastItem(string WhatItem,int WhatID)
        /if (${Debug}) /echo CastItem Enter Line#: ${Macro.CurLine}
        | Prevent casting of Prestige items on silver and F2P accounts
        /if (${Me.Subscription.NotEqual[gold]} && ${FindItem[=${WhatItem}].Prestige}) /return 0
        | Fix for progression server - exchange item to inventory slot 30
        /if (${Select[${EverQuest.Server},fippy,vulak,ragefire,lockjaw]}) {
            /if (${FindItem[=${WhatItem}].ItemSlot}>22) {
                /exchange "${WhatItem}" 30
                /autoinventory
            }
        }
        /if (${IAmABard}) {
            /if (${Debug})  /echo I am a bard CastItem ${WhatItem}
            /call CastBard "${WhatItem}" ${WhatID} CastItem 
            /if (${Debug}) /echo ${Macro.Return} 
            /varset CastResult  ${Macro.Return}  
        } else {
            /casting "${WhatItem}|item" -targetid|${WhatID}
            /while (${Me.Casting.ID}) {
                /delay 5
            }
            /delay 300 ${Cast.Status.Equal[I]}
            /varset CastResult ${Cast.Result}
        }    
        /if (${Debug}) /echo CastItem Leave Line#: ${Macro.CurLine}
    /return ${CastResult}
|--------------------------------------------------------------------------------------------------------------|
    Sub CastDisc(string WhatDisc,int WhatID)
        /declare WaitTimerCD timer local 
        /if (${Debug}) /echo CastDisc Enter Line#: ${Macro.CurLine}
        /if (!${Spell[${WhatDisc}].Duration.TotalSeconds} || (${Spell[${WhatDisc}].Duration.TotalSeconds} && !${Me.ActiveDisc.ID})) {
            | /if (${Spell[${WhatDisc}].EnduranceCost}>${Me.Endurance}) /return CAST_OUTOFENDURANCE
            /if (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID}) /call CastTarget ${WhatID}
            /varset WaitTimerCD 30
            /while (${Me.CombatAbilityReady[${WhatDisc}]} && ${WaitTimerCD}) {
                /disc ${Me.CombatAbility[${Me.CombatAbility[${WhatDisc}]}].ID}
                /call CastWait "${WhatDisc}"
                /delay 5
            }
            /varset CastResult CAST_SUCCESS
        }
        /if (${Debug}) /echo CastDisc Leave Line#: ${Macro.CurLine}
    /return ${CastResult}  
|--------------------------------------------------------------------------------------------------------------|
    Sub CastSkill(string WhatSkill,int WhatID)
        /if (${Debug}) /echo CastSkill Enter Line#: ${Macro.CurLine}
        /if (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID}) /call CastTarget ${WhatID}
        /doability "${WhatSkill}"
        /delay 20 !${Me.AbilityReady[${WhatSkill}]}
        /if (!${Me.AbilityReady[${WhatSkill}]}) /varset CastResult CAST_SUCCESS
        /if (${Debug}) /echo CastSkill Leave Line#: ${Macro.CurLine}
    /return ${CastResult}
|--------------------------------------------------------------------------------------------------------------|
    Sub CastSpell(string WhatSpell,int WhatID,string sentFrom)
        /if (${Debug}) /echo CastSpell Enter Line#: ${WhatSpell} ${WhatID} ${sentFrom} ${Me.GemTimer[${WhatSpell}]} ${Macro.CurLine}
        /declare MaxTryNum int local 2
        /if (${sentFrom.Equal[Pull]}) /varset MaxTryNum 1
        /if (${IAmABard}) {
            /call CastBard "${WhatSpell}" ${WhatID} CastSpell
            /return  ${CastResult}  
        }
        | /if (!${IAmABard} && ${Spell[${WhatSpell}].Mana}<=${Me.CurrentMana}) /return 
        /if (!${Target.CanSplashLand} && ${Spell[${WhatSpell}].TargetType.Equal[Free Target]}) {
           /echo Splash Spell will not cast at targets location. Skipping ${WhatSpell}
           /return
        }
        /if (${Target.ID}!=${WhatID} && ${Spell[${WhatSpell}].TargetType.NotEqual[Self]} && ${Spawn[id ${WhatID}].ID}) /call CastTarget ${WhatID}
        /if (${Me.Gem[${WhatSpell}]}) {
            /if (${Me.GemTimer[${WhatSpell}]}==0) {
                /casting "${WhatSpell}" -maxtries|${MaxTryNum}
                /while (${Cast.Status.Equal[C]} && ${CastResult.NotEqual[CAST_CANCELLED]}) {
                    /if (${CastingInterruptOn}) {
                        /if (${sentFrom.Equal[SingleHeal]}) {
                           /call CastInteruptHeals "${WhatSpell}"
                        } else /if (${Select[${sentFrom},dps,gom,burn]}>0) {
                           /call CastInteruptDPS "${WhatSpell}"
                        } else /if (${Select[${sentFrom},buffs,buffs-nomem]}>0) {
                           /call CastInteruptBuffs "${WhatSpell}"
                        }
                    }
                    /delay 5
                }
                /call CastWait "${WhatSpell}"
                /if (${sentFrom.Equal[Pull]} && ${PullAggroTargetID}) /varset CastResult CAST_SUCCESS
                | READ THIS. For some reason Cast.Result is still equal to CAST_SUCCESS after /interrupt, maybe macro to fast for plugin to update.
                | So checking for CastResult NotEqual CAST_CANCELLED fixes the issue, and fixes the casting on corpse messages even though the spell was canceled. 
                /if (${CastResult.NotEqual[CAST_CANCELLED]}) /varset CastResult ${Cast.Result}
            }
        } else {
            /echo Skip Casting ${WhatSpell}. Spell Not Memed.
            /varset CastResult CAST_NO_RESULT
        }
        /if (${Debug}) /echo CastSpell Leave ${Me.GemTimer[${WhatSpell}]} ${CastResult} ${Cast.Result} Line#: ${Macro.CurLine}
    /return  ${CastResult}  
|--------------------------------------------------------------------------------------------------------------|
    Sub CastWait(string WaitSpell)
        /if (${Spell[${WaitSpell}].CastTime}) {
            /while (${Me.Casting.ID} || ${Cast.Status.Equal[c]}) {
                /delay 5
            }
        }
    /return
|--------------------------------------------------------------------------------------------------------------|    
    Sub CastBard(string BardSpell,int WhatID,string sentFrom)
        | Bard song with long refresh is not ready so return and do not interupt twisting.
        /if (${Me.GemTimer[${BardSpell}]}>=1 && ${Me.Book[${BardSpell}]}) /return
        /if (${Debug}) /echo CastBard Enter Line#: ${BardSpell} ${WhatID} ${sentFrom}
        /varset WasTwisting ${Twist}
        /while (${Me.BardSongPlaying}) {
            /if (${Twist}) /squelch /twist off
            /stopsong
            /delay 10
        }
        /if (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID}) /call CastTarget ${WhatID}
        /if (${FindItem[=${BardSpell}].ID}) {
            /if (${Debug}) /echo I am a bard CastBard ${BardSpell}
            /casting "${BardSpell}|item" -targetid|${WhatID}
            /while (${Me.Casting.ID} || ${Cast.Status.Equal[c]}) {
                /delay 5
            }
            /varset CastResult ${Cast.Result}
        } 
        /if (${Me.GemTimer[${BardSpell}]}==0 && ${Me.Book[${BardSpell}]}) {
            /delay 2 
            /squelch /twist once ${Me.Gem[${BardSpell}]}
            /delay 30
            /varset CastResult CAST_SUCCESS
        }
        /if (${WasTwisting} && !${Twist}) {
            /squelch /twist
        }
    /return ${CastResult}     
|--------------------------------------------------------------------------------------------------------------|
    Sub CastTarget(int WhatID)
        /if (${Debug}) /echo CastTarget Enter Line#: ${Macro.CurLine}
        /squelch /target clear
        /delay 10 !${Target.ID}
        /target id ${WhatID}
        /delay 10 ${Target.ID}==${WhatID}
        /if (${Debug}) /echo CastTarget Leave Line#: ${Macro.CurLine}
    /return  
|--------------------------------------------------------------------------------------------------------------|
    Sub CastMem(string WhatMemSpell,string sentFrom)
        /declare WaitTimerCM timer local 0
        /if (${Debug}) /echo CastMem Enter Line#: ${Macro.CurLine}
        | Prevent tanks and heals trying to mem spells during combat.
        /if ((${Attacking} && ${MainAssist.Equal[${Me}]}) || (${HealsOn} && ${AggroTargetID} && ${sentFrom.NotEqual[Heal]} && !${Me.Mount.ID})) {
            /echo Cannot mem a spell durring combat or while you have aggro.
		    /return notready
        }
        /if (${Cursor.ID}) /call CheckCursor CastMem
		/if (${IAmABard}) {
		    /varset WasTwisting ${Twist}
            /while (${Me.BardSongPlaying}) {
        	    /if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
		}
        /if (${MiscGemRemem} && ${MiscGemLW} && ${Spell[${WhatMemSpell}].RecastTime.TotalSeconds}>30 && ${ReMemWaitLong.Equal[null]}) {
           /varset ReMemWaitLong ${WhatMemSpell}
           /varset DontMoveMe 1
           /call CastMemSpell "${WhatMemSpell}" ${MiscGemLW} 0 CastMem
           /varset DontMoveMe 0
           /return notready
        }
        /varset ReMemWaitShort ${WhatMemSpell}
        /varset DontMoveMe 1
        /call CastMemSpell "${WhatMemSpell}" ${MiscGem} 0 CastMem
        /varset DontMoveMe 0
        /if (${Me.Gem[${WhatMemSpell}]}) {
            /varset WaitTimerCM 350
            /while (!${Me.SpellReady[${WhatMemSpell}]} && ${WaitTimerCM}) {
                /delay 5
            }
            /delay 10
        }
		/if (${IAmABard}) {
            /if (${WasTwisting} && !${Twist}) /squelch /twist
		}
        /if (!${Me.Gem[${WhatMemSpell}]}) /return notready
        /if (${Debug}) /echo CastMem Leave Line#: ${Macro.CurLine}
   /return 0
|--------------------------------------------------------------------------------------------------------------|
    Sub CastReMem(string WhatMemSpell,string sentFrom)
        /if (${Debug}) /echo CastTarget Enter Line#: ${Macro.CurLine}
        |We need to check if the spell just cast was swaped out and other spell needs to bo rememed.
        |Need a way to carry a flag so remem will be done out of combat after the spell has been cast.
        /if (${CastResult.Equal[CAST_SUCCESS]}) {
            |Is it the MiscGem?
            /if (${WhatMemSpell.Equal[${ReMemWaitShort}]}) {
                /varset ReMemCast 1
            |Is it the MiscGemLW
            } else /if (${WhatMemSpell.Equal[${ReMemWaitLong}]}) {
                /varset ReMemCastLW 1
            }
        }
        /if (${MiscGemRemem}==1 || ${MiscGemRemem}==2) {
            /if (!${Me.Gem[${ReMemMiscSpell}]} && ${ReMemCast} && !${CombatStart} && !${Me.Buff[Resurrection Sickness].ID} && !${sentFrom.Find[-nomem]}) {
                /if (${Cursor.ID}) /call CheckCursor CastReMem
                |/memorize "${ReMemMiscSpell}" gem${MiscGem}
                /varset DontMoveMe 1
                /call CastMemSpell "${ReMemMiscSpell}" ${MiscGem} 0 CastReMem
                /varset DontMoveMe 0
                /varset ReMemCast 0
                /varset ReMemWaitShort null
            }
        }
        |Remem spell originally in Long Wait Gem slot
        /if ((${MiscGemRemem}==1 || ${MiscGemRemem}==3) && ${MiscGemLW} && ${ReMemWaitLong.NotEqual[null]}) {
            /if (${ReMemCastLW} && !${Me.Buff[Resurrection Sickness].ID}) {
                /if (${Cursor.ID}) /call CheckCursor CastReMem2
                /varset DontMoveMe 1
                /call CastMemSpell "${ReMemMiscSpellLW}" ${MiscGemLW} ${Int[${Me.Gem[${ReMemMiscSpellLW}]}]} CastReMem
                /varset DontMoveMe 0
                /varset ReMemCastLW 0
                /varset ReMemWaitLong null
            }
        }
        /if (${Debug}) /echo CastTarget Leave Line#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------------------------------------|
    Sub CastMemSpell(SpellToMem, int i, int ForceIt, string sentFrom)
        /if (${Debug}) /echo \atDEBUGBUFFS CastMemSpell Enter \agLine#: ${Macro.CurLine}
        /if (${Int[${SpellToMem.Length}]}==0 || ${SpellToMem.Equal[null]} || ${i}==0) /return

        /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && !${ForceIt}) /return
        | Unmem a spell if already memmed in a diffent gem
        /if (${ForceIt}) {
            /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && ${i}!=${ForceIt}) {
                /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${ForceIt}-1]}]} rightmouseup
                /delay 20 ${Int[${Me.Gem[${i}].ID}]}==0
            }
        }
        /if (${Me.Book[${SpellToMem}]}) {
            /if (${Int[${Me.Gem[${i}].ID}]}>0) {
                /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${i}-1]}]} rightmouseup
                /delay 20 ${Int[${Me.Gem[${i}].ID}]}==0
            }
            /if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${SpellToMem}]}) {
                /while (${Me.Moving}) {
                    /delay 5
                }
                /echo Meming ${SpellToMem} in slot ${i}
                /if (${Stick.Active}) {
                    /stick pause 
                    /MemSpell ${i} "${SpellToMem}"
                    /delay 90 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]} 
                    /stick unpause
                } else {
                    /MemSpell ${i} "${SpellToMem}"
                    /delay 90 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]} 
                }
            }
        } else {
            /echo Could Not find the spell ${SpellToMem} in your spell book.
        }
        /if (${Window[SpellBookWnd].Open}) /windowstate spellbookwnd close
        /if (${Debug}) /echo \atDEBUGBUFFS CastMemSpell Leave \agLine#: ${Macro.CurLine}
    /return   
|--------------------------------------------------------------------------------------------------------------|    
    Sub CastInteruptHeals(string CIHSpell)
       /if (!${Int[${Me.Casting.ID}]}) /return
       /if (${Target.Type.Equal[npc]}) {
            |/stopcast
            /Interrupt
            /varset CastResult CAST_CANCELLED
            /echo ${CIHSpell} interrupted. Target is an NPC
            /if (${Debug}) /echo CheckHP1: ${Target.Type}
        }
       /if ( ${Target.PctHPs}>${SHealPct} && ${SHealPct}>65) {
            |/stopcast
            /Interrupt
            /varset CastResult CAST_CANCELLED
            /echo ${CIHSpell} interrupted. Target is above required ${SHealPct}% health. ${Target}
            /if (${Debug}) /echo CheckHP2: ${Target.PctHPs} ${SHealPct}
       }
    /return    
|--------------------------------------------------------------------------------------------------------------|
    Sub CastInteruptDPS(string CIDSpell)
        /if (!${Int[${Me.Casting.ID}]}) /return
        /if (${Target.Type.Equal[pc]}) /return
        /if (${Target.PctHPs}<1 || ${Target.Type.Equal[corpse]} || !${Int[${Target.ID}]}) {
            /Interrupt
            /varset CastResult CAST_CANCELLED
            /echo ${CIDSpell} interrupted due to Killing corpses is not required.
            /if (${Debug}) /echo CheckDPS1: ${Target.PctHPs} ${Target.Type} ${Int[${Target.ID}]}
        }
        /if (${HealsOn}) {
            /if (${Spawn[${MainAssist}].PctHPs}<70 && ${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]}) {
                /Interrupt
                /varset CastResult CAST_CANCELLED
                /echo ${CIDSpell} interrupted due to The Main Assist Needs a Heal.
                /if (${Debug}) /echo CheckDPS2: ${HealsOn}  ${Spawn[${MainAssist}].PctHPs} ${Spawn[${MainAssist} ${MainAssistType}].ID}  ${Spawn[${MainAssist} ${MainAssistType}].Type}
            } else /if (${Select[${Role},pettank,petpullertank,hunterpettank]}>0 && ${Me.Pet.ID} && ${Me.Pet.PctHPs}<80) {
                /Interrupt
                /varset CastResult CAST_CANCELLED
                /echo ${CIDSpell} interrupted due to my Pet Tank needs a heal.
                /if (${Debug}) /echo CheckDPS3: ${HealsOn}  ${Me.Pet.ID} ${Me.Pet.PctHPs} 
            }
        }
    /return
|--------------------------------------------------------------------------------------------------------------| 
    Sub CastInteruptBuffs(string CIBSpell)
        /if (!${Int[${Me.Casting.ID}]}) /return
        /if (${Me.Casting.Range}==0 && ${Me.Casting.AERange}==0) /return
        /if ((${Int[${Target.ID}]} && ${Int[${Target.PctHPs}]}<1) || (${Target.Type.Equal[corpse]}) || (!${Int[${Target.ID}]} && ${Select[${Me.Casting.TargetType},self,pet,pet1,pet2]}==0)) {
            |/stopcast
            /Interrupt
            /varset CastResult CAST_CANCELLED
            /echo ${CIBSpell} interrupted because target dead or not valid.
            /if (${Debug}) /echo CheckBUFFS2: ${Int[${Target.PctHPs}]} ${Target.Type}  ${Int[${Target.ID}]} ${Me.Casting} ${Me.Casting.TargetType}
        }
        /if ((${Me.Casting.Range}>0 && ${Target.Distance}>${Me.Casting.Range}) || (${Me.Casting.AERange}>0 && ${Target.Distance}>${Me.Casting.AERange})) {
            |/stopcast
            /Interrupt
            /varset CastResult CAST_CANCELLED
            /echo ${CIBSpell} interrupted because target out of range.
            /if (${Debug}) /echo CheckBUFFS3: ${Int[${Me.Casting.ID}]}  ${Target.Distance} ${Me.Casting.Range} ${Me.Casting.AERange} ${Me.Casting}
        }
    /return       
|*****************************************************************************************************************************************|    
| -------------------------------------------------------------------------------------
| SUB: Do We Move
| -------------------------------------------------------------------------------------
    Sub DoWeMove(int ForceToCamp, SentFrom)
        /if (!${ReturnToCamp} && !${ForceToCamp}) /return
        /declare StuckCount int local 0 
        /declare X1 int local
        /declare Y1 int local
        /declare scatterDistance int local
        /declare CampYRandom int local
        /declare CampXRandom int local
        /doevents
        /call EndMacroIf
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 30s
        /if (${Target.ID} && ${Target.Type.Equal[npc]}) {
            /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        }
        /declare circleDirection string local
        /if (${Debug}) /echo \atDEBUG DoWeMove: Enter \agLine#: ${Macro.CurLine}
        | - Shuts off ReturnToCamp if a toon moves a big distance defined by CampRadiusExceed ie CoH !${Pulled} || ${Pulling}
            /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) My distance from camp is: (${Math.Distance[${CampYLoc},${CampXLoc}]}). \agLine#: ${Macro.CurLine}
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadiusExceed} && !${Role.Find[hunter]} && ${ReturnToCamp}==1) {
                /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) CampRadiusExceed turning off ReturnToCamp. \agLine#: ${Macro.CurLine}
                /varset ReturnToCamp 0
                /echo Leashing exceeded distance of ${CampRadiusExceed} turning off ReturnToCamp
                /return
            }
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 12) {
                /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) Distance to camp > 10 and no adds in camp. ${Math.Distance[${CampYLoc},${CampXLoc}]} ${CampRadius} ${Medding} \agLine#: ${Macro.CurLine}
                | Prevent puller roles from returning to camphere spot and just pull from where they are if in camp radius.
                /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=${CampRadius} && !${ForceToCamp} && !${Medding}) /return
                /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    |---------------------------------------------- MQ2Nav ---------------------------------------------------------------------|
                    /if (${PullMoveUse.Equal[nav]}) {
                        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius})  {
                            /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) Distance to camp > 15, MQ2Nav return to camp. \agLine#: ${Macro.CurLine}
                            :NotInCamp
                            /doevents
                            /if (${IAmDead} || ${Me.Hovering}) {
                                /nav stop
                                /return
                            }
                            /nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
                            /if (${Me.Mount.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]} <= 75 ) {
                                /echo MQ2Nav does not work well with mounts. Dismounting.
                                /dismount
                            }
                            :NavActive
                                /varset X1 ${Int[${Me.X}]}
                                /varset Y1 ${Int[${Me.Y}]}   
                                | PullerPetTank - send in pet to attack on my way back to camp if not too far from camp.
                                /if (${Select[${Role},pullerpettank]} && ${Pulled}) {
                                    /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                                        /call CombatPet
                                    } else {
                                        /pet back off
                                    }
                                }     
                                /delay 10
                                | Check for getting stuck on geometry
                                /if (!${Me.Stunned} && !${Me.Feigning}) {
                                    /if (${Int[${Me.X}]}==${X1} && ${Int[${Me.Y}]}==${Y1}) {
                                        /varcalc StuckCount (${StuckCount})+1
                                        /if (${StuckCount}>=3) {
                                            /if (${Navigation.Active}) /nav stop
                                            /call Stuck
                                            /varset StuckCount 0
                                        }
                                    }                                
                                }
                                /if (${DebugMove}) /echo \atDEBUG DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} >= ${CampRadius} Timer: ${DWMTimer} \agLine#: ${Macro.CurLine}
                                /if (${Navigation.Active} && ${DWMTimer}>=1) /goto :NavActive
                                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) /goto :NotInCamp
                        }
                    |---------------------------------------------- MQ2AdvPath ---------------------------------------------------------------------|
                    } else /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                        /if (${MoveTo.Moving}) /moveto off
                        /play ${PullPath} reverse nodoor smart
                        /if (${DebugMove}) /echo \atDEBUG DoWeMove: /play ${PullPath} reverse nodoor smart \agLine#: ${Macro.CurLine}
                        :RunningThePathBack
                            /doevents
                            /if (${IAmDead} || ${Me.Hovering}) {
                                /if (${PullMoveUse.Equal[advpath]}) {
                                    /if (${AdvPath.State}) /play off
                                }

                                /return
                            }
                            /delay 5
                            /varset DWMWPCurrent ${AdvPath.NextWaypoint}
                            /if (${DebugMove}) /echo \atDEBUG DoWeMove: ReturnToCamp WP#: ${DWMWPCurrent} ${MoveTo.Moving} \agLine#: ${Macro.CurLine}
                            /if (${AdvPath.State}==2 && ${Me.Moving} && ${DWMTimer}<10) /varset DWMTimer 10
                        /if (${DWMWPCurrent}>=2 && ${DWMTimer}>=1) /goto :RunningThePathBack
                        /if (${AdvPath.State}) /play off
                    } 
                } 
                |------------------------------------------------ MoveTo -----------------------------------------------------------------------|
                /if (${DebugMove}) /echo \atDEBUG DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15, MQ2MoveUtils return to camp. \agLine#: ${Macro.CurLine}
                /doevents
                /if (!${Me.FeetWet}) /look 0
                /moveto mdist 5
                /if (${ScatterOn}) {
                    | Randomize camp x,y by +- so toons don't always retun to exact same spot and help to look less botted.
                    /varcalc scatterDistance ${Math.Rand[7]}+5
                    /if (${Math.Rand[2]}) {
                        /varcalc CampYRandom ${CampYLoc}-${scatterDistance}
                    } else {
                        /varcalc CampYRandom ${CampYLoc}+${scatterDistance}
                    }  
                    /if (${Math.Rand[2]}) {
                        /varcalc CampXRandom ${CampXLoc}-${scatterDistance}
                    } else {
                        /varcalc CampXRandom ${CampXLoc}+${scatterDistance}
                    }
                } else {
                   /varset CampYRandom ${CampYLoc}
                   /varset CampXRandom ${CampXLoc}
                }                
                /if (${DebugMove}) /echo \atDEBUG DoWeMove: Camp Location Info: ScatterOn: ${ScatterOn} YRandom: ${CampYRandom} XRandom: ${CampXRandom} \agLine#: ${Macro.CurLine}
                :StillMoving
                    /if (${IAmDead} || ${Me.Hovering}) {
                        /moveto off
                        /return
                    }
                    /if (!${Me.Mount.ID} && ${Me.Sitting} && ${Math.Distance[${CampYLoc},${CampXLoc}]} >= 16) /stand
                    /if (!${Me.Moving} || !${MoveTo.Moving}) {
                        /if (${Me.FeetWet}) {
                            /moveto set useback off
                            /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} uw mdist 15
                        } else {
                            /moveto set useback on
                            /moveto loc ${CampYRandom} ${CampXRandom}
                        }
                    }
                    /if (${Select[${Role},pullerpettank]} && ${Pulled}) {
                        /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                            /call CombatPet
                        } else {
                            /pet back off
                        }
                    }     
                    /delay 10
                    /if ((${MoveTo.Moving} || ${Me.Moving}) && ${DWMTimer}>=1) /goto :StillMoving
                /if (${DebugMove}) /echo \atDEBUG DoWeMove: MoveTo My distance from Camp is: ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} ${Me.FeetWet}. \agLine#: ${Macro.CurLine}
                /if (${MoveTo.Moving}) {
                    /if (${Me.FeetWet} && ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} >= 15) {
                        /goto :StillMoving
                    } else /if (${Math.Distance[${CampYRandom},${CampXRandom}]} >= 15) {
                        /goto :StillMoving
                    }
                }
                /if (${Me.FeetWet} && ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} >= 15) {
                    /varset DWMTimer 20
                    /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} uw mdist 15
                    /while (${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} > 15 && ${DWMTimer}) {
                        /delay 5
                    }
                    /if (${MoveTo.Moving}) /moveto off
                }
                /delay 20 !${Me.Moving}
                | Move down if Z distance more than 3 due to levitation
                /if (${Target.ID} && ${Select[${Target.Type},npc,corpse]})  /call ZAxisCheck ${ZDist} 3.1
                /if (!${AggroTargetID} && !${CombatStart} || ${Select[${Role},pullertank,puller,pullerpettank]}==0) /face heading ${LookForward}
                /if (!${Me.FeetWet}) /look 0
                /if (${Select[${Role},hunter,hunterpettank]}) /varset ReturnToCamp 0
            }
            /if (${Me.FeetWet} && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} >= 15) {
                /moveto loc ${CampYLoc} ${CampXLoc} ${CampZLoc} uw mdist 15
                /varset DWMTimer 30
                /while (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} > 15 && ${DWMTimer}) {
                    /delay 5
                }
                /if (${MoveTo.Moving}) /moveto off
            }
        /if (${Debug}) /echo \atDEBUG DoWeMove: Leave \agLine#: ${Macro.CurLine}
    /return
|*****************************************************************************************************************************************|    
| -------------------------------------------------------------------------------------
| SUB: Do We Chase
| -------------------------------------------------------------------------------------
    Sub DoWeChase(string SentFrom)
        /if (!${ChaseAssist}) /return
        /if (${Me.Hovering} || ${IAmDead}) /return
        /declare StuckCount int local 0 
        /declare X1 int local
        /declare Y1 int local
        | Stop sticking if mobs are on xtarget
        /if (${ChaseAssist}==1) {
            /if (${SpawnCount[npc xtarhater]} && !${Role.Find[pull]} && ${MainAssist.NotEqual[${Me}]}) {
                /if (${Stick.Active}) {
                    /if (${DebugMove}) /echo \atDEBUG Not gonna be an idiot and move during fight cause I dont have to.
                    /stick off
                    /moveto off
                    /if (${PullMoveUse.Equal[nav]}) {
                        /if (${Navigation.Active}) /nav stop
                    }
                }
                /return
            }
        }
        /doevents
        /call EndMacroIf
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 0
        /if (${Debug}) /echo \atDEBUG DoWeChase: Enter ${SentFrom} \agLine#: ${Macro.CurLine}
            /if (${DebugMove}) /echo \atDEBUG DoWeChase:(ChaseAssist) My distance from (${WhoToChase}) is: (${Spawn[=${WhoToChase}].Distance}). \agLine#: ${Macro.CurLine}
            /if (${JustZoned}==0 && (${Spawn[=${WhoToChase}].Distance} > ${CampRadiusExceed}) || (${Math.Calc[${Spawn[=${WhoToChase}].Z}-${Me.Z}]}>100 && ${Math.Calc[${Spawn[=${WhoToChase}].Z}-${Me.Z}]}<100)) {
                /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist exceed camp check \agLine#: ${Macro.CurLine}
                /varset ChaseAssist 0
                /echo ChaseAssist distance exceeded: Turning off ChaseAssist
                /call BroadCast ${IRCOn} ${EQBCOn} r "Hey! I got left behind please run me to " ${WhoToChase}
            }
            /if (${Spawn[=${WhoToChase}].Distance} > ${ChaseDistance} && ${Spawn[=${WhoToChase}].Distance} < ${CampRadiusExceed}) {
                /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist MA distance check \agLine#: ${Macro.CurLine}
                /if (${PullMoveUse.Equal[nav]}) {
                    /if (${Navigation.PathExists[id ${Spawn[=${WhoToChase}].ID}]}) {
                        /nav id ${Spawn[=${WhoToChase}].ID}
                    } else /if (${Spawn[=${WhoToChase}].LineOfSight}) {
                        /moveto id ${Spawn[=${WhoToChase}].ID} uw mdist ${ChaseDistance}
                    } else {
                        /echo Chase Failed due to ${WhoToChase} is not in Line of sight and Navigation couldn't find a path. Will try /Sticking.
                    }
                } else /if (${Spawn[=${WhoToChase}].LineOfSight}) {
                    /moveto id ${Spawn[=${WhoToChase}].ID} uw mdist ${ChaseDistance}
                }
                /delay 10 ${Me.Moving}
                /while (${Me.Moving}) {
                    /if (${Spawn[=${WhoToChase}].Distance3D}<=${ChaseDistance}) {
                        /if (${PullMoveUse.Equal[nav]}) {
                            /if (${Navigation.Active}) /nav stop
                        }
                    }
                    /delay 5
                }
            }
            /if (!${Stick.Active}) {            
                /if (${Spawn[=${WhoToChase}].Type.Equal[Pet]}) {
                    /target ${Spawn[=${WhoToChase}].Master}
                    /delay 10
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} uw id ${Target.ID} loose
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else /if ( ${Spawn[=${WhoToChase}].Type.Equal[mercenary]}) {
                    /target ${Spawn[=${WhoToChase}].Owner}
                    /delay 10
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} uw id ${Target.ID} loose
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else {
                   /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} uw id ${Spawn[=${WhoToChase}].ID} loose
                    } else {
                       /stick ${ChaseDistance} id ${Spawn[=${WhoToChase}].ID} loose
                    }
                }
                /delay 10
                /while (${Me.Moving}) {
                    /delay 10
                }
            }
            /while (${ChaseAssist}==3) {
                /delay 10
            }
        /if (${Debug}) /echo \atDEBUG DoWeChase: Leave \agLine#: ${Macro.CurLine}
    /return
|-------------------------------------------------------------------------------------
| SUB: Stuck
| -------------------------------------------------------------------------------------
    Sub Stuck
        /declare strafedir string local
        | - We're stuck, back off a second, move left or right (randomly) for 1 second
        /if (${IAmDead}) /return
        /keypress back hold
        /delay 10
        /keypress back
        /if (${Math.Rand[2]}) {
            /varset strafedir STRAFE_LEFT
        } else {
            /varset strafedir STRAFE_RIGHT
        }
        /keypress ${strafedir} hold
        /delay 10
        /keypress ${strafedir}
    /return
| -------------------------------------------------------------------------------------
| SUB: DoWeMed
| -------------------------------------------------------------------------------------
    Sub DoWeMed
        /if (!${MedOn}) /return
        /if (!${MedCombat} && ${AggroTargetID}) /return
        /if (${MedCombat} && !${Medding} && ${AggroTargetID}!=0 && ${AggroTargetID}==${MyTargetID}) /return
        /if (${Debug}) /echo \atDEBUG DoWeMed Enter \agLine#: ${Macro.CurLine}
        /declare Med2On int local 0
        /declare MedForceOn int local 0
        /declare MedStat1 string local ${MedStat}
        /declare j int local 0
        /declare MedFlag int local 0
        /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
        /if (!${Me.Moving}) {
            /if (${Select[${Me.Class.ShortName},BRD,BST,PAL,RNG,SHD]} && ${Me.Pct${MedStat2}}<${MedStart} && ${Me.Pct${MedStat}}>${MedStart})  {
                /varset MedStat1 ${MedStat}
                /varset MedStat ${MedStat2}
                /varset Med2On 1
            }
            /if (${Group.MainAssist.ID} && ${Group.MainAssist.Sitting}) {
                /if (!${MASitTime}) {
                    /varset MASitTime 300            
                } else /if (${MASitTime}<260) {
                   /varset MedForceOn 1
                }
            } else {
                /varset MASitTime 0
            }
            /if (${Me.Pct${MedStat}}<${MedStart}) {
                /varset MedFlag 1
            } else /if (${ChainPullHold}==2 && ${Me.Pct${MedStat}}<100) {
                /varset MedFlag 1
            } else /if (${MedForceOn} && ${Me.Pct${MedStat}}<90 && !${Role.Find[puller]} && !${MedCombat}) {
                /varset MedFlag 1
            } else /if (${MedForceOn} && ${IAmABard} && ${TwistMed}) {
                /varset MedFlag 1
            }
            |/if (${Me.Pct${MedStat}}<${MedStart} || (${ChainPullHold}==2 && ${Me.Pct${MedStat}}<100) || (${MedForceOn} && ${Me.Pct${MedStat}}<90 && !${Role.Find[puller]} && !${MedCombat})) {
            /if (${MedFlag}) {
                /squelch /tar clear
                /varset Medding 1
                /if (${Attacking}) /call CombatReset 0 dowemed
                /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) /call BroadCast ${IRCOn} ${EQBCOn} t "PULLER-> My ${MedStat} is ${MedStart}% time to med. ${MedStat} ${Me.Pct${MedStat}} ${ChainPullHold}"
                | bards twisting while others fighting negate fast med 
                /if (${IAmABard}) {
                    /if (${AggroTargetID} || ${MedCombat}) {
                        /while (${Me.BardSongPlaying}) {
                            /if (${Twist}) /squelch /twist off
                            /stopsong
                            /delay 10
                        }
                    } else /if (${TwistMed}) {
                        /while (${Me.BardSongPlaying}) {
                            /if (${Twist}) /squelch /twist off
                            /stopsong
                            /delay 10
                        }
                        /squelch /twist ${TwistMed}
                        /delay 10
                        /while (${Window[CastingWindow].Open}) {
                            /delay 5
                        }
                    } else {
                        /squelch /twist ${TwistWhat}
                        /delay 10
                    }
                }
                /if (${Medding}) /echo Medding until ${MedStat} 100%
                /if (${Me.Pct${MedStat}}<${MedStart}) /call BroadCast ${IRCOn} ${EQBCOn} t "My ${MedStat} is ${MedStart}% time to med."
            :wait_for_resume
                    /doevents
                    /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                        /call DoWeMove 0 dowemed
                    }
                    /if (!${Me.Mount.ID} && ${Me.Standing}) /sit                    
                    /if (${Debug}) /echo \atDEBUG ${MedStat} ${MedStat1} ${MedStat2} \agLine#: ${Macro.CurLine}
                    |/delay 10
                    |/call CheckCasting 50
                    /delay 10
                    /if (!${MedCombat}) {
                        /call WaitSubs
                        /if (${AggroTargetID}) {
                            /call CheckForCombat 0 DoWeMed
                            /if (${Med2On}) /varset MedStat ${MedStat1}
                            /varset Medding 0
                            /if (${IAmABard}) {
                                /while (${Me.BardSongPlaying}) {
                                    /if (${Twist}) /squelch /twist off
                                    /stopsong
                                    /delay 10
                                }
                            }
                            /return
                        }
                    }
                /if (${MedForceOn} && (!${Group.MainAssist.ID} || !${Group.MainAssist.Sitting})) /varset MedForceOn 0
                /if (${Me.Pct${MedStat}}<100 || ${MedForceOn}) /goto :wait_for_resume
                :done_medding
                /if (${Med2On}) /varset MedStat ${MedStat1}
                /varset Medding 0
                /if (${Me.Sitting}) /stand
                /if (${IAmABard} && ${TwistMed}) {
                    /while (${Me.BardSongPlaying}) {
                        /if (${Twist}) /squelch /twist off
                        /stopsong
                        /delay 10
                    }
                }
            }
            /if (${Select[${Role},pullerpettank,puller,hunter,hunterpettank]} && ${Me.PctHPs}<=50) {
                /echo Medding to 100% health
                /if (!${Me.Mount.ID} && !${Me.Sitting}) /sit
                :WaitFor100
                    /doevents
                    /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                        /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
                        /call DoWeMove 0 dowemed
                    }
                    |/delay 10
                    |/call CheckCasting 50
                    /delay 5
                    /if (!${MedCombat}) {
                        /call WaitSubs
                        /if (${AggroTargetID}) {
                            /call CheckForCombat 0 DoWeMed
                            /varset Medding 0
                            /return
                        }
                    }
                /if  (${Me.PctHPs}<100) /goto :WaitFor100
                /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
            }
            /if (${Select[${Role},pullerpettank,hunterpettank]} && !${Me.Invis} && (${Me.Pet.PctHPs}<=50 || ${PetForceHealOnMed})) {
                | Check pet is at full health before pulling.  
                /echo Waiting on pet to full health before next pull        
                /if (${Me.Pet.ID} && ${Me.Pet.PctHPs}<100) {                
                    :WaitingOnPetHealth
                    /for j ${SingleHeal.Size} downto 1
                        /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /continue
                        /if (${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) {
                            /if (${Debug}) /echo \amDEBUG DoPetMedStuff (${SingleHeal[${j}].Arg[3,|].Find[PET]} && ${Me.Pet.PctHPs} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) \agLine#: ${Macro.CurLine}
                            /call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Med
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /call BroadCast ${IRCOn} ${EQBCOn} o "${Heals[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} <<"
                                /varcalc PetHealTimer${j} (${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration.TotalSeconds}*${DurationMod})*10
                            }
                            /break
                        }
                        |:NextPetHeal
                    /next j
                    /if (${Me.Pet.ID} && ${Me.Pet.PctHPs}<100 && !${AggroTargetID}) {
                        /delay 6s
                        /goto :WaitingOnPetHealth
                    }
                }  
            }             
        }
        /if (${Debug}) /echo \atDEBUG DoWeMed Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckBuffs
| -------------------------------------------------------------------------------------
    Sub CheckBuffs
        /if (!${BuffsOn}) /return
        /if ( ${IAmDead}) /return
        /if (${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs CheckBuffs: Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare k int local
        /declare l int local
        /declare FullText string local 0
        /declare 1stPart string local 0
        /declare 2ndPart string local 0
        /declare 3rdPart string local 0
        /declare 4thPart string local 0
        /declare 5thPart string local 0
        /declare SpellRange int local
        /declare MATargetID int local
        /declare BookSpellTT string local 0
        /declare BuffSub string local
        /if (${PowerSource.NotEqual[NULL]} && ${Bool[${Me.Inventory[powersource].Name.Length}]} && !${Me.Inventory[powersource].Power} ) {
           /call CheckCursor CheckBuffs0
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /if (${Cursor.Name.Equal[${PowerSource}]}) /destroy
           /delay 5s ${Cursor.Equal[Null]}
        }
        |--------- Change to add Zone.Outdoor TLO and specific Zone.Type to stop mount cast spam.
        /if (${MountOn} && !${Me.Mount.ID} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]}) && ${Me.CombatState.NotEqual[COMBAT]}) /call CastMount
        | Call Buffs Array
        /for i 1 to ${Buffs.Size}
           /doevents
            /if (${Buffs[${i}].Find[|0]}) /goto :SkipBuff
            /if (${ChaseAssist} && !${CombatStart}) /call DoWeChase
            /if (${HealsOn}) /call CheckHealth
            /if (${AutoRezOn}) /call RezCheck
            | If Buffs=NULL skip to next buff
            /if (${Buffs[${i}].Equal[null]} || ${Buffs[${i}].Arg[3,|].Equal[0]} || ${Buffs[${i}].Arg[2,|].Equal[0]}) /goto :SkipBuff
            | Check for combat and skip redundant subs called in combat routines.
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Buff${i}: ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to the buff
            /if (${Buffs[${i}].Arg[2,|].Length}) {
                /varset FullText ${Buffs[${i}]}
                /varset 1stPart ${Buffs[${i}].Arg[1,|]}
                /varset 2ndPart ${Buffs[${i}].Arg[2,|]}
                /varset 3rdPart ${Buffs[${i}].Arg[3,|]}
                /varset 4thPart ${Buffs[${i}].Arg[4,|]}
                /varset 5thPart ${Buffs[${i}].Arg[5,|]}
                /if (${2ndPart.Equal[Dual]}) {
                    /if (${4thPart.Equal[MA]}) {
                        /varset 2ndPart DualMA
                    } else /if (${4thPart.Equal[melee]}) {
                        /varset 2ndPart DualMelee
                    } else /if (${4thPart.Equal[caster]}) {
                        /varset 2ndPart DualCaster
                    }
                }
            } else {
                /varset FullText ${Buffs[${i}]}
                /varset 1stPart ${Buffs[${i}]}
                /varset 2ndPart 
                /varset 3rdPart 
                /varset 4thPart 
            }
            /varset SpellRange ${Spell[${1stPart}].Range}
            /if (${Me.Subscription.NotEqual[gold]} && ${Select[${2ndPart},Dual,DualMA,DualMelee,DualCaster]}==0) {
                /if (${1stPart.Find[ Rk.]}) {
                    /varset BuffSub ${1stPart.Left[${Math.Calc[${1stPart.Find[ Rk.]}-1]}]} 
                } else {
                    /varset BuffSub ${1stPart}
                }
            } else {
                /varset BuffSub ${1stPart} 
            }
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs 1st:${1stPart} 2nd: ${2ndPart} #rd: ${3rdPart} 4th: ${4thPart} \agLine#: ${Macro.CurLine}
            /if (${Me.Book[${1stPart}]}) /varset  BookSpellTT ${Spell[${Me.Book[${Me.Book[${1stPart}]}].ID}].TargetType}
            /if ((${BookSpellTT.Find[0]} && ${Spell[${1stPart}].TargetType.Find[Group v]}) || ${BookSpellTT.Find[Group v]})  /varset SpellRange ${Spell[${1stPart}].AERange}
            /if (${Spell[${1stPart}].TargetType.Find[Group v]})  /varset SpellRange ${Spell[${1stPart}].AERange}
            /if (!${SpellRange}) /varset SpellRange 100
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs ${i} 1st: ${1stPart} 2nd: ${2ndPart} FullText: ${Buffs[${i}]} Type: ${Spell[${1stPart}].TargetType} ReadBuffsTimer: ${ReadBuffsTimer} IniNextTimer: ${IniNextTimer} \agLine#: ${Macro.CurLine}
            | Added Conditions Check
            /if (${ConditionsOn} && ${BuffsCOn} && ${If[${BuffsCond[${i}]},0,1]}) /goto :SkipCheckIni
            | Check for Mana/End AA Regen on others
            /if (${Group} && ${Select[${2ndPart},Endgroup,Managroup]}>0 && !${Buff${i}GM0}) {
                /if (${2ndPart.Equal[Endgroup]}) /call RegenOther "${1stPart}" Endurance ${3rdPart} 0    
                /if (${2ndPart.Equal[Managroup]}) /call RegenOther "${1stPart}" Mana ${3rdPart} 0
                /if (${Macro.Return.Equal[TRUE]}) {
                    /varcalc Buff${i}GM0 (${Spell[${1stPart}].RecastTime.TotalSeconds})*10
                    /goto :SkipBuff
                }
            } else /if (${2ndPart.Equal[mana]} && !${Buff${i}GM0}) {
                /call CastWhat "${Buffs[${i}]}" ${Me.ID} Buffs
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /varcalc Buff${i}GM0 (${Spell[${1stPart}].RecastTime.TotalSeconds})*10
                    /goto :SkipBuff
                }
            }
            | Combat check to skip all buffs but mana regen
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Skip if Combat:${CombatStart}  Aggro:${AggroTargetID} IDied: ${IAmDead} ReadBTimer: ${ReadBuffsTimer} 
            /if (${Me.CombatState.Equal[COMBAT]}) /goto :SkipBuff
            /if (${AggroTargetID}) /goto :SkipBuff
            /if (${CombatStart}) /goto :SkipBuff
            /if (${IAmDead}) /goto :SkipBuff
            /if (${ReadBuffsTimer}) /goto :SkipBuff
            | Remove buff from |Remove tag
            /if (${2ndPart.Equal[Remove]} && ${Me.Buff[${1stPart}].ID}) {
                /removebuff "${1stPart}" 
                /goto :SkipBuff
            }            
            | If buff cost more mana than I have skip it
            /if ((${Spell[${1stPart}].Mana} || ${Spell[${1stPart}].Mana})>${Me.CurrentMana}) /goto :SkipBuff
            | Check if aura is up
            /if (${2ndPart.Equal[Aura]}) {
                /call CheckAura "${1stPart}"
                /if (${Macro.Return.Equal[TRUE]}) /goto :SkipBuff
            }
            | Check for |Once tag and turn buff off is cast is successful
            /if (${2ndPart.Equal[Once]}) {
                /call BuffOnce "${1stPart}" 
                /if (${Macro.Return.Equal[TRUE]}) {
                    /varset Buffs[${i}] ${1stPart}|0
                    /echo Buffing Once with ${1stPart}.
                    /return
                }
            }
            | Check and Cast endurance discs/AAs - 2nd wind, respite, etc
            /if (${2ndPart.Equal[End]}) {
                /if (${Me.PctEndurance}<=${3rdPart} && ((${Me.CombatAbilityReady[${1stPart}]} && !${Me.ActiveDisc.ID}) || ${Me.AltAbilityReady[${1stPart}]})) /call CheckEndurance "${1stPart}" ${3rdPart} ${4thPart}
                /if (${Macro.Return.Equal[TRUE]}) /goto :SkipBuff
            }
            | Summon items ini example Buffs1=The Guardian's Pouch|Summon|Guardian Blade|200
            /if (${2ndPart.Equal[Summon]}) {
                /if (${FindItemCount[=${3rdPart}]}<${4thPart}) /call SummonStuff "${1stPart}" "${3rdPart}" ${4thPart}
                /if (${Macro.Return.Equal[TRUE]}) /goto :SkipBuff
            }
            /if (${Select[${2ndPart},Aura,End,Mount,Mana,Summon]}) /goto :SkipBuff
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to buff part of spell
            /if (${Select[${2ndPart},Dual,DualMA,DualMelee,DualCaster]}) /varset 1stPart ${3rdPart}
            /if (${Select[${2ndPart},Me,MA,!MA,Caster,Melee]}) /varset 1stPart ${BuffSub}
            | Cast buffs on MA && ${Spell[${Buffs[${i}]}].TargetType.Find[self]}
            /if ((${2ndPart.Equal[MA]} || ${2ndPart.Equal[DualMA]}) && ${Spawn[=${MainAssist}].Distance}<=${SpellRange} && ${Spawn[=${MainAssist}].ID} && ${Buff${i}GM7}==0) {
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS Cast buffs with MA tag ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
                | Check buffs in file to see if MA has buff or its blocked
                /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Blockedbuffs"].Find[${1stPart}]}) /goto :SkipBuff
                /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Buffs"].Find[${1stPart}]}) /goto :SkipBuff
                |/varset Buffs[${i}] ${1stPart}
                | If its a group spell cast on mercs - owner
                /if (${Spawn[=${MainAssist}].Type.Equal[mercenary]} && ${Spell[${Buffs[${i}]}].TargetType.Find[group v]}) { 
                    /varset MATargetID ${Spawn[=${MainAssist}].Owner.ID}
                } else /if (${Select[${Role},hunterpettank,pettank,pullerpettank]} ) {
                    /varset MATargetID ${Me.Pet.ID}
                } else {
                    /varset MATargetID ${Spawn[=${MainAssist}].ID}
                }
                /if (${Cursor.ID}) /call CheckCursor CheckBuffs1
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs: MA Buff /call CastWhat "${1stPart}" ${MATargetID} Buffs \agLine#: ${Macro.CurLine}
                /call CastWhat "${1stPart}" ${MATargetID} Buffs-nomem
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs: MA Buff MacroReturn: ${Macro.Return} \agLine#: ${Macro.CurLine}
                /delay 60 !${Me.Casting.ID}
                /if (${Macro.Return.Equal[CAST_SUCCESS]} || (!${Spawn[${MainAssistType} ${MainAssist} group].ID} && ${Macro.Return.Equal[CAST_TAKEHOLD]} )) {
                    /echo Buffing MA >> ${Spawn[=${MainAssist}].CleanName} << with ${1stPart}.
                    | For dual tag need to asssign spell duration of the 3rd part 
                    /if (${Select[${2ndPart},Dual,DualMA]}) /varset 1stPart ${3rdPart}
                    /varcalc Buff${i}GM7 (${Spell[${1stPart}].Duration.TotalSeconds}*${DurationMod})*10
                    /if (${DebugBuffs}) /echo DEBUGBUFFS CheckBuffs MA Buff Timer ${Buff${i}GM7} Line#: ${Macro.CurLine}
                    /varset WriteBuffsTimer 0
                    /call WriteBuffs
                    /goto :SkipCheckIni
                }
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components. Turning off ${1stPart}.
                    /varset Buffs[${i}] NULL
                    /varset FullText NULL
                    /goto :SkipBuff
                }
            } 
            | Skip to next spell if Tag MA
            /if (${Select[${2ndPart},MA,DualMA]}) /goto :SkipBuff
            | Check if buff is up and if it stacks with existing buffs
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs BuffSlot: !${Int[${Me.Buff[${Buffs[${i}]}].ID}]} SongSlot: ${Int[${Me.Song[${Buffs[${i}]}].ID}]} Stacks: ${Spell[${Buffs[${i}]}].Stacks[0]} 2nd Part: ${Select[${2ndPart},Aura,Mount,Mana,End,Summon]}<1 Tar Type: ${Spell[${Buffs[${i}]}].TargetType} \agLine#: ${Macro.CurLine}
            /if ((!${Int[${Me.Buff[${BuffSub}].ID}]} && !${Int[${Me.Song[${BuffSub}].ID}]}) && ${Spell[${1stPart}].Stacks[0]}) {
                | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to actual spell
                /if (${Select[${2ndPart},Dual,DualMelee,DualCaster]}) /varset 1stPart ${Buffs[${i}].Arg[1,|]}
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs -- 2nd asssigned: ${1stPart} TargetType: ${Spell[${1stPart}].TargetType} \agLine#: ${Macro.CurLine}
                | If Target.Type=Group then buff self with group buff
                /if ((${BookSpellTT.Find[0]} && ${Spell[${1stPart}].TargetType.Find[group v]}) || ${BookSpellTT.Find[group v]} ) {
                    /if (${Cursor.ID}) /call CheckCursor CheckBuffs2
                    /call CastWhat "${1stPart}" ${Me.ID} Buffs-nomem
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Buffing >> ${1stPart} <<
                        /doevents flush Worn_off
                        /varset WriteBuffsTimer 0
                        /call WriteBuffs
                        /goto :SkipCheckIni
                    }
                }
                | If Target.Type=Single then buff each party member with single buff
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Find 0: ${BookSpellTT.Find[0]} Spell TT: ${Spell[${1stPart}].TargetType.Find[single]} BookTT: ${BookSpellTT.Find[single]} Medding: ${Medding} MedCombat: ${MedCombat} \agLine#: ${Macro.CurLine}
                /if ((${BookSpellTT.Find[0]} && ${Spell[${1stPart}].TargetType.Find[single]}) || ${BookSpellTT.Find[single]}) {
                    /if (${Buff${i}GM0}) /varset Buff${i}GM0 0
                    /if (${Select[${2ndPart},Dual,DualMelee,DualCaster]})  /varset 1stPart ${Buffs[${i}].Arg[1,|]}
                    /if (${Group} && ${Me.CurrentMana}>(${Spell[${1stPart}].Mana}*${Group})) {
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Single Type Group Buff \agLine#: ${Macro.CurLine}
                        /for j 0 to ${Group}
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs !${Group.Member[${j}].ID} || ${Spawn[${Group.Member[${j}]}].Distance}>=${SpellRange} || ${2ndPart.Equal[Me]} && ${j}>=1 || ${2ndPart.Equal[MA]} && ${Group.Member[${j}].ID}!=${Spawn[${MainAssistType} ${MainAssist}].ID} || ${Buff${i}GM${j}} \agLine#: ${Macro.CurLine}
                            | Check if party member is alive in zone and within spell range and spell timer does not exist
                            /if (!${Group.Member[${j}].ID} || ${Spawn[${Group.Member[${j}]}].Distance}>=${SpellRange} || ${Buff${i}GM${j}}) /continue
                            /if (${2ndPart.Equal[Me]} && ${j}>=1) /continue
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs 3 ${2ndPart.Equal[caster]}  ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]} ${2ndPart.Equal[Melee]} ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]} \agLine#: ${Macro.CurLine}
                            /if ((${Select[${2ndPart},caster,DualCaster]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${Select[${2ndPart},Melee,DualMelee]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /continue
                            /if (${Me.CurrentMana}<${Spell[${1stPart}].Mana}) /continue
                            /if (${2ndPart.Equal[!MA]} && ${Group.Member[${j}].ID}==${Spawn[${MainAssistType} ${MainAssist}].ID}) /continue
                            /if (${Cursor.ID}) /call CheckCursor CheckBuffs3
                            /if (${AggroTargetID}) /return
                            /delay 7s ${Cast.Ready[${1stPart}]}
                            /call CastWhat "${1stPart}" ${Group.Member[${j}].ID} Buffs-nomem
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /echo Buffing ${1stPart} on ${Group.Member[${j}].CleanName}
                                | assisgn buff 3rd part of dual tag for actual duration
                                /if (${Select[${2ndPart},Dual,DualMelee,DualCaster]}) /varset 1stPart ${3rdPart}
                                /varcalc Buff${i}GM${j} (${Spell[${1stPart}].Duration.TotalSeconds}*${DurationMod})*10
                                /doevents flush Worn_off
                                /varset WriteBuffsTimer 0
                                /call WriteBuffs
                            }
                        /next j
                        /goto :SkipCheckIni
                    } else /if (${Select[${2ndPart},MA,Melee,Caster,DualMA,DualMelee,DualCaster]}==0) {
                        /if (${Cursor.ID}) /call CheckCursor CheckBuffs4
                        /call CastWhat "${1stPart}" ${Me.ID} Buffs-nomem
                    }
                }
                | If Target.Type=self then buff self
                /if (!${FindItem[=${1stPart}].ID} && ${BookSpellTT.Find[0]} && ${Spell[${1stPart}].TargetType.Find[self]} || ${BookSpellTT.Find[self]}) {
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Self Buff \agLine#: ${Macro.CurLine}
                        /call CastWhat "${1stPart}" ${Me.ID} Buffs-nomem 
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${1stPart}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /goto :SkipBuff
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Casting ${1stPart} on me.
                        /delay 10
                    }
                }
                | Check if buff needs pet as target ie Mage's Symbiosis line of mana buffs
                /if (${Me.Pet.ID} && (${BookSpellTT.Find[0]} && ${Spell[${1stPart}].TargetType.Find[pet]}  || ${Select[${Spell[${Spell[${1stPart}].ID}].Name.Arg[2,]},Symbiosis,Siphon,Simulacrum]})) {
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Self Buff that targets pet ie mage mana buff line \agLine#: ${Macro.CurLine}
                    /call CastWhat "${1stPart}" ${Me.Pet} Buffs
                }
            }
            | If buff is an item click it
            /if (${FindItem[=${1stPart}].Spell.Stacks[0]} && !${Int[${Me.Buff[${FindItem[=${1stPart}].Spell}].ID}]} && ${FindItem[=${1stPart}].Timer}==0 && ${Select[${2ndPart},Aura,Mount,Mana]}<1) {
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Items \agLine#: ${Macro.CurLine}
                | Call of the wild ear fix
                /if (${1stPart.Equal[Call of the Wild]}) {
                    /casting 133851 item 
                    /delay 15
                } else {
                    /call CastWhat "${1stPart}" ${Me.ID} Buffs
                }
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Clicking > ${1stPart} <
            }
            | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip ini check because none of these are cast on others
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${1stPart}]}>=1 Self:${Spell[${1stPart}].TargetType.Find[self]} \agLine#: ${Macro.CurLine}
         :SkipBuff
            /if (${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} || (${FindItemCount[=${1stPart}]}>=1 && ${Select[${Spell[${1stPart}].TargetType},self]}) || (${FindItemCount[${1stPart}]}>=1 && ${Select[${Spell[${3rdPart}].TargetType},self]}) || (${BookSpellTT.Find[0]} && ${Spell[${1stPart}].TargetType.Find[self]}) || ${BookSpellTT.Find[self]} || ${BookSpellTT.Find[pet]}) /goto :SkipCheckIni
            /if (${Redguides} && !${IniNextTimer} && !${CombatStart}) /call CheckiniBuffs "${1stPart}" ${i} ${SpellRange} "${1stPart}" "${2ndPart}" "${3rdPart}" "${4thPart}" "${BookSpellTT}"
         :SkipCheckIni
          | Reset spell vars
            |/if (${2ndPart.Length}) {
            |    /varset Buffs[${i}] ${FullText}
            |    /varset FullText 0
            |}
            /varset BookSpellTT 0
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs reset var ${i} ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
        /next i
        /if (${PowerSource.NotEqual[NULL]} && !${Bool[${Me.Inventory[powersource].Name.Length}]} && ${FindItemCount[=${PowerSource}]}) {
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /autoinventory
        }
        /if (!${ReadBuffsTimer} && !${AggroTargetID}) /varset ReadBuffsTimer ${CheckBuffsTimer}s
        /if (${Macro.RunTime}>120 && !${IniNextTimer}) /varset IniNextTimer 30s
        /if (${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscSpell}]} && ${MiscGemRemem}) {
            /varset DontMoveMe 1
            /call CastMemSpell "${ReMemMiscSpell}" ${MiscGem} 0 CheckBuffs
            /varset DontMoveMe 0
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: BuffOnce 
| -------------------------------------------------------------------------------------
    Sub BuffOnce(Oncepell)
        /if (${Me.Invis}) /return
        /declare OnceResult string local FALSE
        /call CastWhat "${Oncepell}" ${Me.ID} BuffOnce
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset OnceResult TRUE
        }
    /return ${OnceResult}
| -------------------------------------------------------------------------------------
| SUB: CheckAura | Check if aura is up
| -------------------------------------------------------------------------------------
    Sub CheckAura(AuraSpell)
        /if (${Me.Invis}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Spell: ${AuraSpell} Enter \agLine#: ${Macro.CurLine}
        /declare AuraName string local
        /declare TempAura string local
        /declare AuraResult string local FALSE
        | Strip the Rk II/III out of the spell to check against aura window
        /if (${AuraSpell.Find[ Rk. III]}) {
            /varset AuraName ${AuraSpell.Left[-8]}
        } else /if (${AuraSpell.Find[ Rk. II]}) {
            /varset AuraName ${AuraSpell.Left[-7]}
        } else /if (${AuraSpell.Find[ Rk.II]}) {
            /varset AuraName ${AuraSpell.Left[-6]}
        } else {
            /varset AuraName ${AuraSpell}
        }
        | Correct typo from SOE in monks 55 level aura
        /if (${AuraSpell.Find[Disciple's Aura]}) /varset AuraName Disciples Aura
        | Cleric exception for Reverent Aura 
        /if (${Me.Class.Name.Equal[cleric]} && ${AuraSpell.Find[Reverent]}) /varset AuraName Reverent Aura
        | Enchanter exception for Mana Recursion Auras
        /if ( ${AuraSpell.Find[Mana Reverberation]} || ${AuraSpell.Find[Mana Repercussion]} || ${AuraSpell.Find[Mana Reiteration]}) /varset AuraName Mana Recursion Aura
        | Enchanter exception for Mana Reverberation Aura lv 100
        /if (${AuraSpell.Find[Mana Reiterate]}) /varset AuraName Mana Reiterate Aura
        /if (${AuraSpell.Find[Mana Reverberation]}) /varset AuraName Mana Rev.
        /if (${AuraSpell.Find[Mana Resurgence]}) /varset AuraName Mana Resurgence Aura
        /if (${AuraSpell.Find[Mana Repercussion Aura]}) /varset AuraName Mana Rep. Aura
        /if (${AuraSpell.Find[Runic Radiance Aura]}) /varset AuraName Runic Rad. Aura
        | Mage exceptions because aura is on pet not in aura window and other fucked up shit
        /if (${AuraSpell.Find[Arcane Distillect]}) /varset TempAura Arcane Distillect
        /if (${AuraSpell.Find[Earthen Strength]}) /varset TempAura Earthen Strength Effect
        /if (${AuraSpell.Find[Rathe's Strength]}) /varset TempAura Rathe's Strength Effect
        | Check if aura is up 4 parts - Mage | Everyone else | 2 auras cleric | 2 auras enchamter
        /if (${Select[${Me.Class.ShortName},CLR,ENC,MAG]}==0 && !${Me.Aura[1].Name.Find[${AuraName}]}) {
            /goto :FoundAura
        } else /if (${Me.Class.ShortName.Equal[MAG]} && ${Me.Pet.ID} &&  ${Me.Pet.Distance}<175 && !${TempAura.Find[effect]} && !${Me.Aura[1].Name.Find[${TempAura}]}) {
            /goto :FoundAura
        } else /if (${Me.Class.ShortName.Equal[CLR]} && ((!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.AltAbility[Spirit Mastery]}) || (!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[2].Name.Find[${AuraName}]} && ${Me.AltAbility[Spirit Mastery]}))) {
            /goto :FoundAura
        } else /if (${Me.Class.ShortName.Equal[ENC]} && ((!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.AltAbility[Auroria Mastery]}) || (!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[2].Name.Find[${AuraName}]} && ${Me.AltAbility[Auroria Mastery]}))) {
            /goto :FoundAura
        } else /return ${AuraResult}
        :FoundAura
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Aura \agLine#: ${Macro.CurLine}
        | - Mutant Bards do this
        /if (${Me.Class.ShortName.Equal[BRD]}) {
            /if (!${Me.Gem[${AuraSpell}]} && ${Me.Book[${AuraSpell}]}) {
                /if (${Cursor.ID}) /call CheckCursor CheckAura
                /if (${Twist}) {
                    /while (${Me.BardSongPlaying}) {
                        /if (${Twist}) /squelch /twist off
                        /stopsong
                        /delay 10
                    }
                }
                /varset DontMoveMe 1
                /call CastMemSpell "${AuraSpell}" ${MiscGem} 0 CheckAura
                /varset DontMoveMe 0
                |/delay 15s ${Me.Gem[${MiscGem}].Name.Equal[${AuraSpell}]}
            }
            /if (${Me.Book[${AuraSpell}]}) {
                /squelch /twist once ${Me.Gem[${AuraSpell}]}
                /delay 50
                /varset AuraResult TRUE
                /return ${AuraResult}
            }
        }
        | - Normal casting
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]} && ${Me.CurrentEndurance}>500) {
            /disc ${AuraSpell}
            /delay 50
            /varset AuraResult TRUE
            /return ${AuraResult}
        } else {
            /call CastWhat "${AuraSpell}" ${Me.ID} CheckAura
        }
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /echo Casting Aura >> ${AuraSpell} <<
            /varset AuraResult TRUE
        }
    /return ${AuraResult}
| -------------------------------------------------------------------------------------
| SUB: CheckEndurance
| -------------------------------------------------------------------------------------
    Sub CheckEndurance(ESpell,EPct,EHealth)
        /if (${Me.Invis}) /return
        /declare EndResult string local FALSE
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Enter Spell: ${ESpell} EndPct: ${EPct} HealthPct: ${EHealth} \agLine#: ${Macro.CurLine}
        /if (${EHealth.Equal[null]} || !${EHealth.Length}) /varset EHealth 0
        /if (${DebugBuffs}) /echo DEBUGBUFFS CheckAura Endurance Regen Line#: ${Macro.CurLine}
        /if (${Me.Sitting}) /stand
        | /if (${Cursor.ID}) /call CheckCursor CheckEndurance
        /call CastWhat "${ESpell}" ${Me.ID} CheckEndurance
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset EndResult TRUE
            /echo Casting >> ${ESpell} << for endurance
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Leave \agLine#: ${Macro.CurLine}    
    /return ${EndResult}
| -------------------------------------------------------------------------------------
| SUB: SummonStuff
| -------------------------------------------------------------------------------------    
    Sub SummonStuff(SSpell,SumItem,int SumNum)
        /if (${Me.Invis}) /return
        /if (${FindItemCount[=${SumItem}]}>=${SumNum}) /return
        /declare SumResult string local FALSE
        /declare SummonAttempts int local 0
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS SummonStuff Enter SSpell: ${SSpell} SumItem: ${SumItem} SumNum: ${SumNum} \agLine#: ${Macro.CurLine}
        /if (${FindItemCount[=${SumItem}]}<${SumNum}) {
            :summonagain
            /if (${Twist}) {
                /squelch /twist off
                /varset Twisting 0
                /while (${Me.BardSongPlaying}) {
                    /stopsong
                    /delay 10
                    /if (${Twist}) /squelch /twist off
                }
            }
            /if (${Me.FreeInventory}==0) {
                /echo No room in inventory skipping summoning >> ${SumItem} <<.
                /goto :summondone
            }
            | Summon axes for zerkers had to be hard coded because spell is same name as tm item summoned.
            /if (${Select[${Me.Class.ShortName},BER]} && ${SSpell.Find[axe]}) {
                /docommand /disc ${SSpell}
                /delay 80 ${Cursor.ID}
                /varcalc SummonAttempts ${SummonAttempts}+1
                /goto :inventory
            } else {
                | Check if summoning from an item
                /if (${FindItemCount[=${SSpell}]} > 0) {
                    | Check if item is ready to cast
                    /if (${FindItem[=${SSpell}].Timer}!=0) {
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS ${SSpell} not ready yet skipping \agLine#: ${Macro.CurLine}
                        /varset SumResult FALSE
                        /return ${SumResult}
                    }
                }
                /if (${Cursor.ID}) /call CheckCursor SummonStuff
                /call CastWhat "${SSpell}" ${Me.ID} SummonStuff-nomem
            }
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs summon item cast result ${Macro.Return} \agLine#: ${Macro.CurLine}
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                :inventory
                /delay 15s ${Cursor.ID}
                /if (${Cursor.ID}) {
                    /echo Summoned  >> ${SumItem} <<
                    /varcalc SummonAttempts ${SummonAttempts}+1
                    /call CheckCursor SummonStuff
                }
                /if (${FindItemCount[=${SumItem}]}==0 && ${SummonAttempts}>0) {
                    /echo Summoning >> ${SumItem} << Failed - Check reagents, timer, etc
                    /echo -- Turning off ${SSpell} - ${SSpell}|Summon|${SumItem}|0
                    /varset SummonAttempts 0
                    /varset SumResult TRUE
                    /goto :summondone
                }
            }
            /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                /echo You are missing components. Turning Off ${SSpell}.
                /varset SumResult FALSE
                /return ${SumResult}
            }
            /if (${Macro.Return.Equal[CAST_NO_RESULT]}) {
                /varset SumResult FALSE
                /return ${SumResult}
            }
            /if (${FindItemCount[=${SumItem}]}<${SumNum} && ${SummonAttempts}<=5) /goto :summonagain
            :summondone
            /echo I now have ${SumNum} of >> ${SumItem} <<
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS SummonStuff Leave \agLine#: ${Macro.CurLine}    
    /return ${SumResult}
| -------------------------------------------------------------------------------------
| SUB: CheckIniBuffs
| -------------------------------------------------------------------------------------
    Sub CheckIniBuffs(BuffName, BuffsNum, int BuffRange, 1stPart, 2ndPart, 3rdPart, 4thPart)
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckIniBuffs Enter ${BuffName} ${BuffsNum} ${BuffRange} ${1stPart} ${2ndPart} ${3rdPart} ${4thPart}  \agLine#: ${Macro.CurLine}
        /declare k int local
        /declare l int local
        | Assign var IniIDList all the spawn ids from buff ini file 2345|2195|2391| etc
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        /declare IniBuffCount int local 0
        /declare IniBBuffList string local
        /declare IniBuffList string local
        /declare IniStackCheck[50] string local
        /declare PBTimerID int local
        /declare IniTempBuff string local
        /declare skipFlag int local 0
        | Check Buffs from ini
        /if (${Redguides}) {
            | IniIDCount = number of Char IDs counted in ini file. If 0 skip or Buff is null the the process.
            /if (${IniIDCount}<=0 || ${BuffName.Equal[null]}) /return
            | Start scan of buffs listed on toons in ini file
            /for k 1 to ${IniIDCount}
                /varset skipFlag 0
                /if (${AggroTargetID}) /return
                | If the Spawn ID is not in the zone and not a PC/merc and not me skip to next ID
                /if (!${Spawn[${IniIDList.Arg[${k},|]}].ID} || ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Type},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,NPC,TRIGGER,TRAP,TIMER,MOUNT]} || ${IniIDList.Arg[${k},|]}==${Me.ID}) /goto :NextCharCheck
                | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip because none of these are cast on others
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${BuffName}]}>=1 Self:${Spell[${BuffName}].TargetType.Find[self]} \agLine#: ${Macro.CurLine}
                | Set buff to correct spell to check for with Dual tag
                /if (${2ndPart.Find[Dual]}) {
                    /if (${Select[${Spell[${3rdPart}].TargetType},self]})  {
                        /goto :NextCharCheck
                    } else /varset BuffName ${3rdPart}
                }
                | If buff marked MA skipped if spawn ID isn't MA
                /if (${Select[${2ndPart},MA,DualMA]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.NotEqual[${MainAssist}]} || ${2ndPart.Equal[!MA]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.Equal[${MainAssist}]}) /goto :NextCharCheck
                /if ((${Select[${2ndPart},Caster,DualCaster]}>0 && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${Select[${2ndPart},Melee,DualMelee]}>0 && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /goto :NextCharCheck
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 1.1: 2ndPart: ${2ndPart} Class Name: ${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName} \agLine#: ${Macro.CurLine}
                | Temp variable to store buff name after stripping rk stuff makes it easier to compare
                /varset IniTempBuff ${BuffName}
                /if (${BuffName.Find[ Rk. III]}) /varset IniTempBuff ${BuffName.Left[-8]}
                /if (${BuffName.Find[ Rk. II]})  /varset IniTempBuff ${BuffName.Left[-7]}
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 2: ${Spawn[${IniIDList.Arg[${k},|]}].Name} ${IniIDList.Arg[${k},|]} ${IniTempBuff} ${BuffName} \agLine#: ${Macro.CurLine}
                | Assign var IniBBuffList blocked buffs list from ini file
                /varset IniBBuffList ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"Blockedbuffs"]}
                | If the current buff is on the blocked buff list skip it.
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 3: ${IniBBuffList.Find[${IniTempBuff}]} Buff blocked? \agLine#: ${Macro.CurLine}
                /if (${IniBBuffList.Find[${IniTempBuff}]}) /goto :NextCharCheck
                | Assign var IniBuffList buffs list from ini file
                /varset IniBuffList ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"Buffs"]}
                | If current buff is on the buff list skip it
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 4: ${IniTempBuff} ${IniBuffList.Find[${IniTempBuff}]} \agLine#: ${Macro.CurLine}
                /if (${IniBuffList.Find[${IniTempBuff}]}) /goto :NextCharCheck
                | Assign buff count
                /varset IniBuffCount ${Math.Calc[${IniBuffList.Count[|]}]}
                | Check if current buff stacks will all existing buffs in list
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 5: ${Spawn[${IniIDList.Arg[${k},|]}].Name} ${IniBuffCount} BuffsNum ${BuffName} \agLine#: ${Macro.CurLine}
                /for l 1 to ${IniBuffCount}
                    | Fix for stacking issues with Perfected Group Levitation there are a lot
                    /if (${IniBuffList.Arg[${l},|].Find[Group Perfected Levitation]} && !${BuffName.Find[Group Perfected Levitation]}) /continue
                    /if (!${Spell[${BuffName}].RankName.WillStack[${IniBuffList.Arg[${l},|]}]}) {
                        /varset skipFlag 1
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck Stack: ${IniBuffList.Arg[${l},|]} !Stack ${BuffName} ${Select[${Spell[${IniBuffList.Arg[${l},|]}].WillStack[${BuffName}]},TRUE,FALSE,NULL]} \agLine#: ${Macro.CurLine}
                        /break
                    }
                    |:PGLevFix
                /next l
                /if (!${skipFlag}) { 
                    | If buff has dual tag assign current buff to spell that needs to be cast
                    /if (${2ndPart.Find[Dual]}) /varset BuffName ${1stPart}
                    | varset ini buff timer toon Id spell Id to shorten var and clarity
                    /varset PBTimerID ${IniIDList.Arg[${k},|]}${Spell[${BuffName}].ID}
                    | Define timer for spell i am about to cast
                    /if (!${Defined[IniBuffTimer${PBTimerID}]}) /declare IniBuffTimer${PBTimerID} timer outer 0
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 6: ${Spawn[${IniIDList.Arg[${k},|]}].Name} Temp:${IniTempBuff} OnList:${IniBuffList.Find[${IniTempBuff}]} Timer:${IniBuffTimer${PBTimerID}} \agLine#: ${Macro.CurLine}
                    | Check if toon is within spell range and cast buff
                    /if (${Spawn[${IniIDList.Arg[${k},|]}].Distance}<=${BuffRange} && !${IniBuffTimer${PBTimerID}}) {
                        /if (${Spell[${BuffName}].TargetType.Equal[self]} && ${Spawn[${IniIDList.Arg[${k},|]}].ID}!=${Me.ID}) {
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs tried to buff ${Spawn[${IniIDList.Arg[${k},|]}].CleanName} with a self buff
                            /goto :NextCharCheck
                        }
                        /call CastWhat "${BuffName}" ${IniIDList.Arg[${k},|]} Buffs
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 7: /call CastWhat "${BuffName}" ${IniIDList.Arg[${k},|]} Buffs ${Macro.Return} \agLine#: ${Macro.CurLine}
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /echo Buffing >> ${BuffName} << on ${Spawn[${IniIDList.Arg[${k},|]}].CleanName}
                            /varset IniBuffTimer${PBTimerID} 60s
                            /varset IniNextTimer 0
                            /doevents flush Worn_off
                            /varset WriteBuffsTimer 0
                            /call WriteBuffs
                        }
                    }
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 8: IniBuffTimer${PBTimerID}:${IniBuffTimer${PBTimerID}} IniNextTimer:${IniNextTimer} \agLine#: ${Macro.CurLine}
                }
                :NextCharCheck
                /if (${2ndPart.Find[Dual]}) /varset BuffName ${3rdPart}
            /next k
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckIniBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: RegenOther
| ----------------------------------------------------------------------------
    Sub RegenOther(RGName, Stat, int StatPct, RegonOnClasses)
    | Casting on others during combat will interrupt fast med
    /if (${Medding} && ${MedCombat}) /return FALSE
    /if (${Me.Invis}) /return FALSE
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Enter \agLine#: ${Macro.CurLine} ${RGName} ${Stat} ${StatPct} ${RegonOnClasses} \agLine#: ${Macro.CurLine}
        /declare i int local 
        /declare ROResult string local FALSE
        /if (${RegonOnClasses.Equal[0]} || ${RegonOnClasses.Equal[null]}) {
            /if (${Stat.Equal[endurance]}) {
                /varset RegonOnClasses BER,BST,MNK,PAL,RNG,ROG,SHD,WAR
            } else /if (${Stat.Equal[mana]}) {
                /varset RegonOnClasses BRD,BST,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHD,SHM,WIZ
            }
        }
        /for i 1 to ${Group}
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Class: ${Group.Member[${i}].Class.ShortName} AggroID: ${AggroTargetID}  GrpMemPct: ${Group.Member[${i}].Current${Stat}}<=${StatPct} GrpMemID: ${Group.Member[${i}].ID}  \agLine#: ${Macro.CurLine}        
            | If bard rallying call aa skip tank or he won't attack
            /if (${RGName.Find[Rallying Call]} && ${Group.Member[${i}].ID}==${Spawn[${MainAssist} ${MainAssistType}].ID}) /continue 
            | Bard Dichotomic uses endurance not mana
            /if  (${RGName.Find[Dichotomic Psalm]} && ${Me.CurrentEndurance}<15000) /continue
            | Dichotomic Psalm & Quiet Miracle do not work on bards
            /if (${Group.Member[${i}].Class.Name.Equal[bard]} && (${RGName.Equal[Dichotomic Psalm]} || ${RGName.Equal[Quiet Miracle]})) /continue
            /if (${Select[${Group.Member[${i}].Class.ShortName},${RegonOnClasses}]} && !${AggroTargetID} && ${Group.Member[${i}].Current${Stat}}<=${StatPct} && ${Group.Member[${i}].Current${Stat}}>=1 && ${Group.Member[${i}].ID}) {            
                /call CastWhat "${RGName}" ${Group.Member[${i}].ID} Regenother
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting ${RGName} on ${Group.Member[${i}].CleanName} for ${Stat}.
                    |/varcalc Buff${i}GM${j} (${Spell[${1stPart}].Duration.TotalSeconds}*${DurationMod})*10
                    /varset ROResult TRUE
                    /break
                }
            }
            |:NextGMember              
        /next i
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Leave \agLine#: ${Macro.CurLine}
    /return ${ROResult}    
| -------------------------------------------------------------------------------------
| SUB: Target Window Buffs
| -------------------------------------------------------------------------------------     
    Sub TargetWinBuffs(int TWtargetID,Checkbuff,FromSub)
        /if (!${Checkbuff.Length} || ${Spawn[TWtargetID].ID}) /return
        /declare i int local
        /for i 0 to 50
            /if (${Window[TargetWindow].Child[Target_Buff${i}_Button].Tooltip.Find[${Checkbuff}]}) {
                /echo ${Target.CleanName} has ${Checkbuff} skipping to next buff
                /if (${FromSub.Equal[CastWhat]}) /call Interrupt
                /return TRUE 
            }
        /next i
    /return 
| -------------------------------------------------------------------------------------
| SUB: PetStateCheck
| -------------------------------------------------------------------------------------
    Sub PetStateCheck 
        /if (${DebugPet}) /echo Checking Pet State. \agLine#: ${Macro.CurLine}
        /if (${Me.AltAbility[Companion's Suspension]}>0) {    
            :CastSusMin
            /if (${Me.AltAbilityReady[Companion's Suspension]}) {
                /casting "Companion's Suspension" alt
                /delay 5s !${Me.Casting.ID}
                /doevents
            } else {
                /echo Waiting on Suspend Minion AA to be ready.
                /delay 10
                /goto :CastSusMin
            }
       } else {
            /echo You do not have the "Companion's Suspension" AA, PetSuspend being turned off.
            /varset PetSuspend 0    
        }
        /if (${Me.Pet.ID}) /varset PetActiveState  1
    /return
| -------------------------------------------------------------------------------------
| SUB: DoPetStuff
| -------------------------------------------------------------------------------------
    Sub DoPetStuff
        | /if (!${PetOn} || ${AggroTargetID} || ${Me.Invis} || ${Me.Hovering}) /return
        /if (!${PetOn}) /return
        /if (${AggroTargetID}) /return
        /if (${Me.Invis}) /return
        /if (${Me.Hovering}) /return
        /declare PetSummonTimer timer local 60s
        /doevents
        /if (${Debug}) /echo \atDEBUG DoPetStuff Enter \agLine#: ${Macro.CurLine}
        /declare FocusCurrent string local ${InvSlot[${PetFocus.Arg[2,|]}].Item.Name}
        /declare FocusSlot string local ${PetFocus.Arg[2,|]} ${PetFocus.Arg[1,|]}
        /declare FocusPet string local ${PetFocus.Arg[1,|]}
        /declare FocusSwitch int local 0
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]}) /pet get lost
        | Swap pet focus in pet cast
        /if (!${Me.Pet.ID} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
            | verbose
            /echo I have no pet. ${Me.Class}s live longer when we have pets.
            /varset PetActiveState 0
            /if (${PetFocus.Arg[1,|].Length} && ${FindItemCount[=${FocusPet}]}) {
                /if (!${Cursor.ID} && ${FocusPet.NotEqual[${FocusCurrent}]}) {
                    |/call CheckCasting 50
                    /exchange "${FocusPet}" ${FocusSlot}
                    /varset FocusSwitch 1
                    /delay 10
                }
            }
            /doevents
            /delay 3
            | Pet spell mem check - Else try item like mage epic
            /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff
            | Summon Pet
            |- If using suspended pet function.
            /if (${PetSuspend}) {
               |- If I have a suspended pet bust him out!
               /if ((${PetTotCount}==1) && (${PetActiveState}==0) && (${PetSuspendState}==1)) {
                   /echo I have a suspended pet, summoning it now!
                   /call PetStateCheck           
               }
               |- If I don't have a suspended or an active pet, make them.
               /if (${PetTotCount}<2 && ${PetSuspendState}==0 && ${PetActiveState}==0 && ${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
                    :MakeMyPet1
                    /echo - Making pet now.
                    /echo ARISE ${PetSpell}
                    /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components to make this pet. Ending macro.
                        /end
                    } 
                    /delay 10s !${Me.Casting.ID}
                    /delay 1s ${Me.Pet.ID}            
                    /if (!${Me.Pet.ID} && ${PetSummonTimer}) {
                        /goto :MakeMyPet1
                    } else {                
                        /if (${Me.Pet.ID})  /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                        /varset PetActiveState 1
                        /call CheckPetBuffs
                        /if (${Me.Pet.ID} && ${PetToysOn}) {
                            /call PetToys ${Me.Pet.CleanName}
                            /if ((${PetSuspendState}==0) && (${PetActiveState}==1)) /varset PetToysDone 0
                            /if ((${PetSuspendState}==1) && (${PetActiveState}==1)) /varset PetToysDone 1
                        }
                    }
                    /call PetStateCheck
                    /if (${PetTotCount}<2 && ${PetSuspendState}==1 && ${PetActiveState}==0  && ${PetSummonTimer}) /goto :MakeMyPet1
                }
            } else /if (${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
                | Normal pet function for not using suspend pet.
                :MakeMyPet2
                /echo ARISE ${PetSpell}
                /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff
                /delay 10s !${Me.Casting.ID}
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components to make this pet. Ending macro.
                    /end
                } 
                /delay 1s ${Me.Pet.ID}
                /if (!${Me.Pet.ID}  && ${PetSummonTimer}) {
                    /goto :MakeMyPet2
                } else {                
                    /if (${Me.Pet.ID})  /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                    /varset PetActiveState 1                
                }
                | Swap pet focus out for regular item
                /if (${FocusSwitch} && !${Cursor.ID}) {
                    |/call CheckCasting
                    /exchange "${FocusCurrent}" ${FocusSlot}
                    /delay 10
                }            
            }
            | Reset PetToysGave in config after pet creation, as well as memory variable so we will pickup if our pet needs toys after death, under new condition checks.
            /ini "${IniFileName}" "Pet" "PetToysGave" ""
            /if (${Me.Pet.ID} && ${PetToysOn}) /varset PetToysGave "NULL"
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]} && ${Me.Pet.Distance}>${CampRadius}) /pet follow
            /if (${PetHoldOn}) /pet ${PetHold} on      
            /if (${Me.AltAbility[Pet Discipline]}>5) /pet focus on
            /if (!${PetTauntOn} && ${Select[${Role},pettank,pullerpettank]}) /pet taunt on
        }
        /call CheckPetBuffs
        | Pet Toy routines
        | Condition revised to only call PetToys if I do not have my pet name in the PetToysGave string.
        /if (${Me.Pet.ID} && ${PetToysOn} && (!${PetToysGave.Find[${Me.Pet.CleanName}]} || !${PetToysGave.Find[Summoned]})) /call PetToys ${Me.Pet.CleanName}
        | Check to have pet come to owner if owner out of camp too long.
        /if (${Select[${Role},pettank,hunterpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) && ${Me.Pet.Stance.Equal[GUARD]}) /pet follow
        |/if (${Me.Pet.ID} && ${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscSpell}]}) /memorize "${ReMemMiscSpell}" gem${MiscGem}
        /if (${Me.Pet.ID} && ${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscSpell}]} && ${MiscGemRemem}) {
            /varset DontMoveMe 1
            /call CastMemSpell "${ReMemMiscSpell}" ${MiscGem} 0 DoPetStuff
            /varset DontMoveMe 0
        }
        /if (${Debug}) /echo \atDEBUG DoPetStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckPetBuffs
| -------------------------------------------------------------------------------------
    Sub CheckPetBuffs
        /if (!${Me.Pet.ID}) /return
        /if (!${PetOn}) /return
        /if (!${PetBuffsOn}) /return
        /if (${CombatStart}) /return
        /if (${Pulling}) /return
        /if (${PetBuffCheck}) /return
        /if (${Me.Invis}) /return
        /if (${Debug}) /echo \atDEBUG CheckPetBuffs Enter \agLine#: ${Macro.CurLine}
        /declare PTempBuff string local
        /declare i int local
        /declare j int local
        /declare 1stPart string local 0
        /declare 2ndPart string local 0
        /declare 3rdPart string local 0                
        /declare FoundPetBuff int local 0
        /varset PetBuffCheck 60s
        /for i 1 to ${PetBuffs.Size}
            /doevents
            | Stop pet buffing if aggro detected
            /if (${AggroTargetID}) /return
            /if (${PetBuffs[${i}].Equal[Null]}) /goto :SkipPetBuff
            | Check for pet spells in book to prevent double casting of items
            /if (${Me.Book[${PetBuffs[${i}]}]} || ${Me.AltAbilityReady[${PetBuffs[${i}]}]}) {
                /varset PTempBuff ${PetBuffs[${i}]}
                /if (${PetBuffs[${i}].Find[ Rk. III]}) /varset PTempBuff ${PetBuffs[${i}].Left[-8]}
                /if (${PetBuffs[${i}].Find[ Rk. II]}) /varset PTempBuff ${PetBuffs[${i}].Left[-7]}
                /if (${Debug}) /echo \atDEBUG CheckPetBuffs ${i} ${Me.PetBuff[${PTempBuff}]} ${PetBuffs[${i}]} ${PTempBuff} \agLine#: ${Macro.CurLine}
                /for j 1 to 50
                    /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) /varset FoundPetBuff 1
                /next j
                /if (!${FoundPetBuff}) {
                    | Vebrose
                    /call CastWhat "${PetBuffs[${i}]}" ${Me.Pet.ID} Pet-nomem
                    /delay 20
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Buffing ${Me.Pet.CleanName}, my pet, with ${PetBuffs[${i}]}
                    /varset FoundPetBuff 0
                    /goto :SkipPetBuff
                }
            }
            /if (${Debug}) /echo \atDEBUG CheckPetBuffs ${FindItem[=${PetBuffs[${i}]}].Spell} ${Me.PetBuff[${FindItem[=${PetBuffs[${i}]}].Spell}]} \agLine#: ${Macro.CurLine}
            /if (${Me.PetBuff[${FindItem[=${PetBuffs[${i}]}].Spell}]}>=1) /goto :SkipPetBuff
            |- Cast item clicky buff (ItemName and PetBuff = DIFFERENT)
            |--- START: Multipart handling for PetBuffs.
            /if (${PetBuffs[${i}].Find[|]}) {            
                /varset 1stPart ${PetBuffs[${i}].Arg[1,|]}
                /varset 3rdPart ${PetBuffs[${i}].Arg[3,|]}
                /varset PTempBuff ${3rdPart}
                |--- START: DUAL Handle for different Effect names versus their Item name
                /if (${Debug}) /echo \atDEBUG CheckPetBuffs - Dual - ${1stPart} - ${3rdPart} \agLine#: ${Macro.CurLine}
                /if (${PetBuffs[${i}].Arg[2,|].Equal[Dual]}) {
                    /if (${FindItem[=${1stPart}].ID}) {
                        /for j 1 to 50
                            /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) /varset FoundPetBuff 1
                        /next j
                        /if (!${FoundPetBuff}) {
                            |Vebrose
                            /call CastWhat "${1stPart}" ${Me.Pet.ID} Pet
                            /delay 20
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Buffing ${Me.Pet.CleanName}, my pet, with (${3rdPart})
                            /varset FoundPetBuff 0        
                            /goto :SkipPetBuff
                        }
                    }
                }
                |--- END: DUAL Handle for different Effect names versus their Item name                
            }
            |--- END: Multipart handling for PetBuffs.
            |- Cast item clicky buff (ItemName and PetBuff = SAME)
            /if (${FindItem[=${PetBuffs[${i}]}].ID}) {
                /call CastWhat "${PetBuffs[${i}]}" ${Me.Pet.ID} Pet
                |/call CheckCasting 75
            }
            :SkipPetBuff
            /varset FoundPetBuff 0
        /next i
        /if (${Debug}) /echo \atDEBUG CheckPetBuffs Pet Height: ${Me.Pet.Height} \agLine#: ${Macro.CurLine}
        /if (${Me.Pet.Height}>1.35 && ${PetShrinkOn}) {
            /call CastWhat "${PetShrinkSpell}" ${Me.Pet.ID} Pet
            /delay 20
        }
        /if (${Target.ID}==${Me.Pet.ID}) /squelch /target clear
        /if (${Debug}) /echo \atDEBUG CheckPetBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check PetToys - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub PetToys(string petName)
        /if (!${Me.Pet.ID}) /return
        /if (${DebugPet}) /echo \atDEBUGPet PetToys Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare GrabItem int local 0
        /declare PetToySpell string local 0
        /declare FullText string local
        /declare 2ndPart string local
        /declare 3rdPart string local
        /declare PetToysTemp string local ${Ini[${IniFileName},Pet,PetToysGave]}
        /declare GaveItem int local 1
        /call OpenInvSlot
        /declare petID int local ${Spawn[pet ${petName}].ID}
        /if (${BagNum}==0) {
            /echo You must have an empty Top Inventory slot for Pet Toys to work.
            /varset PetToysOn 0
            /return
        }
        /if (!${InvSlot[pack${BagNum}].Item.Container} && !${Me.FreeInventory}) {
            /echo Inventory is full
            /varset PetToysOn 0
            /return
        }
        | reset if different pet name only on my pet
        /if (!${PetToysTemp.Find[${petName}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
            /ini "${IniFileName}" "Pet" "PetToysGave" "0"
            /varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
        }
        /for i 1 to ${PetToys.Size}
            /if (${DebugPet}) /echo CHECKING: ${PetToys[${i}]} \agLine#: ${Macro.CurLine}
            /if (${DebugPet}) {
                /echo \atDEBUGPET PetToys 1: ${PetToys[${i}]} \agLine#: ${Macro.CurLine}
                /echo \atDEBUGPET PetToys 2: ${PetToysTemp} \agLine#: ${Macro.CurLine}
                /echo \atDEBUGPET PetToys 3: ${PetToys[${i}].Equal[Null]} || ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]} \agLine#: ${Macro.CurLine}
            }
            | Had to add pet name check else it will always skip giving weapons to OTHER pets.                        
            /if (${PetToys[${i}].Equal[Null]} || (${Me.Pet.CleanName.Equal[${petName}]} && ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]})) /goto :SkipPetToy
            | Are we handing weapons to the pet
            /if (${PetToys[${i}].Arg[2,|].Length}) {
                /varset FullText ${PetToys[${i}]}
                /varset PetToySpell ${PetToys[${i}].Arg[1,|]}
                /varset 2ndPart ${PetToys[${i}].Arg[2,|]}
                /varset 3rdPart ${PetToys[${i}].Arg[3,|]}
            } else {
                /varset PetToySpell ${PetToys[${i}]}
            }
            /if (${Me.Pet.CleanName.Equal[${petName}]} && ((${2ndPart.Length} && ${PetToysTemp.Find[${2ndPart}1]}) || (${3rdPart.Length} && ${PetToysTemp.Find[${3rdPart}2]}))) /goto :SkipPetToy
            | Check for pet toy spells in book to prevent double casting of items
            /if (${Me.Book[${PetToySpell}]}) {
                /call CastWhat "${PetToySpell}" ${Me.ID} Pet-nomem
                /if (!${PetToysTemp.Find[${petName}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
                    /ini "${IniFileName}" "Pet" "PetToysGave" "${petName}"
                    /varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
                }
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting pet toy spell >> ${PetToySpell} <<
                }

                /delay 15s ${Cursor.ID}
                /if (!${Cursor.ID}) /return
                | Check if spell has summoned a bag or folded pack
                /if (${Cursor.Container} || ${Cursor.Name.Find[Folded]}) {
                    | If item is in Inv Slot exchange it with bag on cursor
                    /if (${InvSlot[pack${i}].Item.ID}) /nomodkey /itemnotify pack${BagNum} leftmouseup
                    :Unfolded
                    /delay 2s ${Cursor.ID}
                    | Drop bag or item into inventory
                    /autoinventory
                    /delay 1s
                    | Drop exchanged item into inventory after bag is dropped
                    /if (${Cursor.ID}) /autoinventory
                    | If folded pack right click to convert to phantom satchel
                    /if (${InvSlot[pack${BagNum}].Item.Name.Find[folded]}) {
                        /nomodkey /itemnotify pack${BagNum} rightmouseup
                        /echo Opening ${InvSlot[pack${BagNum}].Item.Name}
                        /delay 3s
                        | Return to top to drop bag into inventory
                        /goto :Unfolded
                    }
                }
                /if (${InvSlot[pack${BagNum}].Item.Container} && (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]})) {
                    | Open the bag
                    /nomodkey /itemnotify pack${BagNum} rightmouseup
                    /delay 10
                    /if (${DebugPet}) /echo \atDEBUGPET PetToys ${i} ${PetToySpell} ${2ndPart} ${3rdPart} \agLine#: ${Macro.CurLine}
                    | Condition revised to allow for pet weapons to be given to other people's pets.
                    /if (((${Me.Pet.CleanName.Equal[${petName}]} && !${PetToysTemp.Find[${2ndPart}1]}) && ${2ndPart.Length} && ${FindItemCount[=${2ndPart}]}) || (!${Me.Pet.CleanName.Equal[${petName}]} && ${2ndPart.Length} && ${FindItemCount[=${2ndPart}]})) {
                        /call GiveTo "${2ndPart}" ${petID}
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}1
                        /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                    | Condition revised to allow for pet weapons to be given to other people's pets.
                    /if (((${Me.Pet.CleanName.Equal[${petName}]} && !${PetToysTemp.Find[${3rdPart}2]}) && ${3rdPart.Length} && ${FindItemCount[=${3rdPart}]}) || (!${Me.Pet.CleanName.Equal[${petName}]} && ${3rdPart.Length} && ${FindItemCount[=${3rdPart}]})) {                  
                        /call GiveTo "${3rdPart}" ${petID}
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${3rdPart}2
                        /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                    /if (!${2ndPart.Length}) {
                        /for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
                            /if (${InvSlot[pack${BagNum}].Item.Item[${j}].ID} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
                                /call GiveTo "${InvSlot[pack${BagNum}].Item.Item[${j}].Name}" ${petID}
                            }
                            /delay 10
                        /next j
                        /if (${j}>=8 && !${PetToysTemp.Find[${PetToySpell}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
                            /varset PetToysTemp ${PetToysTemp}|${PetToySpell}
                            /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                        }
                    }
                }
                /if (${Cursor.Name.Find[Summoned:]}) {
                    /call GiveTo "${Cursor.Name}" ${petID}
                    /varset PetToysTemp ${PetToysTemp}|${PetToySpell}
                    /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    /varset GaveItem 0
                }
                /if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) /call DestroyBag
                |/goto :SkipPetToy
            }
        :SkipPetToy
            | Reset spell vars
            /if (${2ndPart.Length}) {
                /varset FullText
                /varset 2ndPart
                /varset 3rdPart
            }
            /if (!${PetToysOn}) /return
        /next i
        | MUST reset PetToysGave after cycle complete in order to stop calling PetToys all the time.
        /varset PetToysGave ${PetToysTemp}
        /if (${Window[InventoryWindow].Open} && !${GaveItem}) /keypress inventory
        /varset PetToysDone 1
        /if (${DebugPet}) /echo \atDEBUGPET PetToys Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check OpenInvSlot - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub OpenInvSlot
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS OpenInvSlot Enter \agLine#: ${Macro.CurLine}
        /if (${BagNum}) /return
        /declare i int local
        /varset BagNum 0
        /for i 1 to 10
            /if (${InvSlot[pack${i}].Item.Container}) /continue
            /if (!${InvSlot[pack${i}].Item.Container} || ${InvSlot[pack${i}].Item.ID}==0) {
                | Must have at least 2 inv slots open in order to swap bags and items
                /if (${Me.FreeInventory}>=2) /varset BagNum ${i}
            }    
            /if (${BagNum}) {
                /echo Pet Toys: Inventory slot ${i} is empty using that one.
                /delay .5
                /return
            }
            |:NextSlot
        /next i
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS OpenInvSlot Leave  \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check DestroyBag - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub DestroyBag
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS DestroyBag Enter  \agLine#: ${Macro.CurLine}
        /declare j int local
        | Make sure bag has no items other than summoned in it before deleting.
        /if (${InvSlot[pack${BagNum}].Item.Items}) {
            /for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
                /if (!${InvSlot[pack${BagNum}].Item.Item[${j}].NoRent} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
                    /echo Bag has non summoned item(s) in it. Aborting delete. Pet Toys Off
                    /varset PetToysOn 0
                    /return
                }
            /next j
        }
        /if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) {
            /nomodkey /itemnotify pack${BagNum} leftmouseup
            /delay 5s ${Cursor.ID}
            /if (${Cursor.Name.Find[Phantom Satchel]} || ${Cursor.Name.Find[Pouch of Quellious]}) /destroy
            /delay 20 !${Cursor.ID}
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check GiveTo - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub GiveTo(string GItem, int GTarget)
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS GiveTo Enter \agLine#: ${Macro.CurLine}
        /declare ItemSummoned int local 0
        /if (${Target.ID}!=${GTarget}) {
            /target id ${GTarget}
            /delay 2s ${Target.ID}==${GTarget}
        }
        /if (${Target.Distance}>10 && ${Target.Distance}<=${CampRadius}) {
            /moveto id ${Target.ID}
            /delay 50 ${MoveTo.Stopped}
        }
        /if (!${Cursor.ID} && ${FindItemCount[=${GItem}]}>0) {
            /shift /itemnotify "${GItem}" leftmouseup
            /delay 20 ${Cursor.ID}
        }
        :CursorFree
        /if (${Cursor.ID} && ${Cursor.NoRent} && ${Cursor.ID}==${FindItem[=${GItem}].ID}) {
            /varset ItemSummoned 1
            /nomodkey /click left target
            /delay 10
        }
        /if (${Cursor.ID} && ${Cursor.NoRent}) /goto :CursorFree
        /delay 30 ${Window[GiveWnd].Open}
        /if (${ItemSummoned} && ${Window[GiveWnd].Open}) {
            /notify GiveWnd GVW_Give_Button leftmouseup
            /echo Giving ${GItem} to ${Target.CleanName}
        } else {
            /echo Item is NOT SUMMONED canceling trade
            /notify GiveWnd GVW_Cancel_Button leftmouseup
        }
        /delay 15 
        | New pet patch gives back item if pet has equipped. Delete item from cursor.
        /if (${Cursor.ID} && ${Cursor.NoRent} && ${Cursor.ID}==${FindItem[=${GItem}].ID}) {
            /while (${Cursor.ID}) {
                /destroy
                /delay 10
            }
        }
        /delay 200 !${Window[GiveWnd].Open}
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS GiveTo Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check Plugin
| ----------------------------------------------------------------------------
    Sub CheckPlugin(string pluginname)
        /if (${Debug}) /echo \atDEBUG CheckPlugin: Enter \agLine#: ${Macro.CurLine}
        /if (!${Bool[${Plugin[${pluginname}]}]}) {
            /squelch /plugin ${pluginname}
            /echo ${pluginname} not detected! This macro requires it! Loading ...
        }
        /if (${Debug}) /echo \atDEBUG CheckPlugin: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Load Ini
| ----------------------------------------------------------------------------
    Sub LoadIni(string sectionName, string varName, string varType, string varValue, string varArray, string varArray2, string FileName, string FileName2)
        /if (${Debug}) {
            /delay 2
            /echo \atDEBUG Sub Loadini S:${sectionName} V1:${varName} V2:${varType} V3:${varValue} V4:${varArray} V5:${varArray2} V6:${FileName} V7:${FileName2} \agLine#: ${Macro.CurLine}
        }
        /declare rkTemp                 string      local 
        /declare UtilInt                int         local        0 
        /declare FileName1              string      local        ${FileName}
        | Assign ini name to default ini if not defined
        /if (${FileName1.Length}==0  || ${FileName1.Equal[NULL]}) {
            /varset FileName1 ${IniFileName}
        }
        | Check if ini value is asking for an array ie buff1 to buff20
        
        /if (${Bool[${varArray}]}) {
            /if (${${varArray}.Size}>0) {
                /declare i int local
                /for i 1 to ${${varArray}.Size}
                    /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) /ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
                    /if (${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) /varset ${varArray}[${i}] ${Ini[${FileName1},${sectionName},${varArray}${i}]}
                    /if (${Debug}) /echo \atDEBUG ${ConditionsOn} ${Int[${varArray2.Length}]} ${varArray2.Length} ${Bool[${varArray2.NotEqual[null]}]} ${varArray2}
                    /if (${Defined[ConditionsOn]}) {
                        /if (${ConditionsOn} && ${Int[${varArray2.Length}]}>0 && ${varArray2.NotEqual[null]}) {
                            | Check to see if the conditions file is a different file and update spell info.
                            /if (${FileName2.NotEqual[${FileName1}]}) /ini "${FileName2}" "${sectionName}" "${varName}${i}" "${${varArray}[${i}]}"
                            /if (!${Ini[${FileName2},${sectionName},${varArray2}${i}].Length}) {
                                /if (${${varArray}[${i}].NotEqual[null]}) {
                                    /ini "${FileName2}" "${sectionName}" "${varArray2}${i}" "TRUE"
                                } else {
                                    /ini "${FileName2}" "${sectionName}" "${varArray2}${i}" "FALSE"
                                }
                            }
                            /varset ${varArray2}[${i}]  ${Ini[${FileName2},${sectionName},${varArray2}${i},TRUE,noparse]}
                        } else /if (${Int[${varArray2.Length}]}>0 && ${varArray2.NotEqual[null]}) {
                            /varset ${varArray2}[${i}] TRUE
                        } 
                    } else {
                        /varset ${varArray2}[${i}] TRUE
                    }
                    /if (${${varArray}[${i}].NotEqual[null]}) {
                        | find out if there is a Rank and fix spell name.
                        /if (${varType.Equal[string]} && ${Int[${${varArray}[${i}].Left[1]}]}==0) {
                                /call SpellRankCheck "${${varArray}[${i}]}"
                            /varset ${varArray}[${i}] ${Macro.Return}
                        }
                        | code to fix the Heal PCT for those zones that knock your HPs down to 
                        /if (${sectionName.Equal[Heals]} && ${Select[${Zone.ID},795,796]}) {
                            /if (${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0) {
                                /varset UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}
                                /varcalc UtilInt 70*(${UtilInt}/100)
                                /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                            }
                        } else /if (${sectionName.Equal[DPS]} && ${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0 && ${${varArray}[${i}].Arg[3,|].Equal[debuffall]}) {
                            /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
                            /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                        }
                    }
                    /if (${Debug}) /echo  \atDEBUG Loadini ${i} - ${varArray}[${i}] - ${${varArray}[${i}]} - ${Macro.Return} - ${Me.AltAbility[${Macro.Return}]} \agLine#: ${Macro.CurLine}
                /next i
                /return
            }
        } else {
            /if (!${Defined[${varName}]} && ${Defined[varType]}) /declare ${varName} ${varType} outer 0
            |Using the varArray2 to tell if trying to find a conditional entry or not. False = conditional null = non-conditional
            /if (${varArray2.Length}==0 || ${varArray2.Equal[false]} || ${varArray2.Equal[NULL]}) {
                /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                    /if (${varValue.Length}) {
                        /ini "${FileName1}" "${sectionName}" "${varName}" "${varValue}"
                        /varset ${varName} ${varValue}
                        /if (${Debug}) /echo \atDEBUG Sub Loadini /varset ${varName} ${varValue} \agLine#: ${Macro.CurLine}
                    }
                } else {
                    /varset ${varName} ${Ini[${FileName1},${sectionName},${varName}]}
                }
                /if (${FileName1.Equal[${IniFileName}]}) {
                    /varset rkTemp ${${varName}}
                    | find out if there is a Rank and fix spell name.
                    /if (${varType.Equal[string]} && ${Int[${rkTemp.Left[1]}]}==0 && !${varName.Find[Help]}) {
                        /call SpellRankCheck "${${varName}}"
                        /if (${Macro.Return.NotEqual[null]}) /varset ${varName} ${Macro.Return}
                    }
                }
            } else /if (${Defined[ConditionsOn]}) {
                /if (${ConditionsOn}) {
                    /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                        /if (${varValue.Length}) {
                            /ini "${FileName1}" "${sectionName}" "${varName}" "${varValue}"
                            /varset ${varName} ${varValue}
                            /if (${Debug}) /echo \atDEBUG Sub Loadini /varset ${varName} ${varValue} \agLine#: ${Macro.CurLine}
                        }
                    } else {
                        /varset ${varName} ${Ini[${FileName1},${sectionName},${varName}]}
                    }
                } else {
                    /varset ${varName} ${varValue}
                }
            } else {
                /varset ${varName} ${varValue}
            }
            /if (${Debug}) /echo \atDEBUG Sub LoadIni: ${varName} - ${${varName}} \agLine#: ${Macro.CurLine}
            /varset rkTemp 
        }
        /if (${Debug}) /echo \atDEBUG Sub LoadIni: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: End Mac If
| ----------------------------------------------------------------------------
    Sub EndMacroIf
        /if (${Debug}) /echo \atDEBUG EndMacroIf: Enter \agLine#: ${Macro.CurLine}
        | I died wait for rez loop
        :WaitOnRez
        /if (${EverQuest.GameState.Equal[CHARSELECT]}) /endmac
        /if ((${Me.Hovering} || ${CampZone} != ${Zone.ID}) && ${RezAcceptOn} && ${IAmDead}) {
            /if (${Attacking}) /call CombatReset 0 endmacroif
            /delay 10
            /if (${ClickBacktoCamp}) /call CampfireBack
            /if (${CampOnDeath}) /call DoICamp
            /goto :WaitOnRez
        }
        /if (!${RezAcceptOn} && ${CampZone} != ${Zone.ID}) {
            /if (${CampOnDeath}) /call DoICamp
            /if (${IAmDead}) {
                /if (${Twist}) {
                    /squelch /twist off
                    /delay 20
                } else /if (${Me.BardSongPlaying}) {
                    /stopsong
                }
                /endmac
            }
        }
        /if (${Debug}) /echo \atDEBUG EndMacroIf: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Do I Camp
| ----------------------------------------------------------------------------
    Sub DoICamp
        /if (!${CampOnDeath}) /return
        /if (!${CampOnDeathTimer} && ${CampZone} != ${Zone.ID} && ${Me.Buff[Revival Sickness].ID}) {
            /echo I am dead and not where I am suppose to be. Time to camp out.
            /if (${IAmABard}) {
                /while (${Me.BardSongPlaying}) {
                    /if (${Twist}) /squelch /twist off
                    /stopsong
                    /delay 10
                }
            }
            /docommand /camp desktop
            /delay 40s
            /endmac
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Do Bard Stuff
| ----------------------------------------------------------------------------
    Sub DoBardStuff
        /if (${Me.Class.Name.NotEqual[Bard]}) /return
        /if (!${Twist}) {
            /varset Twisting 0
            /varset DPSTwisting 0
            /if (${Me.BardSongPlaying} && ${Me.Casting.ID} && !${Window[CastingWindow].Open}) /stopsong
        }
        /if (!${BardStartTwist} && !${Me.Invis}) {
            /while (${Me.BardSongPlaying}) {
                /if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
            /if (${TwistWhat.Length} && ${TwistWhat.Find[order]}==0) /squelch /twist ${TwistWhat}
            /varset BardStartTwist 1
            /return
        }
        /if (${Me.Invis} && ${Twist} || (${Medding} && ${MedCombat} && ${AggroTargetID})) {
            /while (${Me.BardSongPlaying}) {
                /if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
            /return
        }
        /if (${Debug}) /echo \atDEBUG DoBardStuff: Enter \agLine#: ${Macro.CurLine}
        /if (${MeleeTwistOn} && ${CombatStart} && (!${DPSTwisting} || (${DPSTwisting} && !${Twist}))) {
            /if (!${DPSTwisting} && ${MeleeTwistWhat.NotEqual[Continuous]}) /echo == Starting melee twist
            /varset DPSTwisting 1
            /varset Twisting 0
            /if (${MeleeTwistWhat.Equal[Continuous]}) {
                /if (${Twist}) {
                    /echo == Continuing normal twist for melee
                    /return
                } else {
                    /squelch /twist ${TwistWhat}
                }
            } else {
                /squelch /twist ${MeleeTwistWhat}
            }
        }
        /if (${TwistOn} && !${CombatStart} && !${Twisting}) {
            /varset DPSTwisting 0
            /varset Twisting 1
            /if (${MeleeTwistWhat.Equal[Continuous]} && ${Twist} && ${Twist.Current}!=${TwistMed}) {
                    /echo == Continuing normal twist
                    /return
            } else {
                /squelch /twist ${TwistWhat}
                /echo == Starting normal twist
            }
        }
        /if (!${TwistOn} && !${CombatStart} && ${Twist}) {
            /while (${Me.BardSongPlaying}) {
                /if (${Twist}) /squelch /twist off
                /stopsong
                /delay 10
            }
        }
        /delay 1
        /if (${Debug}) /echo \atDEBUG DoBardStuff: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: GroupEscape
| ----------------------------------------------------------------------------
    Sub GroupEscape
        /if (!${GroupEscapeOn}) /return
        /if (${Debug}) /echo \atDEBUG GroupEscape Enter \agLine#: ${Macro.CurLine}
        |- If (in combat) or (Have AgroID) AND (MA is not present) or (a corpse).
        /if ((${Me.CombatState.Equal[COMBAT]} || ${AggroTargetID}) && (!${Spawn[=${MainAssist}].ID} || ${Spawn[=${MainAssist}].Type.Equal[Corpse]})) {
            /if (${Debug}) /echo \atDEBUG GroupEscape: CombatState:${Me.CombatState.Equal[COMBAT]} AggroTargetID:${AggroTargetID} MA Dead:!${Spawn[=${MainAssist}].ID}|${Spawn[=${MainAssist}].Type.Equal[Corpse]} \agLine#: ${Macro.CurLine}
            /echo + The MA is dead and I'm in combat, activating Group Escape!
            /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
                |-- Druid AA or Spell group evac casting.
                /if (${Select[${Me.Class.ShortName},DRU]}) {
                    |- Drop Divine Barrier if it is up so we can exodus group!
                    /removebuff "Divine Barrier"
                    /if (${Me.AltAbilityReady[Exodus]}) {
                        /call CastWhat "Exodus" ${Me.ID} GroupEscape
                    } else /if (${Me.Book[Succor]}) {
                        /call CastWhat "Succor" ${Me.ID} GroupEscape
                    }
                }
                |-- Wizard AA or Spell group evac casting.
                /if (${Select[${Me.Class.ShortName},WIZ]}) {
                    /if (${Me.AltAbilityReady[Exodus]}) {
                        /call CastWhat "Exodus" ${Me.ID} GroupEscape
                    } else /if (${Me.Book[Evacuate]}) {
                        /call CastWhat "Evacuate" ${Me.ID} GroupEscape
                    }
                }                
            }            
        }
         /if (${Debug}) /echo \atDEBUG GroupEscape Leave \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: CheckHealth
| ----------------------------------------------------------------------------
    Sub CheckHealth
        /if (!${HealsOn}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${Medding} && ${MedCombat}) /return
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth Enter \agLine#: ${Macro.CurLine}
        /declare i                  int         local       0
        /declare MostHurtName       string      local
        /declare MostHurtType       string      local
        /declare MostHurtID         int         local       0
        /declare MostHurtHP         int         local       100
        /declare MostHurtNo         int         local       0
        /declare GroupHealthAvg     string      local       0
        :CheckAgain
        /varset HealAgain    0
        /varset GroupHealthAvg 0
        | Check self health
        /if (${Me.PctHPs} < ${SingleHealPoint}) /call SingleHeal "${Me}" PC ${Me.PctHPs} 0
        | Call MA health check for only those that can heal others
        /if (${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,RNG,PAL]}) {
            | This is to target Main Assist out of group if class can heal
             /if (${Select[${HealsOn},1,3]} && ${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} && ${Spawn[${MainAssist}].ID}!=${Me.Pet.ID} && ${Spawn[${MainAssist}].ID}!=${Me.ID}) {
                /if ((${SpawnCount[${MainAssist} ${MainAssistType} group]}==0 && ${MainAssistType.NotEqual[pet]}) || (${SpawnCount[${Spawn[=${MainAssist}].Master} pc group]}==0 && ${MainAssistType.Equal[pet]})) {
				
                    | Skip targeting tank if MA is defined to watch for heals in XTarget
                    /if (!${XTarHeal} || (${XTarHeal} && ${Me.XTarget[${XTarHeal}].ID}!=${Spawn[${MainAssist} ${MainAssistType}].ID}) && (${XTarHeal2} && ${Me.XTarget[${XTarHeal2}].ID}!=${Spawn[${MainAssist} ${MainAssistType}].ID})) {
                        /target id ${Spawn[${MainAssist} ${MainAssistType}].ID}
                        /delay 10 ${Target.ID}==${Spawn[${MainAssist} ${MainAssistType}].ID}
                    }
                }
                /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth:  Tank OOG: ${Spawn[${MainAssist}].PctHPs} ${SingleHealPointMA} ${Spawn[${MainAssist} ${MainAssistType}].ID}  ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} \agLine#: ${Macro.CurLine}
                |Add code to check if pet HP < needed.
                /if (${Spawn[${MainAssist} ${MainAssistType}].PctHPs} < ${SingleHealPointMA}) /call SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[${MainAssist} ${MainAssistType}].PctHPs} 6
            }
            /if (${AutoRezOn} &&  !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
           | Who is the most hurt
            /if (${Select[${HealsOn},1,2]} && ${Group} && !${JustZoned} && !${JoinedParty}) {
                /varset MostHurtName
                /varset MostHurtType
                /varset MostHurtID
                /varset MostHurtHP 100
                /varset MostHurtNo 0
                /for i 0 to 5
                    /if (${Select[${HealsOn},2]} && ${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${Spawn[${MainAssist} ${MainAssistType}].ID},${Group.Member[${i}].ID},${Group.Member[${i}].Pet.ID}]}>0) /continue
                    /if (${Group} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].PctHPs}>=1) {
                    /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth:  -- Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP} \agLine#: ${Macro.CurLine}
                        /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP}) {
                            /varset MostHurtName ${Group.Member[${i}].CleanName}
                            /varset MostHurtType ${Group.Member[${i}].Type}
                            /varset MostHurtID ${Group.Member[${i}].ID}
                            /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                            /varset MostHurtNo ${i}
                        }
                        /if (${HealGroupPetsOn} && ${Select[${Group.Member[${i}].Class.Name},cleric,wizard]}==0 && ${Group.Member[${i}].Pet.ID}>0 && ${Group.Member[${i}].Pet.PctHPs} < ${MostHurtHP}) {
                            /varset MostHurtName ${Group.Member[${i}].Pet.CleanName}
                            /varset MostHurtType Pet
                            /varset MostHurtID ${Group.Member[${i}].Pet.ID}
                            /varset MostHurtHP ${Group.Member[${i}].Pet.PctHPs}
                            /varcalc MostHurtNo ${i}+8
                        }
                    }
                :NextGMember
                /next i
                /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth: (${MostHurtHP} < ${SingleHealPoint}) /call SingleHeal "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo} \agLine#: ${Macro.CurLine}
                /if (${MostHurtHP} < ${SingleHealPoint}) /call SingleHeal "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo}
            }
        }
        | Rez tank check
        /if (${AutoRezOn} && !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
        | Group Heal Check only call for those clases that can group heal
        /if (${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) {
            /call GroupHealthCheck
            /varset GroupHealthAvg ${Macro.Return}
            /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth: Group Health Average ${GroupHealthAvg} \agLine#: ${Macro.CurLine}
            | Check for group heals
            /if (${GroupHealthAvg} < 100 && ${Group}) /call DoGroupHealStuff ${GroupHealthAvg}
        }
        | Rez tank check
        /if (${AutoRezOn} &&  !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
        | Check xtarget health if on.
        /if (${XTarHeal}) {
            /if (${Select[${Spawn[${Me.XTarget[${XTarHeal}].ID}].Type},PC,Mercenary,Pet]} && ${Me.XTarget[${XTarHeal}].ID} && ${Spawn[${Me.XTarget[${XTarHeal}].ID}].PctHPs} < ${SingleHealPoint}) {
                /call SingleHeal "${Spawn[${Me.XTarget[${XTarHeal}].ID}].CleanName}" "${Spawn[${Me.XTarget[${XTarHeal}].ID}].Type}" ${Spawn[${Me.XTarget[${XTarHeal}].ID}].PctHPs} 7
                /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth: SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[${MainAssist} ${MainAssistType}].PctHPs} 7 \agLine#: ${Macro.CurLine}
            }
        }
        /if (${XTarHeal2}) {
            /if (${Select[${Spawn[${Me.XTarget[${XTarHeal2}].ID}].Type},PC,Mercenary,Pet]} && ${Me.XTarget[${XTarHeal2}].ID} && ${Spawn[${Me.XTarget[${XTarHeal2}].ID}].PctHPs} < ${SingleHealPoint}) {
                /call SingleHeal "${Spawn[${Me.XTarget[${XTarHeal2}].ID}].CleanName}" "${Spawn[${Me.XTarget[${XTarHeal2}].ID}].Type}" ${Spawn[${Me.XTarget[${XTarHeal2}].ID}].PctHPs} 8
                /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth: SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[${MainAssist} ${MainAssistType}].PctHPs} 7 \agLine#: ${Macro.CurLine}
            }
        }
        /if (${PetOn} && ${Me.Pet.ID} && ${Me.Pet.PctHPs} < 100) /call DoPetHealStuff
        /if (${HealAgain}) /goto :CheckAgain
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth leave \agLine#: ${Macro.CurLine}
        /if (${AutoRezOn}) /call RezCheck
        /call WriteDebuffs
    /return    
|----------------------------------------------------------------------------
| SUB: Single Heals
|----------------------------------------------------------------------------
    Sub SingleHeal(SHealName, SHealType, int SHealHPs, int WhoNum)
        /if (!${HealsOn}) /return
        /if (${Me.Moving}) /return
        /if (${Me.Hovering}) /return
        /if (${Spawn[${SHealName} ${SHealType}].ID}==0 ) /return
        /if (${Select[${SHealType},PC,Pet,Mercenary]}==0) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return    
        /if (${DebugHeal}) /echo \amDEBUGHEALS SingleHeal Enter: \ayName: ${SHealName} TType: ${SHealType} Hps%: ${SHealHPs} WhoNum:${WhoNum} \agLine#: ${Macro.CurLine}
        /varset GoMByPass 1
        /doevents
        /varset GoMByPass 0
        /declare i               int     local   0
        /declare SHealSpell      string  local
        /declare SHealTag        string  local
        /declare SHealThem       int     local   ${Spawn[=${SHealName} ${SHealType}].ID}
        /declare MainAssistID    int     local   ${Spawn[=${MainAssist}].ID}
        /declare SHealRange      int     local   0
        /declare HealLoopCount   int     local   0
        /declare HealLoopTimer   timer   local   5
        | Set MA ID to 6 to keep spell durations correct
        /if (${WhoNum}!=6 && ${SHealThem}==${MainAssistID}) /varset WhoNum 6
        :NoHeal
        /if (${SHealType.Equal[corpse]} || !${Spawn[=${SHealName} ${SHealType}].ID} || ${Spawn[=${SHealName}].Type.Equal[corpse]}) /return
        /varset HealAgain 0
        /varset HealLoopCount 0
        /for i 1 to ${SingleHeal.Size}
            | If heal is null or off |0 or spell/aa/item not ready skip it
            /if (${DebugHeal}) /echo \amDEBUGHEALS SingleHeal \awSpell ${i}: ${SingleHeal[${i}]}  ${SingleHeal[${i}].Arg[1,|]}   ${SingleHeal[${i}].Arg[2,|]}   ${SingleHeal[${i}].Arg[3,|]} \agLine#: ${Macro.CurLine}
            /if (${DebugHeal}) /echo \amDEBUGHEALS SingleHeal \awSpellSkip: !${SingleHeal[${i}].Length} || ${SingleHeal[${i}].Arg[2,|].Equal[0]} \agLine#: ${Macro.CurLine}
            /if (!${SingleHeal[${i}].Length} || ${SingleHeal[${i}].Arg[2,|].Equal[0]}) /continue
            /varset SHealSpell   ${SingleHeal[${i}].Arg[1,|]}
            /varset SHealPct     ${SingleHeal[${i}].Arg[2,|]}
            /varset SHealTag     ${SingleHeal[${i}].Arg[3,|]}
            /varset SHealRange ${Spell[${SHealSpell}].Range}
            /call CastReady "${SHealSpell}" singleheal
            /varset SpellReadyL ${Macro.Return}
            /if (!${SpellReadyL}) /continue
            /if (${Spell[${SHealSpell}].TargetType.Find[Group v]}) /varset SHealRange ${Spell[${SHealSpell}].AERange}
            /if (!${SHealRange}) /varset SHealRange 100
            | New Conditional Check to Skip spell
            /if (${ConditionsOn} && ${HealsCOn} && ${If[${SHCond[${i}]},0,1]}) /continue
            | Skip Heal if pet 
            /if (${Spawn[${SHealThem}].Type.NotEqual[Pet]} && ${SHealTag.Equal[pet]}) /continue
            /if (${SHealThem}!=${MainAssistID} && (${HealGroupPetsOn} && ${SHealTag.Equal[pet]} && ${Spawn[${SHealThem}].Type.NotEqual[pet]}) || (!${HealGroupPetsOn} && ${SHealTag.Equal[pet]})) /continue
            | If tag MA/Mob and heal target not MA or tag !MA and heal target MA skip
            /if (${DebugHeal}) /echo \amDEBUGHEALS SingleHeal \awTAG: ${SHealTag.Equal[MA]} && ${SHealThem}!=${MainAssistID} || ${SHealTag.Equal[Mob]} && ${SHealThem}!=${MainAssistID} || ${SHealTag.Equal[!MA]} && ${SHealThem}==${MainAssistID} \agLine#: ${Macro.CurLine}
            /if ((${SHealTag.Equal[MA]} && ${SHealThem}!=${MainAssistID}) || (${SHealTag.Equal[Mob]} && ${SHealThem}!=${MainAssistID}) || (${SHealTag.Equal[!MA]} && ${SHealThem}==${MainAssistID})) /continue
            | Cleric Divine Arbitration and Epics do not work on pets or people out of group
            /if (${Spawn[${SHealThem}].Type.Equal[Pet]}  && (${SHealSpell.Find[Aegis of Superior Divinity]} || ${SHealSpell.Find[Harmony of the Soul]} ||  ${SHealSpell.Find[Divine Arbitration]})) /continue
            /if (!${Spawn[${SHealName} ${SHealType} group].ID} && (${SHealSpell.Find[Aegis of Superior Divinity]} || ${SHealSpell.Find[Harmony of the Soul]} ||  ${SHealSpell.Find[Divine Arbitration]})) /continue
            | intervention and survival lines only work on group members
            /if (!${Spawn[${SHealName} ${SHealType} group].ID} && ${Select[${Me.Class.Name},Druid,Shaman]} && (${SHealSpell.Find[Intervention]} || ${SHealSpell.Find[Survival]})) /continue    
            | Check For Life Taps
            /if (${SHealTag.Find[Tap]}) {
                /if (!${Pulled} && ${CombatStart} && ${Me.PctHPs}<=${SHealPct} && ${Target.Type.NotEqual[Corpse]} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance}<=${SHealRange} && ${Spell${i}GM0}==0) {
                    |/if (${Cast.Ready[${SHealSpell}]}) {
                    /call CastWhat "${SHealSpell}" ${Spawn[${MyTargetID}].ID} SingleHeal
                    |} else /continue
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} o "${SHealSpell} for  >> ${Me.CleanName} <<"
                        /varcalc Spell${i}GM0 (${Spell[${SHealSpell}].Duration.TotalSeconds}*${DurationMod})*10
                        /if (${DebugHeal}) /echo DEBUGHEALS SingleHeal Assign Timer:Spell${i}GM0 (${Spell[${SHealSpell}].Duration.TotalSeconds}*${DurationMod}) ${Spell${i}GM0} Line#: ${Macro.CurLine}
                        /return
                    } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) /return
                } else /continue
            }
            | Check For Nuke Heals - contibuted by thenomadman
            /if (${SHealTag.Find[Mob]}) {
                /if (!${AggroTargetID}) /continue
                /doevents Switch
                /if ((${DPSOn} || ${MeleeOn}) && !${MyTargetID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]}) /call Assist Heals
                /if (${MyTargetID} && ${Spawn[${MainAssist}].PctHPs}<=${SHealPct} && ${Spawn[${MyTargetID}].LineOfSight} && ${Spawn[${MyTargetID}].Distance}<=${SHealRange} && !${Spawn[${MyTargetID}].Type.Equal[Corpse]}) {
                    /varset HealAgain 2
                    |/if (${Cast.Ready[${SHealSpell}]}) {
                    /call CastWhat "${SHealSpell}" ${Spawn[${MyTargetID}].ID} SingleHeal
                    |} else /continue
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} o "${SHealSpell} for >>${Spawn[${SHealName} ${SHealType}].CleanName} << cast on ${Spawn[${MyTargetID}].CleanName}"
                        /varset HealAgain 1
                        /return
                    } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) /return
                } else /continue
            }
            | Check conditons for heals
            /if (${DebugHeal}) /echo \amDEBUGHEALS SingleHeal \aw${SHealHPs}<=${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ${Spell${i}GM${WhoNum}}==0 \agLine#: ${Macro.CurLine}
            /if (${SHealHPs}<=${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ${Spell${i}GM${WhoNum}}==0) {
                | target has qualified for a heal
                /varset HealAgain 2
                /if (${Spell[${SHealSpell}].TargetType.Equal[Free Target]}) {
                    | Check if spalsh heal target is in line of sight
                    /if (${Target.ID}!=${SHealThem}) {
                        /target id ${SHealThem}
                        /delay 2s ${Target.ID}==${SHealThem}
                    }
                    /if (!${Target.CanSplashLand}) {
                        /echo Splash Spell will NOT land on target. Skipping.
                        /continue                  
                    }
                }
                /if (${Select[${EverQuest.Server},zek]} && ${Select[${Target.Type},PC]} && ${Me.Combat}) {
                    /attack off
                    /delay 25 !${Me.Combat}
                }
                /if (${SHealThem}==${MainAssistID} && ${Spawn[${MainAssist} ${MainAssistType}].ID}) /removebuff "Divine Barrier"
                |/if (${Cast.Ready[${SHealSpell}]}) {
                /call CastWhat "${SHealSpell}" ${SHealThem} SingleHeal
                |} else {
                |    /continue
                |}
                /if (${DebugHeal}) /echo \amDEBUGHEALS SingleHeal \awMR: ${Macro.Return} \agLine#: ${Macro.CurLine}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast ${IRCOn} ${EQBCOn} o "${SHealSpell} on  >> ${Spawn[${SHealName} ${SHealType}].CleanName} <<"
                    /if (${SHealSpell.Find[Promised]}) { 
                        /varset Spell${i}GM${WhoNum} 215
                    } else {   
                        /varcalc Spell${i}GM${WhoNum} (${Spell[${SHealSpell}].Duration.TotalSeconds}*${DurationMod})*10
                    }
                    /if (${DebugHeal}) /echo DEBUGHEALS SingleHeal Assign Timer:Spell${i}GM${WhoNum} ${Spell[${SHealSpell}].Duration.TotalSeconds}*${DurationMod} ${Spell${i}GM${WhoNum}} Line#: ${Macro.CurLine}
                    | Prioritize heals by setting flag to check Health again
                    /varset HealAgain 1
                    /return
                } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) /return
            | Check if target still needs a heal. spell might not be ready or timer not zero.
            } else /if (${SHealHPs}<=${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange}) {
                /varset HealAgain 2
            }
        :SNextHeal
            /if (${DebugHeal}) /delay 2
            |/varcalc HealLoopCount ${HealLoopCount}+1
        /next i
        | if target qualified for a heal but did not recieve one due to cooldown etc try to heal again. Release after 3s
        |/if (${HealAgain}==2 && ${SingleHeal.Size}==${HealLoopCount} && ${HealLoopTimer}) /goto :NoHeal
        /if (${HealAgain}==2 && ${HealLoopTimer}) /goto :NoHeal
        /if (${DebugHeal}) {
            /echo \amDEBUGHEALS \aySingleHeal Leave \agLine#: ${Macro.CurLine}
            /delay 1
        }
        /varset HealAgain 0
    /return    
| ----------------------------------------------------------------------------
| SUB: Group Health Check
| ----------------------------------------------------------------------------
    Sub GroupHealthCheck
        /if (${DebugHeal}) /echo \amDEBUGHEALS GroupHealthCheck Enter \agLine#: ${Macro.CurLine}
        /declare j                  int     local   0
        /declare GroupHealthTl      float   local   .1
        /declare GroupHealthPct     float   local   100
        /declare NotDead            int     local   0
        /for j 0 to 5
            /if (${Group} && ${Group.Member[${j}].ID} && ${Group.Member[${j}].Type.NotEqual[corpse]}) {
                | Calculate total group health for group heal spells
                /if (${Group.Member[${j}].Present} && ${Group.Member[${j}].Distance}<100) {
                    /if (${DebugHeal}) /echo \amDEBUGHEALS GroupHealthCheck Group Health: GM:${j} Health:${Group.Member[${j}].PctHPs} \agLine#: ${Macro.CurLine}
                    /varcalc GroupHealthTl ${GroupHealthTl}+${Group.Member[${j}].PctHPs}
                    /varcalc NotDead ${NotDead}+1
                }
                /if (${HealGroupPetsOn} && ${Group.Member[${j}].Pet.ID}>0 && ${Group.Member[${j}].Pet.Distance}<100) {
                    /if (${DebugHeal}) /echo \amDEBUGHEALS GroupHealthCheck Group Pet Health: GM:${j} Health:${Group.Member[${j}].Pet.PctHPs} \agLine#: ${Macro.CurLine}
                    /varcalc GroupHealthTl ${GroupHealthTl}+${Group.Member[${j}].Pet.PctHPs}
                    /varcalc NotDead ${NotDead}+1
                }
            }
        /next j
        /if (${GroupHealthTl} && ${NotDead}) /varcalc GroupHealthPct ${GroupHealthTl}/${NotDead}
            /if (${DebugHeal}) /echo \amDEBUGHEALS GroupHealthCheck Leave ${GroupHealthPct} \agLine#: ${Macro.CurLine}
    /return ${GroupHealthPct}
| ----------------------------------------------------------------------------
| SUB: Do Group Heal Stuff
| ----------------------------------------------------------------------------
    Sub DoGroupHealStuff(int GroupHealth)
        /if (${DebugHeal}) /echo \amDEBUGHEALS DoGroupHealStuff Enter ${GroupHealth} \agLine#: ${Macro.CurLine}
        /doevents
        /declare j              int     local
        /declare HealSpell      string  local
        /declare HealPct        string  local
        /for j 1 to ${GroupHeal.Size}
            /if (!${Heals[${j}].Length} || ${Heals[${j}].Arg[2,|].Equal[0]}) /return
            /varset HealSpell   ${GroupHeal[${j}].Arg[1,|]}
            /varset HealPct     ${GroupHeal[${j}].Arg[2,|]}
            /if (${DebugHeal}) /echo \amDEBUGHEALS DoGroupHealStuff ${HealSpell} ${HealPct} \agLine#: ${Macro.CurLine}
            /if (${DebugHeal}) /echo \amDEBUGHEALS DoGroupHealStuff Group Heal Spell/Item:${Spell[${HealSpell}].TargetType.Find[group v]}/${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} Spell:${HealSpell} GpAvg:${GroupHealth} HealAt:${HealPct} Timer:${SpellGH${j}}==0 \agLine#: ${Macro.CurLine}
            /if (!${ConditionsOn} || !${HealsCOn} || ${If[${GHCond[${j}]},1,0]}) {
                /if (${GroupHealth}<=${HealPct} && ${SpellGH${j}}==0 && ${Group}) {
                    /call CastWhat "${HealSpell}" ${Me.ID} GroupHeal
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /if (${DebugHeal}) /echo \amDEBUGHEALS DoGroupHealStuff ${HealSpell} on  >> Group << \agLine#: ${Macro.CurLine}
                        /call BroadCast ${IRCOn} ${EQBCOn} o "${HealSpell} on  >> Group <<"
                        /varcalc SpellGH${j} (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod})*10
                        /if (${DebugHeal}) /echo DEBUGHEALS DoGroupHealStuff Assign Timer:SpellGH${j} (${Spell[${HealSpell}].Duration}*${DurationMod}.TotalSeconds) ${SpellGH${j}} Line#: ${Macro.CurLine}
                        /varset HealAgain    1
                        /return
                    }
                }
            }
        /next j
        /if (${DebugHeal}) /echo \amDEBUGHEALS DoGroupHealStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: DoPetHealStuff
| -------------------------------------------------------------------------------------
    Sub DoPetHealStuff
        | Check if my pet needs healing
        /if (!${Me.Pet.ID}) /return
        /if (${DebugHeal}) /echo \amDEBUGHEALS DoPetHealStuff Enter \agLine#: ${Macro.CurLine}
        /declare j int local
        /for j 1 to ${SingleHeal.Size}
            /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /continue
            /if (${Me.Pet.PctHPs}<=${SingleHeal[${j}].Arg[2,|]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) {
               /if (${DebugHeal}) /echo \amDEBUGHEALS DoPetHealStuff (${Me.Pet.PctHPs}<=${SingleHeal[${j}].Arg[2,|]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) \agLine#: ${Macro.CurLine}
               /call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Heal
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast ${IRCOn} ${EQBCOn} o "${SingleHeal[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} <<"
                    /varcalc PetHealTimer${j} (${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration.TotalSeconds}*${DurationMod})*10
                    /varset HealAgain    1
                }
            }
            |:NextPetHeal
        /next j
        /if (${DebugHeal}) /echo \amDEBUGHEALS DoPetHealStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Rez Check
| -------------------------------------------------------------------------------------
    Sub RezCheck
        | Don't rez if AutoRezOn=0.  AutoRezOn=1 dmzone not instanced like pok, hovering, invis and no aggro, AutoRezOn=2 and aggro(rez after combat setting)
        /if (!${AutoRezOn}) /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Me.Hovering}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${AutoRezOn}==2 && ${AggroTargetID}) /return
        /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare CorpseCount int local
        /declare RezMeID int local 
        /declare RezID int local
        /declare RezRadius int local 150
        | Do I have a Corpse
        /varset RezMeID ${Spawn[corpse ${Me} radius ${RezRadius} zradius 50].ID}
        /if (${RezMeID}) {
            /if (!${Defined[OOCRezTimer${RezMeID}]}) /declare OOCRezTimer${RezMeID} timer outer 0
            /if (${OOCRezTimer${RezMeID}}==0 && ${Cast.Ready[${AutoRezWith}]}) {
                /target id ${RezMeID}
                /delay 10 ${Target.ID}
                /if (${Target.Distance}>${CampRadius}) /corpse
                /delay 10
                /call  CastWhat "${AutoRezWith}" ${Target.ID}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /varset OOCRezTimer${RezMeID} 3m
                    /if (${SpawnCount[corpse ${Me} radius ${RezRadius} zradius 50]}==0 && ${MountOn} && !${Me.Mount.ID} && ${Me.CombatState.NotEqual[COMBAT]} && ${Zone.Outdoor}) /call CastMount
                }
            }
        }
        | Does Group Member have a corpse?
        /for i 1 to 5
            /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck ${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} corpse].Distance}<${RezRadius} ${Spawn[${Group.Member[${i}].CleanName} corpse].Deity.ID}  || !${Cast.Ready[${AutoRezWith}]} \agLine#: ${Macro.CurLine}
            /if (!${Spawn[${Group.Member[${i}].CleanName} pccorpse].ID}  || !${Cast.Ready[${AutoRezWith}]} || (${AutoRezWith.Find[Call of]} && ${Group.Member[${i}].OtherZone}==FALSE)) /continue
            | Check for group member corpses and battle rez
            /if (${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} corpse].Distance}<${RezRadius}) {
                /squelch /tar id ${Spawn[${Group.Member[${i}].CleanName} corpse].ID}
                /delay 10 ${Target.ID}
                /if (${Target.Distance}<100) {
                    /if (${Target.Distance}>${CampRadius} && !${Target.CleanName.Find[${MainAssist}]}) /corpse
                    /delay 10
                    /call CastWhat "${AutoRezWith}" ${Target.ID}
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} o "BATTLE REZZED =>> ${Group.Member[${i}]} <<="
                        /varset BattleRezTimer${i} 3m
                        /squelch /target clear
                        /if (${AutoRezWith.Find[Call of]}) /varset BattleRezTimer${i} 6m
                    } else {
                        /if (${Group.Member[${i}].Name.NotEqual[${MainAssist}]}) /varset BattleRezTimer${i} 1m
                    }
                }
            }
            |:NextChar
        /next i
        | Out of Combat Rez | 
        /varset CorpseCount ${SpawnCount[corpse radius ${RezRadius} zradius 50]}
        /if (${CorpseCount}>0 && !${CombatStart}) {
            /for j 1 to ${CorpseCount}
                /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
                /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
                    /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                    /if (${OOCRezTimer${RezID}}==0 && ${Cast.Ready[${AutoRezWith}]} && (${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} || ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID} || (${XTarHeal} && ${Spawn[${RezID}].ID}==${Me.XTarget[${XTarHeal}].ID}))) {
                        | If call of wild and toon in zone skip
                        /if (${AutoRezWith.Find[Call of]} && ${Spawn[pc ${Spawn[${RezID}].CleanName.Left[-9]} ].ID}) /continue
                        /target id ${RezID}
                        /delay 10 ${Target.ID}==${RezID}
                        /if (${Target.Distance}<=${RezRadius}) {
                            /call  CastWhat "${AutoRezWith}" ${Target.ID}
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /call BroadCast ${IRCOn} ${EQBCOn} o "Rezzing =>> ${Target.CleanName} <<="
                                /varset OOCRezTimer${RezID} 5m
                                /delay 30 !${Me.Casting.ID}
                                /squelch /target clear
                            }
                        }
                    }
                }
            |:NextCorpse
            /next j
        }
        /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Loot Stuff
| -------------------------------------------------------------------------------------
    Sub LootStuff
        /if (!${LootOn} || (!${Me.UseAdvancedLooting} && ${AggroTargetID}) || (${MainAssist.Equal[${Me}]} && ${AggroTargetID}) || (${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Invis}) /return
        /if (${Debug}) /echo \atDEBUG LootStuff: Enter \agLine#: ${Macro.CurLine}
        /if (${Me.FreeInventory}==0) {
            /echo Inventory is full. Looting OFF
            /varset LootOn 0
            /return
        }
        /doevents
        /if (${Me.UseAdvancedLooting}) {
            /call UseAdvLoot
        } else {
            /call LootMobs
        }
        /call DoWeMove 0 lootstuff
        /if (${Debug}) /echo \atDEBUG LootStuff: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
|   Sub MobRadar
| -------------------------------------------------------------------------------------
    Sub MobRadar(int CountRadius,string calledfrom)
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        /if (${Debug}) /echo \atDEBUG MobRadar ${CountRadius} Enter (${calledfrom}) \agLine#: ${Macro.CurLine}
        /declare NMob int local
        /declare i int local
        /varset MobCount ${SpawnCount[npc targetable los radius ${CountRadius} zradius 50 noalert 3]}
        /for i 1 to ${MobCount}
            /varset NMob ${NearestSpawn[${i},npc targetable los radius ${CountRadius} zradius 50 noalert 3].ID}
            /if (${i}>13) /break
            /if (${NMob} && (${Spawn[${NMob}].Type.Equal[Corpse]} || !${Spawn[${NMob}].ID})) /call RemoveFromArray AddsArray ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}
            /if (${MobCount}>0 && ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}==0) /call AddToArray AddsArray ${NMob}
            |:ArrayExceed
       /next i
        | Check if NPC Pet is on Xtarget
        /if (!${MobCount} && ${Me.XTarget[${XTSlot}].ID}) {
            /if (${Debug}) /echo \atDEBUG MobRadar MobCount=0 but Mob on Xtarget Setting Mobcount to 1 \agLine#: ${Macro.CurLine}
            /varset MobCount 1  
        }    
        /if (${Debug}) /echo \atDEBUG MobRadar Leave ${MobCount} \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
|   Sub MezRadar
| -------------------------------------------------------------------------------------
    Sub MezRadar
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        /if (${DebugMez}) /echo \atDEBUG MezRadar Enter \agLine#: ${Macro.CurLine}
        /declare NMMob int local 0
        /declare i int local
        /varset MezMobCount 0
        /varset MezMobAECount 0
        /varset MezAEClosest 0
        /for i 1 to 13
            /if (${DebugMez}) /echo \atDEBUG MezRadar:  ${i} ${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.Equal[NPC]} \agLine#: ${Macro.CurLine}
            /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.Equal[NPC]}) {
                /varset NMMob ${Me.XTarget[${i}].ID}
                /varcalc MezMobCount ${MezMobCount}+1 
                | Setup closest mob for AE mez target necros can't aemez
                /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
                    /if (!${MezAEClosest} && ${Spawn[${NMMob}].Distance}<=${MezRadius}) /varset MezAEClosest ${NMMob}
                    /if (${MezAEClosest} && ${Spawn[${NMMob}].Distance}<${Spawn[${MezAEClosest}].Distance} && ${Spawn[${NMMob}].Distance}<=${MezRadius}) /varset MezAEClosest ${NMMob}
                    /if (${Spawn[${NMMob}].Distance}<=${MezRadius}) /varcalc MezMobAECount ${MezMobAECount}+1 
                }
                /if (${DebugMez}) /echo \atDEBUG MezRadar: MezMobCount ${MezMobCount} ${NMMob} \agLine#: ${Macro.CurLine}
                /if (${NMMob} && (${Spawn[${NMMob}].Type.Equal[Corpse]} || !${Spawn[${NMMob}].ID} || ${Spawn[${NMMob}].Distance}>${MezRadius})) /call RemoveFromArray MezArray ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}
                /if (${MezMobCount}>0 && ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}==0) {
                    /if (${DebugMez}) /echo \atDEBUG MezRadar: ADDING -> Name: ${Spawn[${NMMob}].Name} ID: ${NMMob} to mezlist \agLine#: ${Macro.CurLine}
                    /call AddToArray MezArray ${NMMob} 
                }
                /varset NMMob 0
            }
        /next i
        /if (${DebugMez}) /delay 5
       /if (${DebugMez}) /echo \atDEBUG MezRadar: MezMobCount: ${MezMobCount} Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Add to Array
| -------------------------------------------------------------------------------------
    Sub AddToArray(ArrayName, int AddMobID)
    /if (!${AddMobID}) /return
        /if (${Debug}) /echo \atDEBUG AddToArray ${AddMobID} Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /for i 1 to 13
            /if (${${ArrayName}[${i},1].Equal[NULL]}) {
                /varset ${ArrayName}[${i},1] ${Spawn[${AddMobID}].ID}
                /varset ${ArrayName}[${i},2] ${Spawn[${AddMobID}].Level}
                /varset ${ArrayName}[${i},3] ${Spawn[${AddMobID}].CleanName}
                /if (${Debug}) /echo ARRAY Assign >> ${${ArrayName}[${i},3]} << to ${ArrayName}${i}. \agLine#: ${Macro.CurLine}
                /return
            }
        /next i
        /if (${Debug}) /echo \atDEBUG AddToArray Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Remove From Array
| -------------------------------------------------------------------------------------
    Sub RemoveFromArray(RArrayName, int ArNum)
        /if (${${RArrayName}[${ArNum},1].Equal[NULL]}) /return
        /if (${ArNum}<1 || ${ArNum}>${${RArrayName}.Size}) /return
        /if (${Debug}) /echo \atDEBUG RemoveFromArray ${ArNum} Enter \agLine#: ${Macro.CurLine}
        /if (${Debug}) /echo \atDEBUG ARRAY Remove >> ${${RArrayName}[${ArNum},3]} << from ${RArrayName}${ArNum}. \agLine#: ${Macro.CurLine}
        /varset ${RArrayName}[${ArNum},1] NULL
        /varset ${RArrayName}[${ArNum},2] NULL
        /varset ${RArrayName}[${ArNum},3] NULL
        /if (${MezOn} && ${ArNum}<=13) {
            /varset MezCount[${ArNum}] 0
            /varset MezTimer${ArNum} 0
        }
        /if (${Debug}) /echo \atDEBUG RemoveFromArray Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Do Mez Stuff
| -------------------------------------------------------------------------------------
    Sub DoMezStuff(string SentFrom)
        /doevents 
        /if (!${MezOn}) /return
        /if (${Me.Hovering}) /return
        /if (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]}) /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${DebugMez}) /echo \atDEBUGMEZ DoMezStuff: Enter ${SentFrom} \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare j int local 0
        /declare skipFlag int local 0
        | Reset skip mez on health setting if tank dies to 1%
        /if (!${Spawn[=${MainAssist}].ID}) /varset MezStopHPs 1
        /call MezRadar
        /if (${DebugMez}) /echo DoMezStuff MezMobCount ${MezMobCount} \agLine#: ${Macro.CurLine}
        /if (${MezMobCount}<2 && ${Spawn[=${MainAssist}].ID}) {
            /if (${DebugMez}) /echo MezMobCount was ${MezMobCount} (so less than 2) & ${MainAssist} is alive so we return \agLine#: ${Macro.CurLine}
            /return
        }
        | Necros can't AE mez. But you don't need to check it twice.
        /if (${Select[${MezOn},1,2,3]} && ${MezAECount}>0 && ${MezMobAECount}>=${MezAECount} && ${MezAETimer}==0 && ${Select[${Me.Class.ShortName},BRD,ENC]})  {
            /if (${DebugMez}) /echo I'm about to AEMez \agLine#: ${Macro.CurLine}
            /if (${SpawnCount[npc xtarhater loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]}>=${SpawnCount[npc loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]})  /call MezMobsAE ${MezAEClosest}
        }
        /for i 1 to 13
            /varset skipFlag 0
            | Every Mez test conditon is listed seperately for clarity
            /if (${DebugMez}) /echo we are in the mezcondition loop i is: ${i} \agLine#: ${Macro.CurLine}
            | Test -> Is my single mez spell ready
            /if (!${Me.SpellReady[${MezSpell}]} && !${IAmABard}) {
                /if (${MezOn}!=2) {
                    /if (${DebugMez}) /echo ${MezSpell} not ready, goto return \agLine#: ${Macro.CurLine}
                    /return
                }
                /while (!${Me.SpellReady[${MezSpell}]}) {
                    /delay 2
                }
            }
            | Test -> array not empty,
            /if (${MezArray[${i},1].Equal[NULL]}) {
                /if (${DebugMez}) /echo ${i}  MezArray[${i},1] was equal to NULL, goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            | Test -> Target is dead
            /if (${MezArray[${i},3].Find[corpse]} ||  !${Spawn[${MezArray[${i},1]}].ID}) {
                /if (${DebugMez}) /echo ${i}  ${MezArray[${i},3]} is dead, goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            | Is mob in MezRadius distance
            /if (${Spawn[${MezArray[${i},1]}].Distance}>=${MezRadius}) {
                /if (${DebugMez}) /echo ${i}  Mob distance is greater than MezRadius: ${Spawn[${MezArray[${i},1]}].Distance} ${MezRadius} goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            | Test -> is target MA's current Target
            /if (${Spawn[${MezArray[${i},1]}].ID}==${MyTargetID} && ${Spawn[=${MainAssist}].ID}) {
                /if (${DebugMez}) /echo ${Spawn[${MezArray[${i},1]}].Name} had the same ID(${Spawn[${MezArray[${i},1]}].ID}) as MyTargetID(${MyTargetID}) & ${MainAssist}(${Spawn[=${MainAssist}].ID}), goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            | Test -> is  MA's a merc skip 1st target so he attackes it.
            /if (${AggroTargetID} && !${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) {
                /if (${DebugMez}) /echo AggroTargetID = ${AggroTargetID}  MyTargetID = ${MyTargetID} & Spawn[=MainAssist].ID = ${Spawn[=${MainAssist}].ID} & Spawn[=MainAssist].Type.Equal[Mercenary] was true, goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> is taget above mez hps threshold
            /if (${Spawn[${MezArray[${i},1]}].PctHPs}<${MezStopHPs}) {
                /if (${DebugMez}) /echo Spawn[MezArray[${i},1]].PctHPs(${Spawn[${MezArray[${i},1]}].PctHPs}) was less than MezStopHPs(${MezStopHPs}), goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> is target within levels defined in ini file
            /if (${MezArray[${i},2]}>${MezMaxLevel} || ${MezArray[${i},2]}<${MezMinLevel}) {
                /if (${DebugMez}) /echo MezArray[${i},2](${MezArray[${i},2]}) was greater than MezMaxLevel(${MezMaxLevel}) OR less than MezMinLevel(${MezMinLevel}), goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> is the target in line of sight
            /if (!${Spawn[${MezArray[${i},1]}].LineOfSight}) {
                /if (${DebugMez}) /echo I dont have LineOfSight to Spawn[MezArray[${i},1]](${Spawn[${MezArray[${i},1]}].Name} ID:${Spawn[${MezArray[${i},1]}].ID}), goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> I am a bard and if the player is dumb enough to have me tank then don't mez.
            /if (${IAmABard} && ${MainAssist.Equal[${Me}]} && ${MyTargetID} && ${AggroTargetID} && ${MezArray[${i},1].Equal[${MyTargetID}]}) {
                /if (${DebugMez}) /echo im a bard and stuff, goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> is target a giant unmezzable
            /if (${Spawn[${MezArray[${i},1]}].Body.Name.Equal[Giant]}) {
                /if (${DebugMez}) /echo Spawn[MezArray[${i},1]] (${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]}) is a giant, goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
             | Test -> is target on my mez immune list
            /if (${Alert[4].Size}) {
                /for j 0 to ${Alert[4].Size}
                    /if (${Alert[4].List[${j}].Name.Equal[${MezArray[${i},3]}]} && ${Alert[4].List[${j}].Name.Length}) {
                        /if (${MMTimer${i}}==0) /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Immune Detected -> ${MezArray[${i},3]} <- ID:${MezArray[${i},1]}"
                        /varset MMTimer${i} 1m
                        /if (${DebugMez}) /echo ${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]} is immune, goto :SkipMez \agLine#: ${Macro.CurLine}
                        /varset skipFlag 1
                        /break
                    }
                /next j
                /if (${skipFlag}) /continue
            }
            | Test -> Do i have enough mana to cast the spell 
            /if (${Me.CurrentMana}<${Spell[${MezSpell}].Mana}) {
                /if (${DebugMez}) /echo i didnt have enough mana to cast ${MezSpell}, goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            | Test -> Do i have a mez timer on the mob?
            /if (${MezTimer${i}} > 0) {
                /if (${DebugMez}) /echo MezTimer${i}(${MezTimer${i}}) was greater than 0 , goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            | Stop mezzing last mob because pets and mercs won't attack it.
            /if (${MezMobCount}<=1 && ${Spawn[=${MainAssist}].ID} && (${Spawn[=${MainAssist}].Type.Equal[Mercenary]} || ${Spawn[=${MainAssist}].Type.Equal[Pet]})) {
                /if (${DebugMez}) /echo MezMobCount(${MezMobCount}) was less or equal to 1 & ( MainAssist(${MainAssist}) was a Mercenary OR a Pet ), goto :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            /if (${Spawn[${MainAssist} ${MainAssistType} group].ID} && ${Select[${MezArray[${i},1]},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]}==0) {
                /if (${DebugMez}) /echo If tank is alive and mob not on xtarget go to :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            /if (${MezImmuneIDs.Find[|${MezArray[${i},1]}]}) {
                /if (${DebugMez}) /echo Mez Immune Mob Detected: ${MezArray[${i},3]} go to :SkipMez \agLine#: ${Macro.CurLine}
                /continue
            }
            /if (${DebugMez}) /echo \atDEBUGMEZ MezTimer${i} ${MezTimer${i}} ${Spawn[${MezArray[${i},1]}].ID} ${i} \agLine#: ${Macro.CurLine}
            /if (${Select[${MezOn},1,2]}) {
                /if (${DebugMez}) /echo im gonna singlemez ${MezArray[${i},1]} \agLine#: ${Macro.CurLine}
                /call MezMobs ${MezArray[${i},1]} ${i}
            }
            :SkipMez
        /next i
        /if (${DebugMez}) /echo \atDEBUGMEZ DoMezStuff: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs AE
| -------------------------------------------------------------------------------------
    Sub MezMobsAE(int AEMezID)
        | Bard AE mez code
        /declare i int local 1
        /declare WasChasing int local 0
        /if (${IAmABard}) {
            /squelch /twist once ${Me.Gem[${MezAESpell}]}
            /call BroadCast ${IRCOn} ${EQBCOn} g "MEZZING-> AE Mezzing Now - ${MezAESpell} "
            /delay 35
            /varset MezAETimer 300
        }
        | Enchanter AE mez code
        /if (${Me.Class.Name.Equal[Enchanter]}) {
            /if (${ChaseAssist}) {
                /varset ChaseAssist 0
                /varset WasChasing 1
                /squelch /stick off
                /moveto off
                /if (${PullMoveUse.Equal[nav]} && ${Navigation.Active}) /nav stop
                /delay 30 !${Me.Moving}
            }
            /echo I AM AE MEZZING ${MezAESpell}
            /call CastWhat "${MezAESpell}" ${AEMezID} Mez
            /echo I JUST CAST AE MEZ ${MezAESpell}
            /delay 10 ${Me.SpellReady[${MezAESpell}]}
            /varset MezAETimer ${Spell[${MezAESpell}].Duration.TotalSeconds}s
            /if (${DebugMez}) /echo \atDEBUGMEZ TIMER SET ${MezAETimer} \agLine#: ${Macro.CurLine}
            /call BroadCast ${IRCOn} ${EQBCOn} g "AE MEZZING-> ${MezAESpell} "
            /if (${WasChasing}) /varset ChaseAssist 1
        }
        | Reset all mez timers to 0 after AE Mez
        /for i 1 to 30
            /varset MezTimer${i} 0
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs
| -------------------------------------------------------------------------------------
    Sub MezMobs(int MobID, int TimerNum)
        /if (${DebugMez}) /echo \atDEBUGMEZ MezMobs Enter MobID:${MobID} Timer#:${TimerNum} \agLine#: ${Macro.CurLine}
        /declare MezFail int local 0
        /declare MezTry int local 1
        /declare ReMez int local 0
        /if (${Me.Combat}) {
                /attack off
                /delay 25 !${Me.Combat}
        }
        /squelch /target id ${MobID}
        /delay 20 ${Target.ID}==${MobID} && ${Target.BuffsPopulated}==TRUE
        /if (${Target.ID}==${MobID}) {
            /if (${Int[${Target.Mezzed.ID}]} && ${Target.Mezzed.Name.Equal[${MezSpell}]}) {
                /if (${DebugMez}) /echo DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} Target Info: ${Target.Mezzed.ID} ${Target.Mezzed.Name} ${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds} Line#: ${Macro.CurLine}
                /if (${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds}>${Math.Calc[(${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*.10]}) {
                    /varcalc MezCount[${TimerNum}] 1
                    /varcalc MezTimer${TimerNum} (${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds}*10)*.85
                    /return
                }            
            }
            /if (${MezCount[${TimerNum}]}<1) {
                /call BroadCast ${IRCOn} ${EQBCOn} g "MEZZING-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
            } else {
                /call BroadCast ${IRCOn} ${EQBCOn} g "ReMEZZING-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                /varset ReMez 1
            }
            | Chanter mez code
            :retrymez
            /if (${Me.Class.Name.Equal[Enchanter]}) {
                /call CastWhat "${MezSpell}" ${MobID} Mez
                /varcalc MezFail ${MezFail}+1
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /if (!${ReMez})  /call BroadCast ${IRCOn} ${EQBCOn} g "JUST MEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                    /if (${ReMez})  /call BroadCast ${IRCOn} ${EQBCOn} g "JUST REMEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                    /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                    /varcalc MezTimer${TimerNum} ((${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*10)*.90
                    /if (${DebugMez}) /echo DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} Line#: ${Macro.CurLine}
                }
                /if (${Macro.Return.Equal[CAST_RESIST]} && ${MezFail}<2) {
                    /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                    /goto :retrymez
                }
                /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                    /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                }
            }
            | Bard mez code
            /if (${IAmABard}) {
                /squelch /twist once ${Me.Gem[${MezSpell}]}
                /delay 35
                /squelch /target clear
                /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                /varset MezTimer${TimerNum} 110
            }
            | Necro mez code
            /if (${Me.Class.Name.Equal[Necromancer]}) {
                /call CastWhat "${MezSpell}" ${MobID} Mez
                |/call CheckCasting 50
                /varcalc MezFail ${MezFail}+1
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                    /varcalc MezTimer${TimerNum} ((${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*10)*.95
                    /if (${DebugMez}) /echo MezTimer${TimerNum} ${MezTimer${TimerNum}} Line#: ${Macro.CurLine}
                    | Necro flag to release from mez loop since spell has 6 sec refresh.
                }
                /if (${Macro.Return.Equal[CAST_RESIST]} && ${MezFail}<2) {
                    /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                    /goto :retrymez
                }
                /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                    /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                }
            }
            /varset MezTry 0
        }
        /if (${DebugMez}) /echo \atDEBUGMEZ MezMobs Leave \agLine#: ${Macro.CurLine}
    /return 
| -------------------------------------------------------------------------------------
| SUB: Do Debuff Stuff
| -------------------------------------------------------------------------------------
    Sub DoDebuffStuff(int FirstMobID)
        /doevents
        /if (!${DebuffAllOn} || !${DebuffCount} || ${Window[RespawnWnd].Open} || (${DMZ} && ${Me.InInstance}==FALSE) || (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]})) /return
        /if (${DPSPaused}) {
            /if (${DebugCombat}) /echo DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
            /return
        }
        /if (${DebugCombat}) /echo \atDEBUGDEBUFF DoDebuffStuff: Enter \agLine#: ${Macro.CurLine}
        /declare i               int      local 0
        /declare j               int      local 0
        /declare k               int      local 0
        /declare DebuffTargetID  int      local 0
        /declare DebuffText      string   local
        /if (${IAmABard} && ${MainAssist.Equal[${Me}]} && ${MyTargetID} && ${AggroTargetID}) {
            /if (${DebugCombat}) /echo im a bard and stuff so im getting out of here. Returning \agLine#: ${Macro.CurLine}
            /return
        }
        /call MobRadar ${MeleeDistance} DoDebuffStuff
        /for i 1 to ${DebuffCount}
            /if (${DBOList${i}.Length}) {
                /varset k 1
                /if (!${DBOTimer${i}}) {
                    | Reset the list with only the current DPS mob ID. So you won't try and debuff the mob again.
                    /varset DBOList${i} |${MyTargetID}
                } else {
                    |Remove mobs from list that are dead or over 200 units away.
                    /while (${DBOList${i}.Arg[${k},|].Length}) {
                        /if (!${Spawn[${DBOList${i}.Arg[${k},|]}].ID} || ${Spawn[${DBOList${i}.Arg[${k},|]}].Distance}>200 || ${Spawn[${DBOList${i}.Arg[${k},|]}].Type.Equal[Corpse]}) {
                            /varset DBOList${i} ${DBOList${i}.Replace[|${DBOList${i}.Arg[${k},|]},]}
                        } else {
                            /varcalc k ${k}+1
                        }
                    }
                }
            }
        /next i
        | For Mobs
        /if (${DebugCombat}) /echo MobCount was ${MobCount} MainAssist: ${MainAssist} FirstMobID: ${FirstMobID} MyTargetID: ${MyTargetID} \agLine#: ${Macro.CurLine}
        /call DebuffCast "${FirstMobID}" 1
        /for j 1 to 13
            |--- only call code for GroupEscape kick off.
            /varset DebuffTargetID ${MyTargetID}
            /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
            /if (${DPSPaused}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
                /return
            }
            /if (!${Me.XTarget[${j}].ID} || (${Me.XTarget[${j}].ID}==${FirstMobID})) /continue
            | Every Debuff test conditon is listed seperately because Maskoi forgets why he does anything.
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: we are in the debuffcondition loop j is: ${j} \agLine#: ${Macro.CurLine}
            | Is Xtarget type not of type auto hater
            /if (${Me.XTarget[${j}].TargetType.NotEqual[Auto Hater]} || ${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[Corpse]}) {
                /if (${DebugCombat}) /echo XTarget Type: ${Me.XTarget[${j}].TargetType} Spawn Type: ${Spawn[${Me.XTarget[${j}].ID}].Type}  \agLine#: ${Macro.CurLine}
                /continue
            }
            | Is mob in spell Radius distance
            /if (${Spawn[${Me.XTarget[${j}].ID}].Distance}>=${MeleeDistance}) {
                /if (${DebugMez}) /echo \atDEBUGCOMBAT DoDebuffStuff: ${j}  Mob distance is greater than MeleeDistance: ${Spawn[${Me.XTarget[${j}].ID}].Distance}  \agLine#: ${Macro.CurLine}
                /continue
            }
            | Test -> is the target in line of sight
            /if (!${Spawn[${Me.XTarget[${j}].ID}].LineOfSight}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: I dont have LineOfSight to Spawn[${Me.XTarget[${j}].ID}] ${Spawn[${Me.XTarget[${j}].ID}].Name} so im going to Skip Mob \agLine#: ${Macro.CurLine}
                /continue
            }
            /varset DebuffTargetID ${Me.XTarget[${j}].ID}
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff Target: ${DebuffTargetID}=${Target.ID} DebuffAllOn: ${DebuffAllOn} J: ${j} \agLine#: ${Macro.CurLine}
            /if (${Me.Combat} && (${MainAssist.NotEqual[${Me}]} || ${DebuffTargetID}!=${Target.ID})) {
                /attack off
                /delay 10 !${Me.Combat}
            }
            | ****************  For Spells  *****************************
            /if (${DebuffAllOn}==2) {
                /call DebuffCast "${DebuffTargetID}" 1 
            } else {
                /call DebuffCast "${DebuffTargetID}" 0
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff 4.0 \agLine#: ${Macro.CurLine}
            | Reset values if 3rd value in dps for All
            | ************ Next Mob ***************
        /next j
        /varset DebuffTargetID ${MyTargetID}
        /if (${Target.ID}!=${MyTargetID}) {
            /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]}) {
                /target id ${MyTargetID}
                /delay 1s ${Target.ID}==${MyTargetID}
            }
        }
        /if (${DebugCombat}) /echo \atDEBUGDEBUFF DoDebuffStuff: Leave \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------
| SUB: DebuffCast
| -------------------------------------------------------------------------------------
    Sub DebuffCast(int DebuffTargetID, int FWait)
        /declare c               int      local 0
        /declare f               int      local 0
        /declare f1              int      local 0
        /declare g               int      local 0
        /declare i               int      local 0
        /declare DebuffText      string   local
        /declare TempTimer       timer    local 0
        /declare Tag1            string   local
        /declare Tag2            string   local 
        /declare echoTimer       timer    local 0
        | ****************  For Spells  *****************************
        /if (${DebugCombat}) /echo DebuffCast Enter. \agLine#: ${Macro.CurLine}
        | g  - is control variable for remaining in loop while checking for mobs to debuff and spell is ready to cast.
        | c  - is to tell if the current mob is NOT on the Debuffed List or the debufftimer has runout. c=1 mob needs debuff, c=0 Mob can be skipped
        | f  - is a flag that is changed if we find a mob to debuff, but the current Spell or AA is not ready for casting, f=1 Spells/AA's were ready, f=0 Spell/AA not ready.
        | i  - is the index of the debuff to cast.
        | !${c} This mob has all debuffs, !${f} There is a debuff that was not ready for this mob.
        /while (1) {
            /varset TempTimer 70
            /varset g 1
            /while (${g} && ${TempTimer}) {
                /varset c 0
                /varset f 1
                /if (${i}==${DebuffCount}) /varset i 0
                /while (${f} && ${i}<${DebuffCount}) {
                    /varset f1 0
                    /varcalc i ${i}+1
                    /varset DebuffText ${DPS[${i}].Arg[1,|]}
                    /if (${DebugCombat}) /echo ${DebuffText} ${DPS[${i}].Length} ${DebuffText.NotEqual[null]} ${DBOList${i}.Find[|${DebuffTargetID}]} ${DBOTimer${i}} ${i} ${DebuffCount} ${TempTimer} \agLine#: ${Macro.CurLine}                 
                    |If mob not on list or debuff timer expired then increment counter of mobs needing debuff.
                    /if (${DPS[${i}].Length} && ${DebuffText.NotEqual[null]} && (!${DBOList${i}.Find[|${DebuffTargetID}]} || ${DBOTimer${i}}==0)) {
                        /varset c 1
                        | is spell or AA ready to cast? If ready set flag to drop out of loop.
                        /if (${Select[TRUE,${Me.SpellReady[${DebuffText}]},${Me.AltAbilityReady[${DebuffText}]},${Me.ItemReady[=${DebuffText}]}]}) {
                            /varset f 0
                        } else {
                            /if (${FWait} && !${echoTimer}) {
                                /varset f1 ${Select[TRUE,${Bool[${Me.Book[${DebuffText}]}]},${Bool[${Me.AltAbility[${DebuffText}]}]},${Bool[${FindItem[=${DebuffText}].ID}]}]}
                                | This is a spell.
                                /if (${f1}==1) {
                                    /if (${Me.SpellInCooldown}) {
                                        /if (${Int[${Me.Gem[${DebuffText}]}]}) {
                                            /if (!${Me.GemTimer[${DebuffText}]}) {
                                                /echo Waiting on Spell Global Cool Down To Cast ${DebuffText}
                                                /varset echoTimer 3s
                                            }
                                        }
                                    } else /if (${Int[${Me.Gem[${DebuffText}]}]} && ${Me.GemTimer[${DebuffText}]}) {
                                        /echo Waiting on Spell: ${DebuffText} to Refresh. Time Remaining: ${Me.GemTimer[${DebuffText}].TotalSeconds} Seconds.
                                        /varset echoTimer ${Me.GemTimer[${DebuffText}]}
                                    }
                                    | This is an AltAbility
                                } else /if (${f1}==2) {
                                    /if (${Math.Calc[${Me.AltAbilityTimer[${DebuffText}].TotalSeconds}*10]}<=${TempTimer}) {
                                        /echo Waiting on AltAbility To Cast ${DebuffText}
                                        /varset echoTimer 3s
                                    } else {
                                        /echo Skipping AltAbility. Wait time is to long for ${DebuffText}
                                        /if (${DBOTimer${i}}==0) /varcalc DBOTimer${i} ${Me.AltAbilityTimer[${DebuffText}].TotalSeconds}*10
                                    }
                                    | This is an Item
                                } else /if (${f1}==3) {
                                    /if (${Math.Calc[${FindItem[=${DebuffText}].TimerReady}*10]}<=${TempTimer}) {
                                        /echo Waiting on Item To Cast ${DebuffText}
                                        /varset echoTimer 3s
                                    } else {
                                        /echo Skipping Item. Wait time is to long for ${DebuffText}
                                        /if (${DBOTimer${i}}==0) /varcalc DBOTimer${i} ${FindItem[=${DebuffText}].TimerReady}*10
                                    }                          
                                }
                            }
                        }
                    }
                }
                /if (${DebugCombat}) /echo ${c} ${f}  ${FWait} \agLine#: ${Macro.CurLine}
                /if (!${c} || !${f} || (${f} && !${FWait})) /varset g 0 
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast 0 DebuffTargetID: ${DebuffTargetID} ${i} C: ${c} F: ${f} FWait: ${FWait} \agLine#: ${Macro.CurLine}
            /if (${MezOn}) /varset MezBroke 0
            /doevents
            /if (${DPSPaused}) {
                /if (${DebugCombat}) /echo DebuffCast: Return from DebuffCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
                /return
            }
            /if (!${c} || ${g} || (${f} && !${FWait})) {
                /if (${DebugCombat}) /echo DebuffCast Exit. \agLine#: ${Macro.CurLine}
                /return
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast 1 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} \agLine#: ${Macro.CurLine}
            /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
            /if (${MezOn} && !${MezBroke}) {
                /varset GoMByPass 1
                /call DoMezStuff DebuffCast
                /varset GoMByPass 0
            }
            /varset TempTimer 0
            /varset Tag1 ${DPS[${i}].Arg[4,|]}
            /varset Tag2 ${DPS[${i}].Arg[5,|]}
            /if (${Tag1.Equal[always]}) /varset Tag2 always
            | Test -> Do i have enough mana to cast the spell 
            /if (${Me.CurrentMana}<${Spell[${DebuffText}].Mana}) {
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: i didnt have enough mana to cast ${DebuffText} so im going to :SkipCast \agLine#: ${Macro.CurLine}
                /goto :SkipCast
            }
            /if (${Spawn[${DebuffTargetID}].Type.Equal[Corpse]} || ${Int[${Spawn[${DebuffTargetID}].ID}]}==0) /return
            /if (${Target.ID}!=${DebuffTargetID}) {
                /squelch /target clear
                /delay 10 ${Target.ID}==0
                /target id ${DebuffTargetID}
                /delay 20 ${Target.ID}==${DebuffTargetID} && ${Target.BuffsPopulated}==TRUE
            }
            /if (${Target.BuffsPopulated}==TRUE) {
                /echo Buffs Populated.
            } else {
                /echo Buffs NOT Populated.
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: Debuff: ${DebuffText} TargetID: ${Target.ID} DebuffTargetID: ${DebuffTargetID} : ${Target.Buff[${DebuffText}].ID} ${Target.Buff[${DebuffText}].Caster} ${Me.SpellInCooldown} ${Tag1} ${Tag2} \agLine#: ${Macro.CurLine}
            | Check Target for Buffs
            /if (${Target.BuffCount}) {
                | Does the Target have the debuff I am about to cast
                /if (${Target.Buff[${DebuffText}].ID}) {
                    /if (${Target.Buff[${DebuffText}].Caster.Equal[${Me.CleanName}]} || (${Target.Buff[${DebuffText}].Caster.NotEqual[${Me.CleanName}]} && ${Tag2.NotEqual[always]})) {
                        /varcalc TempTimer ${Target.BuffDuration[${DebuffText}].TotalSeconds}*10
                    }
                }
                | If timer didn't get set above then check this
                /if (${TempTimer}==0) {          
                    | Does the mob have one of the following debuffs if so lets skip casting
                    /if (${Tag1.Equal[strip]} && (${Int[${Target.Beneficial.ID}]}==0 || ${Int[${Target.Beneficial.ID}]}==38728 || ${Int[${Target.Beneficial.ID}]}==38727)) {
                        /varset TempTimer 70
                    } else /if (${Tag2.NotEqual[always]}) {
                        /if (${Tag1.Equal[slow]} && ${Target.Slowed.ID}) {
                            /varcalc TempTimer ${Target.BuffDuration[${Target.Slowed.Name}].TotalSeconds}*10
                        } else /if (${Tag1.Equal[tash]} && ${Target.Tashed.ID}) {
                            /varcalc TempTimer ${Target.BuffDuration[${Target.Tashed.Name}].TotalSeconds}*10
                        } else /if (${Tag1.Equal[malo]} && ${Target.Maloed.ID}) {
                            /varcalc TempTimer ${Target.BuffDuration[${Target.Maloed.Name}].TotalSeconds}*10
                        } else /if (${Tag1.Equal[crip]} && ${Target.Crippled.ID}) {
                            /varcalc TempTimer ${Target.BuffDuration[${Target.Crippled.Name}].TotalSeconds}*10
                        } else /if (${Tag1.Equal[snare]} && ${Target.Snared.ID}) {
                            /varcalc TempTimer ${Target.BuffDuration[${Target.Snared.Name}].TotalSeconds}*10
                        }
                    }
                }
                /if (${TempTimer}) {
                    /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                    /goto :SkipCast
                } 
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: DebuffTargetID: ${DebuffTargetID} Slowed: ${Target.Slowed.ID} Tashed: ${Target.Tashed.ID} Maloed: ${Target.Maloed.ID} Crippled:${Target.Crippled.ID} Tag1: ${Tag1} Tag2: ${Tag2} TempTimer: ${TempTimer} \agLine#: ${Macro.CurLine}
            } 
            /if (${HealsOn}) /call CheckHealth
            | Wait here for a sec, your spell bar may still be in global cool down.
            /if (${Me.SpellInCooldown}) {
                /delay 10
            }
            | When you get here you won't want to cast Eradicate Magic if the mob has NO Beneficial Buffs
            /if (${Tag1.Equal[strip]} && (${Int[${Target.Beneficial.ID}]}==0 || ${Int[${Target.Mezzed.ID}]})) {
                /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                /varset TempTimer 70
                /goto :SkipCast
            }
            | Conditional Check Added.
            /if (${ConditionsOn} && ${DPSCOn} && ${If[${DPSCond[${i}]},0,1]}) /goto :SkipCast
            | Everything is ready, lets debuff this mob
            /call CastWhat "${DebuffText}" ${DebuffTargetID} DebuffCast
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: Return From CastWhat: ${Macro.Return} \agLine#: ${Macro.CurLine}
            /if (${Macro.Return.Equal[CAST_RESIST]}) {
                /echo ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - RESISTED
                /goto :SkipCast
            }
            /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
                /echo ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - DID NOT TAKE HOLD
                /varset TempTimer 3m
                /goto :SkipCast
            }
            /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                /echo ** ${Spawn[${DebuffTargetID}].CleanName} is IMMUNE to - ${DebuffText}
                /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                /varset TempTimer 3m
                /goto :SkipCast
            }
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo ** Debuffing: ==> ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << DebuffTargetID: ${DebuffTargetID} Target: ${Target.ID} DBOList: ${DBOList${i}}
                /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                | Timers for items    
                /if (${FindItemCount[=${DebuffText}]}) {
                    /varcalc TempTimer ${FindItem[=${DebuffText}].Spell.Duration.TotalSeconds}*10
                    | Timers for AltAbilities
                } else /if (${Me.AltAbility[${DebuffText}]}) {
                    /varcalc TempTimer ${Me.AltAbility[${DebuffText}].Spell.Duration.TotalSeconds}*10
                    | Timers for spells
                } else /if (${Me.Book[${DebuffText}]}) {
                    | - Custom timer for counterbias
                    /if (${Me.Class.Name.Equal[Shaman]} && ${DebuffText.Find[counterbias]}) {
                        /varset TempTimer 1.5m
                        | Custom timer for Chanter suffocation
                    } else /if (${Me.Class.Name.Equal[enchanter]} && ${DebuffText.Find[suffocation]}) {
                        /varset TempTimer 1m
                        | Custom timer for Beastlord Feralgia Timer
                    } else /if (${Me.Class.Name.Equal[Beastlord]} && ${DebuffText.Find[feralgia]}) {
                        /varset TempTimer 1.5m
                        | Regular spells
                    } else /if (${Spell[${DebuffText}].Duration}>0) {
                    /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                        | Spells with no timers assign DPS interval
                    } else {
                        /varset TempTimer ${DPSInterval}s
                    }
                    | AA and disc timers
                } else /if (${Spell[${DebuffText}].Duration}>0) {
                    /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                    | AA and disc with no timers assign DPS interval
                } else {
                    /varset TempTimer ${DPSInterval}s
                }
                :SkipCast
                | Check Debuff Timer not set and the Temp Timer has been set.
                | You only want to set the DBOTimer for the first mob you get the Debuff to land on. Don't need a timer for every mob.
                /if (!${DBOTimer${i}} && ${TempTimer}) {
                    /varcalc DBOTimer${i} ${TempTimer}*.95
                }
            }
            | ************ Next Spell ***********
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast 2 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} \agLine#: ${Macro.CurLine}
        }
        /if (${DebugCombat}) /echo DebuffCast leave. \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezBroke
| -------------------------------------------------------------------------------------
    Sub Event_MezBroke(meztext,mezmob,mezbreaker)
        /if (${DebugMez}) /echo \atDEBUGMEZ event mezbroke Enter \agLine#: ${Macro.CurLine}
        /if (!${MezOn}) /return
        |/if (${MyTargetID}==${Spawn[${mezmob}].ID}) /return
        /if (${Spawn[${mezbreaker}].CleanName.Equal[${MainAssist}]}) /return
        /if (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[${MainAssist}].Master.CleanName.Equal[${mezbreaker}]}) /return
        /declare tempMobID int local ${Target.ID}
        /assist ${mezbreaker}
        /delay 5s ${Me.AssistComplete}==TRUE
        /if (${Target.ID} && ${Target.ID}==${MyTargetID}) {
           /target id ${tempMobID}
           /delay 10 ${Target.ID}==${tempMobID}
           /return
        }
        /declare i int local
        /call BroadCast ${IRCOn} ${EQBCOn} g ">>  ${Spawn[${mezbreaker}].CleanName} << has awakened -> ${mezmob}<-"
        /for i 1 to 30
            /if (${MezArray[${i},3].Equal[${mezmob}]}) {
                /echo Resetting Mez Timer ${mezmob} ID: ${MezArray[${i},1]}
                /varset MezTimer${i} 0
            }
        /next i
        /doevents flush MezBroke
        /varset GoMByPass 1
        /call DoMezStuff Event_MezBroke
        /varset GoMByPass 0
        | Set MezOn = 2 to let us know that the event was triggered. Will be set back to 1 in other location
        /varset MezBroke 1
        /if (${DebugMez}) /echo \atDEBUGMEZ event mezbroke Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezImmune
| -------------------------------------------------------------------------------------
    Sub Event_MezImmune(int MezID)
        /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
        | Assign temp var MezImmune list
        /declare ImmuneAdd string local ${MezImmune}
        | If mezimmune default text with the word null in it assign var spawn clean name
        /if (${ImmuneAdd.Find[null]}) {
            /varset ImmuneAdd ${Spawn[${MezID}].CleanName}
        } else {
            /varset ImmuneAdd ${ImmuneAdd},${Spawn[${MezID}].CleanName}
        }
        /if (!${MezImmune.Find[${Spawn[${MezID}].CleanName}]}) /ini "${InfoFileName}" "${Zone}${If[${Me.InInstance},_I,]}" "MezImmune" "${ImmuneAdd}"
        /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Adding to MezImmune list."
        | Reassign mezimmune var the new list
        /varset MezImmune ${ImmuneAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: AddMezImmune
| -------------------------------------------------------------------------------------
    Sub AddMezImmune(int MezID)
    /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
    /if (${MezImmuneIDs.Find[|${MezID}]}) /return
    /varset MezImmuneIDs ${MezImmuneIDs}|${MezID} 
    /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Skipping."
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddMezImmune
| -------------------------------------------------------------------------------------
    Sub Bind_AddMezImmune(MTImmune)
        /if (!${MTImmune.Length} || ${MTImmune.Find[null]} || ${Spawn[${MTImmune}].ID}==${Me.ID} ) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MezImmune list
        /declare MezImmuneAdd string local ${MezImmune}
        | If MezImmune default text with the word null in it assign var spawn clean name
        /if (${MezImmuneAdd.Find[null]} && ${MezImmune.Find[null]}) {
            /varset MezImmuneAdd ${Spawn[${MTImmune}].CleanName}
        } else {
            /varset MezImmuneAdd ${MezImmune},${Spawn[${MTImmune}].CleanName}
        }
        | Remove's corpse if closest match is a mob corpse
        /if (${MezImmuneAdd.Right[-10].Find[corpse]}) /varset MezImmuneAdd ${MezImmuneAdd.Right[-8]}
        /if (${MezImmune.Find[${Spawn[${MTImmune}].CleanName}]}) {
            /echo >> ${Spawn[${MTImmune}].CleanName} << already on Mez Immune List.
            /return
        }
        /if (${Spawn[${MTImmune}].CleanName.Equal[null]}) {
            /echo No Mob with ${MTImmune} in Name detected.
            /return
        }
        /if (!${MezImmune.Find[${Spawn[${MTImmune}].CleanName}]}) {
            /ini "${InfoFileName}" "${ZoneName}" "MezImmune" "${MezImmuneAdd}"
            /echo MezImmune -> ${Spawn[${MTImmune}].CleanName} <- Adding to Mez Immune  list.
        }
        | Reassign MezImmune var the new list
        /varset MezImmune ${MezImmuneAdd}
    /return    
| -------------------------------------------------------------------------------------
| SUB: Bind AddToIgnore
| -------------------------------------------------------------------------------------
    Sub Bind_AddToIgnore(MTIgnore)
        | Take the targeted mob as a parameter for mob to ignore.
        /if (!${Defined[MTIgnore]}) /declare MTIgnore string local ${Target.CleanName}
        /if (${MTIgnore.Equal[null]} || !${Spawn[${MTIgnore}].Type.Equal[NPC]} || ${Spawn[${MTIgnore}].CleanName.Equal[null]}) {
            /echo No NPCs named (${MTIgnore}) detected. Nothing added to list.
            /return
        }
        | Assign temp var   list
        /declare IgnoreAdd string local ${MobsToIgnore}
        | If MobsToIgnore default text with the word null in it assign var spawn clean name
        /if (${IgnoreAdd.Find[null]}) {
            /varset IgnoreAdd ${Spawn[${MTIgnore}].CleanName}
        } else {
            /varset IgnoreAdd ${IgnoreAdd},${Spawn[${MTIgnore}].CleanName}
        }  
        | Remove's corpse if closest match is a mob corpse
        /if (${IgnoreAdd.Right[-10].Find[corpse]}) /varset IgnoreAdd ${IgnoreAdd.Right[-8]}
        /if (${MobsToIgnore.Find[${Spawn[${MTIgnore}].CleanName}]}) {
            /echo >> ${Spawn[${MTIgnore}].CleanName} << already on Ignore List.
            /return
        }
        /ini "${InfoFileName}" "${ZoneName}" "MobsToIgnore" "${IgnoreAdd}"
        /echo AddToIgnore -> ${Spawn[${MTIgnore}].CleanName} <- Adding to Ignore list.
        | Reassign MobsToIgnore var the new list
        /varset MobsToIgnore ${IgnoreAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddToPull
| -------------------------------------------------------------------------------------
    Sub Bind_AddToPull(MTPull)
        /if (!${MTPull.Length} || ${MTPull.Find[null]} || ${Spawn[${MTPull}].ID}==${Me.ID} ) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MobsToPull list
        /declare PullAdd string local ${MobsToPull}
        | If MobsToPull default text with the word null in it assign var spawn clean name
        /if (${PullAdd.Find[all]}) {
            /varset PullAdd ${Spawn[${MTPull}].CleanName}
        } else {
            /varset PullAdd ${PullAdd},${Spawn[${MTPull}].CleanName}
        }
        | Remove's corpse if closest match is a mob corpse
        /if (${PullAdd.Right[-10].Find[corpse]}) /varset PullAdd ${PullAdd.Right[-8]}
        /if (${MobsToPull.Find[${Spawn[${MTPull}].CleanName}]}) {
            /echo >> ${Spawn[${MTPull}].CleanName} << already on Pull List.
            /return
        }
        /if (${Spawn[${MTPull}].CleanName.Equal[null]}) {
            /echo ERROR: No Mob with ${MTPull} in Name detected.
            /return
        }
        /if (!${MobsToPull.Find[${Spawn[${MTPull}].CleanName}]}) {
            /ini "${InfoFileName}" "${ZoneName}" "MobsToPull" "${PullAdd}"
            /echo AddToPull-> ${Spawn[${MTPull}].CleanName} <- Adding to Pull list.
        }
        | Reassign MobsToPull var the new list
        /varset MobsToPull ${PullAdd}
    /return
| ----------------------------------------------------------------------------
| SUB: Add a friend to mq2posse list
| ----------------------------------------------------------------------------
    Sub Bind_AddAFriend
        /declare AFriend string local ${Target.CleanName}
        /if (!${Target.ID} || ${Spawn[${Target.ID}].Type.NotEqual[pc]} || ${Target.ID}==${Me.ID}) {
            /echo --ADDFRIEND: Target a PC to add your Posse list.
            /return
        }
        /docommand /posse add ${AFriend}
        /docommand /posse save
        /docommand /posse load
    /return    
| -------------------------------------------------------------------------------------
| SUB: Bind_ToggleVariable  Check whenever the player is changing any variable via /echo
| -------------------------------------------------------------------------------------
    Sub Bind_ToggleVariable(string Command, string Command2, string Command3)
        /if (${Debug}) /echo ${Command}:${${Command}} ${Defined[${Command}]} ${Command2} ${Command3}
        /declare i int local
        /declare OnOff local
        | Toggle Variables & Set Variables
        /if (${Defined[${Command}]}) {
            /if (${Select[${Command2},0,1,on,off]}) {
                /if (${Select[${Command2},0,off]}) {
                    /varset ${Command} 0
                    /varset OnOff Off
                    /if (${Debug}) /echo ${OnOff} 1
                } else /if (${Select[${Command2},1,on]}) {
                    /varset ${Command} 1
                    /varset OnOff On
                    /if (${Debug}) /echo ${OnOff} 2
                } 
            } else /if (${${Command}}) {
                /varset ${Command} 0
                /varset OnOff Off
                /if (${Debug}) /echo ${OnOff} 3
                /if (!${ChaseAssist} && ${Stick.Active})  /squelch /stick off
            } else {
                /varset ${Command} 1
                /varset OnOff On
                /if (${Debug}) /echo ${OnOff} 4
            }
            /if (${Command.Equal[ChaseAssist]} && ${OnOff.Equal[on]}) {
                /if (${Command3.NotEqual[null]} && ${Command3.Length}>0 && ${WhoToChase.NotEqual[${Command3}]}) {
                    /varset WhoToChase ${Command3}
                    /echo I Will Now Chase ${WhoToChase}
                }
                /if (${ReturnToCamp}) /varset ReturnToCamp 0
            }
            | Turn on return to camp & set new y,x coord
            /if (${Command.Equal[ReturnToCamp]} && ${OnOff.Equal[on]}) {
                /varset CampXLoc ${Me.X}
                /varset CampYLoc ${Me.Y}
                /varset CampZLoc ${Me.FloorZ}
                /varset LookForward ${Me.Heading.DegreesCCW}
                | Turn off ChaseAssit if on
                /if (${ChaseAssist}) {
                    /varset ChaseAssist 0
                    /if (${Stick.Active}) /squelch /stick off
                    /echo >> ChaseAssist Off
                }
                /echo >> New camp set ${Me.Y}, ${Me.X}
            }
            /if (${Command.Find[Debug]}) {
                /if (${EverQuest.CurrentUI.NotEqual[Default]}) {
                    /echo You are using a Custom UI. Please switch to Default UI before Posting.
                }
            }
            | /ini "${IniFileName}" "${sectionName}" "${varName}" "${varValue}"
            /if (${Debug}) /echo ${Command} ${Command2} ${Command3}
            /echo >> Setting: (${Command}) to (${If[${Select[${OnOff},on,1]}>0,On,Off]})
        } else /if (${Command.Equal[conditions]}) {
            /if (${Command2.Equal[all]}) {
                /if (${Select[${Command3},1,on]}) {
                    /varset ConditionsOn 1
                    /varset GoMCOn 1
                    /varset DPSCOn 1
                    /varset HealsCOn 1
                    /varset BurnCOn 1
                    /varset BuffsCOn 1
                } else {
                    /varset ConditionsOn 0
                    /varset GoMCOn 0
                    /varset DPSCOn 0
                    /varset HealsCOn 0
                    /varset BurnCOn 0
                    /varset BuffsCOn 0
                }
                /echo >> Setting: (${Command}) ${Command2} to (${If[${Select[${Command3},on,1]}>0,On,Off]})
            } else /if (${Select[${Command2},on,off,1,0]}>0) {
                /if (${Select[${Command2},1,on]}) {
                    /varset ConditionsOn 1
                } else {
                    /varset ConditionsOn 0
                }
                /echo >> Setting: (ConditionsOn) to (${If[${ConditionsOn},On,Off]})
            } else {
                /if (${Select[${Command3},1,on]}) {
                    /varset OnOff 1
                } else {
                    /varset OnOff 0
                }
                /if (${Command2.Equal[gom]}) {
                    /varset GoMCOn ${OnOff}
                } else /if (${Command2.Equal[dps]}) {
                    /varset DPSCOn ${OnOff}
                } else /if (${Command2.Equal[heals]}) {
                    /varset HealsCOn ${OnOff}
                } else /if (${Command2.Equal[burn]}) {
                    /varset BurnCOn ${OnOff}
                } else /if (${Command2.Equal[buffs]}) {
                    /varset BuffsCOn ${OnOff}
                } 
                /echo >> Setting: (${Command}) ${Command2} to (${OnOff})
            }
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: DoMiscStuff
| -------------------------------------------------------------------------------------
    Sub DoMiscStuff
    /if (!${ChainPull} && (${CombatStart} || ${AggroTargetID})) /return
    /if (${Debug}) /echo \atDEBUG DoMiscStuff Enter \agLine#: ${Macro.CurLine}
        /if (${Window[alertwnd].Open}) /nomodkey /notify alertwnd ALW_Close_Button leftmouseup
        | Accept trades
        /if (${Window[TradeWnd].Open} && ${Window[TradeWnd].HisTradeReady} && !${Cursor.ID}) /notify TradeWnd TRDW_Trade_Button leftmouseup
        | Accept group invite
        /if (${Window[GroupWindow].Child[GW_FollowButton]} && ${AcceptInvitesOn}) /invite
        | Open HoTT window if available
        /if (${HoTTOn} && !${Window[TargetOfTargetWindow].Open}) /windowstate TargetOfTargetWindow open
        | Ditch wizards familiar
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]} && ${Me.Class.ShortName.Equal[Wiz]}) /pet get lost
        | Drop random items on cursor like drive by mod rods into inventory after 30s min
        /if (${Cursor.ID} && !${CursorIDTimer}) {
            /varset CursorIDTimer 20s
            /if (${Me.FreeInventory}) {
                /echo ${Cursor.Name} is stuck on my cursor. Dropping it into inventory in 15s.
                /timed 150 /autoinventory
            } else /if (!${Me.FreeInventory}) {
                /echo HEY YOUR INVENTORY IS FULL!
            }
        }      
    /if (${ChainPull} && ${ChainPullPause.NotEqual[0]} && !${ChainPullHold} && !${ChainPullTimer2}) {
           /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
           /varset ChainPullTimer2 ${ChainPullPause.Arg[2,"|"]}m
    }
    /if (${ChainPull} && ${ChainPullPause.NotEqual[0]} && !${ChainPullTimer}) {
            /if (!${ChainPullHold}) {
            /echo Pausing Pulls for ${ChainPullPause.Arg[2,"|"]} Minutes. 
            /varset ChainPullHold 2
            /varset ChainPullTimer ${ChainPullPause.Arg[2,"|"]}m
            } else /if (${ChainPullHold}==2) {
            /echo Resetting Pull Timer for ${ChainPullPause.Arg[1,"|"]} Minutes. 
            /varset ChainPullHold 0
            /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
            /varset ChainPullTimer2 ${ChainPullPause.Arg[2,"|"]}m
            }
        } 
        /if (${Debug}) /echo \atDEBUG DoMiscStuff Leave \agLine#: ${Macro.CurLine}
/return

| -------------------------------------------------------------------------------------
| SUB: Can I do Stuff  - Check if invis moving ducked etc
| -------------------------------------------------------------------------------------
    Sub CanIDoStuff
    /if ((${CombatStart} || ${AggroTargetID} || ${Me.CombatState.NotEqual[COMBAT]})) /return
    /if (${Debug}) /echo \atDEBUG CanIDoStuff Enter \agLine#: ${Macro.CurLine}
    /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0) ) {
        /varset IAmDead 0
        /if (${IAmABard}) {
            /while (${Me.BardSongPlaying}) {
                /if (${Twist}) /squelch /twist off
                /stopsong
                /delay 5
            }
            /varset Twisting 0
            /varset DPSTwisting 0
        }
    }
    | Turn off twist while invis
    /if (${Me.Invis} && ${IAmABard} && ${Twist}) {
        /while (${Me.BardSongPlaying}) {
            /if (${Twist}) /squelch /twist off
            /stopsong
            /delay 5
        }
    }
    | Assign Master looter    
    /if (${Select[${Me},${Group.Leader}]}==1) /call AssignLooter
    :IAmBusy
        /doevents
        /call WriteDebuffs
        /call RogueStuff
        /delay 2
        /call EndMacroIf
        /if (${Debug} && ${Me.Invis}) /echo You are invisible. 
        /if (${Me.Moving} || ${Me.State.Equal[feign]} || (${ChaseAssist}==0 && ${AggroTargetID}==0 && ${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || ${Me.Stunned} || ${Me.Ducking}  || (${Me.State.Equal[BIND]} && !${Window[LootWnd].Open})) /goto :IAmBusy
        /if (${Window[MerchantWnd]} || ${Window[GiveWnd]} || ${Window[SpellBookWnd]} || ${Window[BigBankWnd]} || ${Window[BankWnd]} || ${Window[GuildBankWnd]}  || ${Window[TributeMasterWnd]} || ${Window[GuildTributeMasterWnd]}) /goto :IAmBusy
    /if (${Debug}) /echo \atDEBUG CanIDoStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Mercs Do What
| -------------------------------------------------------------------------------------
    Sub MercsDoWhat
        /if (!${MercOn}) /return
        /if (${Group.Member[1].Owner.Name.Equal[${Me}]}) /varset MyMerc ${Group.Member[1].Name}
        /if (${Debug}) /echo \atDEBUG MercsDoWhat Enter \agLine#: ${Macro.CurLine}
        /if (${Mercenary.State.Equal[Active]}) /varset MercInGroup 1
        | Revive the merc if dead and previously detected in group
        /if (${MercInGroup} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Mercenary.State.Equal[DEAD]}) /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
        /if (${MercAssistAt}>=${Spawn[${MyTargetID}].PctHPs} && ${Mercenary.State.Equal[Active]} && !${MercAssisting} && (${CombatStart} || ${Select[${Role},Puller]} && ${Pulled})) {
            /mercassist
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT MercsDoWhat ${Spawn[${MyTargetID}].CleanName} %:${Spawn[${MyTargetID}].PctHPs} ID:${Spawn[${MyTargetID}].ID} \agLine#: ${Macro.CurLine}
            /varset MercAssisting 1
        }
        /if (${Debug}) /echo \atDEBUG MercsDoWhat Enter \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| Sub Assign Main Assist
| -------------------------------------------------------------------------------------
    Sub AssignMainAssist    
        /if (${Debug}) /echo \atDEBUG AssignMainAssist Enter \agLine#: ${Macro.CurLine}
        /declare i int local    
        /varset MainAssist ${Target.CleanName}
        /varset MainAssistType ${Target.Type}
        /varset MainAssistClass ${Target.Class.ShortName}
        /if (${Debug}) /echo \atDEBUG AssignMainAssist Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| Sub Check Roles
| -------------------------------------------------------------------------------------
    Sub CheckRoles(int specialK)
        /if (${Debug}) /echo \atDEBUG CheckRoles Enter \agLine#: ${Macro.CurLine}
        /if (${Role.Equal[assist]}) {
            /if (${Debug}) /echo \atDEBUG Looks like I am assisting. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
        } else /if (${Role.Equal[tank]}) {
            /if (${Debug}) /echo \atDEBUG Looks like I am Main Tank. Wish me luck. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /varset StickHow front 15
        } else /if (${Role.Equal[puller]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role puller \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Puller. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Pet.ID} && ${Me.Pet.Distance}>${CampRadius}) /pet follow        
        } else /if (${Role.Equal[pullertank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pullertank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Puller and Tank. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /varset StickHow front 12
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Pet.ID} && ${Me.Pet.Distance}>${CampRadius}) /pet follow            
        } else /if (${Select[${Role},hunter]}) {
            /if (${DebugPull})  /echo \atDEBUGPULL role hunter \agLine#: ${Macro.CurLine}
            /if (${DebugPull})  /echo \atDEBUGPULL Looks like I am Hunting. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /varset StickHow front 12
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /varset ReturnToCamp 0
            /varset MobsTooClose 15
            /if (${Pet.ID}) /pet follow
        } else /if (${Role.Equal[hunterpettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role hunterpettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Hunting and my pet is tanking. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange 115            
            /varset ReturnToCamp 0
            /varset ChaseAssist 0
            /varset MountOn 0
            /varset MobsTooClose 15
            /if (${Pet.ID}) /pet follow
        } else /if (${Select[${Role},petassist]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role petassist \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am assisting a pet. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
        } else /if (${Select[${Role},pettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like my pet is tanking. \agLine#: ${Macro.CurLine}   
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange 115
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            :PTauntOn1
            /if (${Me.Pet.ID} && !${PetTauntOn}) {
                /pet taunt on
                /delay 10
                /doevents PTaunt
                /if (!${PetTauntOn}) /goto :PTauntOn1
            }            
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow            
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend} && ${specialK}) /call PetStateCheck                        
        } else /if (${Select[${Role},pullerpettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pullerpettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am pulling and my pet is tanking. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /varset MeleeOn 0
            /varset PetTanking 1
            /varset PetAttackRange 115
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            :PTauntOn2
            /if (${Me.Pet.ID} && !${PetTauntOn}) {
                /pet taunt on
                /delay 10
                /doevents PTaunt
                /if (!${PetTauntOn}) /goto :PTauntOn2
            }
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow
            /if (${PullRoleToggle} && ${Group.Leader.ID}!=${Me.ID}) {
                /echo You are set to toggle puller mode but are NOT the group leader.
                /echo Please correct this and restart KissAssist. 
                /end
            }
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend} && ${specialK}) /call PetStateCheck           
        } else /if (${Role.Equal[manual]}) {
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
            /varset ReturnToCamp 0
            /varset ChaseAssist 0
            /varset DPSOn 0
            /varset BuffsOn 0
            /varset DebuffAllOn 0
            /if (${Defined[HealsOn]}) /varset HealsOn 0
            /if (${Defined[MezOn]}) /varset MezOn 0
        }    
        /if (${Select[${Role},puller,pullerpet]}==0 && ${ChainPull}) /varset ChainPull 0 
        /if (${Debug}) /echo \atDEBUG CheckRoles Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullRange
| -------------------------------------------------------------------------------------
   Sub PullRangeSet
       /if (${DebugPull}) /echo \atDEBUGPULL PullRange Enter \agLine#: ${Macro.CurLine}
       /declare PullItemRange int local
        /if (${Select[${FindItem[=${PullWith.Arg[1,|]}].Type},Archery,Throwing,Throwingv1,Throwingv2,ammo]} && ${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /varset PullItem ${PullWith.Arg[1,|]}
            /varset PullItemRange ${FindItem[=${PullWith.Arg[1,|]}].Range}
            /if (!${PullItemRange}) /varset PullItemRange 50
            /if (${FindItem[=${PullWith.Arg[2,|]}].WornSlot[ammo]} && ${FindItemCount[=${PullWith.Arg[2,|]}]}) {
                /varset PullAmmo ${PullWith.Arg[2,|]}
                /if (${FindItem[=${PullWith.Arg[1,|]}].Type.Equal[Archery]}) {
                    /varcalc PullItemRange ${PullItemRange}+${FindItem[=${PullWith.Arg[2,|]}].Range}
                }
                /call PullVars ${Math.Calc[${PullItemRange}*(${PullRadiusToUse}/100)]} Ranged ${PullItemRange}
            } else {
                /echo I can't find any ammo defaulting to Melee for PullWith
                /varset PullWith Melee
                /call PullVars 15 Melee 15
                /return
            }
        /if (${DebugPull}) /echo \atPullWith=(${PullWith}) PullItem=(${PullItem}) PullItemRange=(${PullItemRange}) PullItemCount=(${FindItemCount[=${PullWith.Arg[1,|]}]}) PullAmmo=(${PullAmmo})\agLine#: ${Macro.CurLine}
        }
        /if (${FindItemCount[=${PullWith}]} && !${PullWith.Arg[2,|].Length} && ${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /varset PullItemRange ${FindItem[=${PullWith}].Spell.Range}
            /call PullVars  ${Math.Calc[${PullItemRange}*.9]} "${PullWith}" ${PullItemRange}
            /return
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullRange PullWith: ${PullWith} - CA:${Me.CombatAbility[${PullWith}]}/SPELL:${Me.Book[${PullWith}]}/ AA: ${Me.AltAbility[${PullWith}]} \agLine#: ${Macro.CurLine}
        /if (${Me.CombatAbility[${PullWith}]} || ${Me.Book[${PullWith}]} || ${Me.AltAbility[${PullWith}]})  {
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]}) /call PullVars ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].MyRange}/1.11]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].MyRange}
            /if (${Select[${Role},hunter]})  {
                /if (${DebugPull}) /echo ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].MyRange}/2.75]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].MyRange} \agLine#: ${Macro.CurLine}
                /call PullVars ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].MyRange}/2.75]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].MyRange}
            }
        }
        /if (${PullWith.Equal[Pet]}) {
            /if (${Role.Equal[hunterpettank]}) {
                /call PullVars ${Math.Calc[${PetAttackRange}*.80]} Pet ${Math.Calc[${PetAttackRange}*.80]}
            } else {
                /call PullVars 185 Pet 185
            }
        }
        /if (${PullWith.Equal[Melee]}) {
            /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                /beep
                /beep
                /beep
                /popup You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /if (${DebugPull}) /echo ${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}
                /echo You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /endmac
            } else {
                /call PullVars 15 Melee 15
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullRange Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullVars
| -------------------------------------------------------------------------------------
    Sub PullVars(int pRange, pType, int pRange2)
        /if (${DebugPull}) /echo \atDEBUGPULL PullVars Enter \agLine#: ${Macro.CurLine}
        /varset PullRange ${pRange}
        /varset PullWith ${pType}
        /varset PullRangeActual ${pRange2}
        /if (${Bool[${Plugin[MQ2Map]}]}) /squelch /mapfilter CastRadius ${PullRange}
        |/if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) /varcalc MaxRadius ${TempMaxRadius}+${PullRangeActual}
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) /varcalc MaxRadius ${TempMaxRadius}+${PullRange}
        /if (${DebugPull}) /echo MaxRadius is now ${MaxRadius} \agLine#: ${Macro.CurLine}
        /if (${DebugPull}) /echo \atDEBUGPULL PullVars Leave \agLine#: ${Macro.CurLine}
    /return
| -----------------------------------------------------------------------------------------------------------
| SUB: FindMobToPull(int PullFlag) (NEW VERSION) PullFlag 1 - Find mob and pull  0 - Check to see if there is a mob
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobToPull(int PullFlag)
        |/if (${ChainPull}==2 && ${PullFlag}) /varset ChainPull 1
        /if ((${DMZ} && ${Me.InInstance}==FALSE) || (${PullFlag} && !${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) || (!${PullFlag} && !${Role.Find[puller]}) || ${Pulled} || (${AggroTargetID}  && !${ChainPull}) || ${ChainPullHold} || ${DPSPaused}) /return 0
            /call MobRadar ${MeleeDistance} FindMobToPull
        /if (${ChainPull} && (${MobCount}>1 || ${Me.XTarget[${XTSlot2}].ID})) /return 0
        /if (${PullFlag}) {
            /if (${ChainPull}) {
                /if (${Target.ID}==${Me.ID}) {
                    /squelch /target clear
                    /delay 10
                }
                /if (${Me.XTarget[${XTSlot}].ID} && ((!${MyTargetID} && !${Target.ID}) || ${Target.PctHPs}>=${ChainPullHP} || (${MyTargetID} && ${Spawn[${MyTargetID}].PctHPs}>=${ChainPullHP}))) /return 0
                /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>75) /return 0
            }
        }
        /if (${PullFlag} && !${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID} || ${IAmDead}) /return 0
        /if (${PullFlag} && ${PetRampPullWait} && !${Me.CombatState.Equal[COMBAT]} && ${Select[${Role},pullerpettank]} && ${Select[${Me.Class.ShortName},MAG,NEC,BST]}) /call CheckRampPets      
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull Enter ${PullFlag} \agLine#: ${Macro.CurLine}
        /call PullRangeSet
        /doevents
        /declare i int local
        /declare j int local
        /declare k int local
        /declare l int local
        /declare m int local
        /declare n int local
        /declare o int local
        /declare p int local
        /declare f1 int local 0
        /declare PullMobName string local 0
        /declare PullMobDistance float local 0
        /declare PullMobValid int local 0
        /declare PullCount int local
        /declare DistanceCheck int local
        /declare MobsNearCamp int local
        /declare MobsToPullList int local
        /declare PullingTimer timer local 5s
        /declare Start1 int local
        /declare WPMobCount int local
        | Sort by path-lengths for MQ2Nav vars
        /declare PathArray[999] int local 0
        /declare PathDistance[999] float local 0
        /declare PathCount int local 0
        /declare SortIDTemp int local 0
        /declare SortDistTemp float local 0
        /declare m2 int local 0
        /declare cMobDist int local 0
        /declare lMobDist int local 0
        /declare lMobID int local 0
        /declare f2 int local 0
        /varset Pulling 0
        /call GroupWatch
        /if (${ChainPullHold}) /return 0
        /if (${PullFlag}) {
           /echo Looking for Close Range Mobs
        } else {
           /if (!${SpamTimer}) {
              /echo Checking for Close Range Mobs 
              /varset SpamTimer 50
           }   
        }
        | Clear alert list 1, add mobs to ignore alert list1, set timer to keep alert list manageable for pulling no alert 1
        /if (!${PullAlertTimer}) {
            | Add Ignore Mob list to alert list
            /call AlertAddToList 1 "${MobsToIgnore}" "${PullIgnore1}"
            /varset PullAlertTimer 5m
        }
        /varset k 1
        /while (${PullIgnore1.Arg[${k},|].Length} && ${PullIgnore1.Find[|]} && ${PullIgnore1.NotEqual[null]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullIgnore: ${PullIgnore1} Count: ${k} Arg: ${PullIgnore1.Arg[${k},|]}
            /if ((!${Spawn[id ${PullIgnore1.Arg[${k},|]}].ID} || ${Spawn[${PullIgnore1.Arg[${k},|]}].Type.Equal[Corpse]}) && ${PullIgnore1.Arg[${k},|].NotEqual[null]}) {
                /echo Removing from Alert List: ${k} ${PullIgnore1.Arg[${k},|]} ${Spawn[id ${PullIgnore1.Arg[${k},|]}].ID}
                /squelch /alert remove 1 id ${PullIgnore1.Arg[${k},|]}
                /varset PullIgnore1 ${PullIgnore1.Replace[|${PullIgnore1.Arg[${k},|]},]}
            } else {
                /varcalc k ${k}+1
            } 
        }
        | Add any mob NOT on MobsToPull list to the Ignore List
        /if (!${MobsToPull.Find[All for all]} && ${MobsToPull.NotEqual[All]}) {
            /declare MobToPullName string local
            /declare MobToPullIgnore int local 
            /declare MobsToIgnoreTemp string local ${MobsToIgnore}
            /varset MobsToPullList ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable]}
            /if (${MobsToPullList}) {
            /for o 1 to ${MobsToPullList}
                /varset MobToPullName  ${NearestSpawn[${o}, npc radius ${PullRange} zradius ${MaxZRange} targetable].CleanName}
                /varset MobToPullIgnore 1
                /for j 1 to 25
                    /if (${MobsToPull.Arg[${j},,].Find[${MobToPullName}]}) {
                        /varset MobToPullIgnore 0
                    }
                    /if (!${MobToPullIgnore}) /break
                /next j
                /if (${MobToPullIgnore}) {
                    /if (${MobsToIgnoreTemp.Find[null]}) {
                        /varset MobsToIgnoreTemp ${MobToPullName}
                    } else {
                        /varset MobsToIgnoreTemp ${MobsToIgnoreTemp},${MobToPullName}
                    } 
                }
            /next o
            /call AlertAddToList 1 "${MobsToIgnoreTemp}" "${PullIgnore1}"
            }            
        }
        :FindMob
        | Advpath searches for mobs along the path using Pullwith radius not Maxradius
        /if (${PullMoveUse.Equal[advpath]}) {
            /if (${Target.ID}) /squelch /target clear
            /varset PullMobValid 0 
            | loop through pathwaypoints and check for mobs
            /for k 1 to ${PullPathWpCount}
                /varset WPMobCount 0
                /varset PullMob 0
                /if (${UseWayPointZ}) {
                    /varset WPMobCount ${SpawnCount[npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${PullPathArrayZ[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable noalert 1]}
                } else {
                    /varset WPMobCount ${SpawnCount[npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable noalert 1]}
                }
                /if (${WPMobCount}) {
                    /varset i 0
                    /for l 1 to ${WPMobCount}
                        /if (${UseWayPointZ}) {
                            /varset PullMob ${NearestSpawn[${l}, npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${PullPathArrayZ[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable noalert 1].ID}
                        } else {
                            /varset PullMob ${NearestSpawn[${l}, npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable noalert 1].ID}
                        }
                        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 1: WP: ${k} MobID ${PullMob} LOS ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} YXZ ${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z} \agLine#: ${Macro.CurLine}
                        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 1.0: WP: ${k} MobID ${PullMob} UseWaypointZ: ${UseWayPointZ} WP Z: ${PullPathArrayZ[${k}]} Spawn Z: ${Spawn[id ${PullMob}].Z} Distance From Z: ${Math.Distance[${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Z}]} \agLine#: ${Macro.CurLine}
                        /if (${DebugPull}) /delay 1
                        /if (${PullMob} && ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                /if (${k}<${PullPathWpCount}) {
                                    /varcalc i ${k}+1
                                    /while (${i}<=${PullPathWpCount} && ${DistanceCheck}>${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                        /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                        /varcalc i ${i}+1
                                    }
                                    /varset k ${i}
                                }
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: WP ${k} MobCount ${l} ${WPMobCount} \agLine#: ${Macro.CurLine}
                            /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                            /varset PullMobDistance ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                            /varcalc AdvpathPointNum ${k}
                            /varset AdvpathPointX ${PullPathArrayX[${k}]}
                            /varset AdvpathPointY ${PullPathArrayY[${k}]}
                            /varset AdvpathPointZ ${PullPathArrayZ[${k}]}
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 2: WP: ${k} Pullmob ${PullMob} Waypoint: ${AdvpathPointNum} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]}<${PullRange} \agLine#: ${Macro.CurLine}
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 2: AdvPull: Pullmob: ${PullMobName} ID ${PullMob} Waypoint: ${PullPathWpCount} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} \agLine#: ${Macro.CurLine}
                            /call PullValidate ${PullMob} ${PullFlag}
                            /varset PullMobValid ${Macro.Return}
                            |/if (${PullMobValid}) /goto :FoundMob
                            /if (${PullMobValid}) /break
                        }
                    /next l
                }
                /if (${PullMobValid}) /break
            /next k
            /if (${PullMobValid}) /goto :FoundMob
            /varset PullMob 0
            /varset ChainPullTemp 0
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: Mob Not Found. AdvPull: PullFlag: ${PullFlag} Role: ${Role} ID: ${PullMob} PullRange: ${PullRange} \agLine#: ${Macro.CurLine}
            /return 0
            | Check for mobs in max pull radius for normal,MQ2nav pulling
        } else /if (${PullMoveUse.Equal[nav]}) {
            /varset PullCount ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        } else /if (${Select[${Role},hunter,hunterpettank]}) {
            /varset PullCount ${SpawnCount[npc radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        } else {
            /varset PullCount ${SpawnCount[npc los loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc los loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        }
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull PullFlag:${PullFlag} Pullcount: ${PullCount} MobsNearCamp: ${MobsNearCamp} Pull How: ${PullMoveUse} \agLine#: ${Macro.CurLine}
        /if (!${PullFlag} && ${PullCount}>0 && ${Spawn[${LastMobPullID}].Distance}>=${MeleeDistance}) /return 0
        /if (!${PullFlag}) /varcalc PullCount ${PullCount}-${MobsNearCamp}
        /if (${PullCount}) {
           /if (!${PullFlag} && ${MobsNearCamp}) {
                /varset f1 2
            } else {
                /varset f1 1
            }
            | Pull mob with shortest path JooJooBean
            /if (${PullMoveUse.Equal[nav]}) {
                | Pull mob with shortest path by joojoobee
                |/varset PullCount ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
                /for p 1 to ${PullCount}
                    /varset PathArray[${p}] ${NearestSpawn[${p}, npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                    /varset PullMob ${PathArray[${p}]}
                    /if (${Navigation.PathExists[id ${PullMob}]}) {
                        /varset PathDistance[${p}] ${Navigation.PathLength[id ${PullMob}]} 
                        /if (${DebugPull}) /echo Succsesfully Added ${Navigation.PathExists[id ${PullMob}]} (dist :${PathDistance[${p}]}) to the pull array.
                    } else {
                        /varset PathDistance[${p}] 100000
                    }
                /next p
				/if (${PullCount}>1) {
                    /for m 1 to ${PullCount}
                        /varset PathCount ${m}
                        /varset m2 ${Math.Calc[${m} + 1]}
                        /for n ${m2} to ${PullCount}
                            /if (${PathDistance[${n}]} < ${PathDistance[${PathCount}]}) /varset PathCount ${n}
                        /next n
                        /varset SortIDTemp ${PathArray[${m}]}
                        /varset SortDistTemp ${PathDistance[${m}]}
                        /varset PathArray[${m}] ${PathArray[${PathCount}]}
                        /varset PathArray[${PathCount}] ${SortIDTemp}
                        /varset PathDistance[${m}] ${PathDistance[${PathCount}]}
                        /varset PathDistance[${PathCount}] ${SortDistTemp}
                        /if (${m2}==${PullCount}) /break
                        /if (${DebugPull}) /echo \atDEBUGPULL /echo \atDEBUGPULL FindMobToPull: PathNum: ${PathDistance[${m}]} PathDistance:${PathDistance[${PathCount}]} \agLine#: ${Macro.CurLine}
                    /next m
				}
            }
            /for i ${f1} to ${PullCount}
                /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 1.0:  PullFlag: ${PullFlag} Pullcount: ${PullCount} \agLine#: ${Macro.CurLine}
                /if (${PullMoveUse.Equal[nav]}) {
                    /varset PullMob ${PathArray[${i}]}
                    |/varset PullMob ${lMobID}
                    /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                    /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} MQ2Nav: Name: ${PullMobName} ID: ${PullMob} \agLine#: ${Macro.CurLine}
                } else /if (${Select[${Role},hunter,hunterpettank]} && ${Select[${PullMoveUse},los,nav]}>=1) {
                   /varset PullMob ${NearestSpawn[${i}, npc radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                   /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                   /if (${DebugPull} && ${Select[${Role},hunter]}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Role: ${Role} Name: ${PullMobName} ID: ${PullMob} \agLine#: ${Macro.CurLine}
                } else /if (${PullMoveUse.NotEqual[advpath]}) {
                   /varset PullMob ${NearestSpawn[${i}, npc los loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                   /if (${PullMob}) /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                   /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Normal Name: ${PullMobName} ID: ${PullMob} LOS: ${LineOfSight[${CampYLoc},${CampXLoc},${CampZLoc}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} \agLine#: ${Macro.CurLine}
                }
                |/if (${PullMob}) {
                |    /echo we have a mob to pull its ${Spawn[id ${PullMob}]} ${Spawn[id ${PullMob}].Distance} feet away
                |    /varset PullMobDistance ${Spawn[id ${PullMob}].Distance}
                |}
                /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 1.1:  PullFlag: ${PullFlag} Pullcount: ${PullCount} Name:  ${PullMobName} MobID: ${PullMob} MobDistance: ${PullMobDistance} MaxRadius: ${MaxRadius} PullRange: ${PullRange} \agLine#: ${Macro.CurLine}
                /varset PullMobValid 0
                /if (${PullMob}) {
                    /call PullValidate ${PullMob} ${PullFlag}
                   /if (${DebugPull}) /echo \atDEBUGPULL ${i}.${PullMob} Macro.Return ${Macro.Return} \agLine#: ${Macro.CurLine}
                    /if (${Macro.Return}) { 
                        /varset PullMobValid 1
                        /varset ChainPullTemp ${PullMob}
                    }
                }
            |/if (${PullMobValid}) /goto :FoundMob
            /if (${PullMobValid}) /return ${PullMob}
            /next i
            /varset ChainPullTemp 0
            /varset PullMob 0
            |/varset PullMobDistance 0
        } else {
           /varset PullMob 0
           /varset PullMobValid 0
           /varset ChainPullTemp 0
           |/varset PullMobDistance 0
        }
        :FoundMob
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Name: ${Spawn[${PullMob}].CleanName} MobID: ${PullMob} Valid: ${PullMobValid} PullCount: ${PullCount} \agLine#: ${Macro.CurLine}
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Leave \agLine#: ${Macro.CurLine}
    /return ${PullMob}
| -----------------------------------------------------------------------------------------------------------
| SUB: PullCheck PullMob is Mob ID of mob to pull.
| -----------------------------------------------------------------------------------------------------------
    Sub PullCheck
        /if (${DebugPull}) /echo \atDEBUGPULL PullCheck Enter ${PullMob} \agLine#: ${Macro.CurLine}
        /if (${DebugPull}) /echo \atDEBUGPULL PullCheck: 1.0: Name: ${Spawn[${PullMob}].CleanName} MobID: ${PullMob} ${PullMoveUse} \agLine#: ${Macro.CurLine}
        /if (${ChainPull}==2) /varset ChainPull 1
        /if (${PullMob} && ${Select[${PullMoveUse},los,nav]}>=1 && (${Spawn[${PullMob}].Distance3D}<=360 || ${Spawn[${PullMob}].LineOfSight})) {
            /target id ${PullMob}
            /delay 20 ${Target.ID}==${PullMob}
        }
        |/if (${DebugPull}) /echo \atDEBUGPULL PullCheck: 2.0: MobID: ${PullMob} \agLine#: ${Macro.CurLine}
        /if (${PullMob} && ${Spawn[${PullMob}].ID}) {
            /varset Pulling 1
            | Advpath skill validate mob
            /if (${PullMob} && ${PullMoveUse.Equal[advpath]}) {
                /varset MyTargetID ${PullMob}
                /varset MyTargetName ${Spawn[${PullMob}].CleanName}
                /target id ${PullMob}
                /delay 20 ${Target.ID}==${PullMob}
                | Is mob really in range. check for spawn lag
                /if (${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]}>${PullRange}) {
                    /if (${PullMob}) /alert add 1 id ${PullMob}
                    /echo Mob is OOR after targeting. Trying Again. ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]} ${PullRange}
                    /squelch /target clear
                    /varset Pulling 0
                    /return 0
                }
                /call ValidateTarget
            } else /if (${Target.ID} && ${Target.ID}==${PullMob}) {
                /call ValidateTarget
            } else {
               /if (${PullMob} && ${Spawn[${PullMob}].ID}) /call ValidateTarget ${PullMob}
            }
            /if (${DebugPull}) /echo \atDEBUGPULL PullCheck: Target: ${Spawn[${PullMob}].CleanName} Valid: ${ValidTarget} MacReturn ${Macro.Return} \agLine#: ${Macro.CurLine}
            /if (${ValidTarget}==0 || (${Target.ID} && ${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) {
                /if (${PullMob}) /squelch /alert add 1 id ${PullMob}
                /squelch /target clear
                /varset Pulling 0
                /return 0
            }
            /call BroadCast ${IRCOn} ${EQBCOn} t "PULLING-> ${Spawn[${PullMob}].CleanName} <- ID:${PullMob} at ${Int[${Math.Distance[${Spawn[${PullMob}].Y},${Spawn[${PullMob}].X}:${CampYLoc},${CampXLoc}]}]} feet."
            /varset MyTargetID ${PullMob}
            /varset MyTargetName ${Spawn[${PullMob}].CleanName}
            /if (${Pulling} && ${MyTargetID}) {
                /if (${PullWith.Equal[Pet]} && (${Me.Pet.Stance.NotEqual[FOLLOW]})) /pet follow  
                /if (${Target.ID} && ${Target.ID}!=${PullMob}) {
                   /if (${Me.Combat}) /attack off
                   /squelch /target clear
                }
                /call Pull
                /if (${ChainPull} && ${ChainPullPause.NotEqual[0]}) /varset ChainPullTimer2 ${Math.Calc[${ChainPullPause.Arg[2,"|"]}+1]}m
                /return 0
            }
        }
        /if (!${PullMob}) {
            /varcalc FailCounter ${FailCounter}+1
            /if (${DebugPull}) /echo \atDEBUGPULL PullCheck: No Valid Target in Range ${MaxRadius} - ${FailCounter} Time(s) \agLine#: ${Macro.CurLine}
            /if (${FailCounter}>=${FailMax}) {
                /call AlertClearList 1 PullCheck
                /varset FailCounter 0
                /varset PullAlertTimer 0
                /if (${PullWait}) {
                    /call BroadCast ${IRCOn} ${EQBCOn} t "PULLING-> Waiting ${PullWait} seconds for mobs to respawn."
                    /call PullDelay ${PullWait}
                }
                /if (${Select[${Role},hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    /if (${DebugPull}) /echo \atDEBUGPULL PullCheck Returning hunter to camp \agLine#: ${Macro.CurLine}
                    /varset ReturnToCamp 1
                    /echo ${Role}: There are no mobs within ${MaxRadius} trying to return to camp.
                    /call DoWeMove 0 pullcheck
                }    
                /return 0
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullCheck:  Leave \agLine#: ${Macro.CurLine}
    /return 0    
| -------------------------------------------------------------------------------------
| SUB: PullDelay
| -------------------------------------------------------------------------------------
    Sub PullDelay(int TimerAmount)
        /if (${DebugPull}) /echo PullDelay ${TimerAmount} Enter \agLine#: ${Macro.CurLine}
        /declare PDTimer timer local ${TimerAmount}s
        /varset Pulling 0
        :WaitForTimer
            /doevents
            /call CheckForCombat 0 PullDelay
            /delay 2
            /if (${PDTimer}) /goto :WaitForTimer
        /if (${DebugPull}) /echo PullDelay Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: PullValidate
| ----------------------------------------------------------------------------
    Sub PullValidate(PVPullMob, int PFlag)
        /declare j int local
        /declare skipFlag int local 0
        /if (!${MobsToPull.Find[All for all]} && ${MobsToPull.NotEqual[All]}) {
            /for j 1 to 25
                /if (${DebugPull} && ${MobsToPull.Arg[${j},,].Length}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${j} PullList ${Spawn[id ${PVPullMob}].CleanName}/${MobsToPull.Arg[${j},,]} ${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]} \agLine#: ${Macro.CurLine}
                /if (${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]}) {
                    /varset skipFlag 1
                    /break
                }
            /next j
            /if (!${skipFlag}) {
                /if (${DebugPull}) /echo \atDEBUGPULL PullValidate ${Spawn[id ${PVPullMob}].CleanName} NOT on MobsToPull List \agLine#: ${Macro.CurLine}
                /return 0
            }
        }
        | If mob found on ignore list
        /if (${MobsToIgnore.Find[${Spawn[${PVPullMob}].CleanName}]}) /return 0
        
        /if (${DebugPull}) /echo \atDEBUGPULL PullValidate Pulling: ${Spawn[id ${PVPullMob}].CleanName} \agLine#: ${Macro.CurLine}
        | Check spawn for out of range - macro start point as epicEnter
        /if (${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${Spawn[id ${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Out of Range \agLine#: ${Macro.CurLine}
            /return 0
        }
        | Check spawn path exists mq2nav
        /if (${PullMoveUse.Equal[nav]}) {
            /if (!${Navigation.PathExists[id ${Spawn[${PVPullMob}].ID}]}) {
                /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} MQ2Nav path does not exist. \agLine#: ${Macro.CurLine}
                /return 0
            }
        }
        | Check spawn for eye of zomm/tallon ${SpawnCount[pc ${PVPullMob.Right[${Math.Calc[${PVPullMob.Length}-7]}]}]}
        /if (${Spawn[${PVPullMob}].CleanName.Find[Eye of]} && ${SpawnCount[pc ${Spawn[${PVPullMob}].CleanName.Right[${Math.Calc[${Spawn[${PVPullMob}].CleanName.Length}-7]}]}]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Eye of Zomm/Tallon \agLine#: ${Macro.CurLine}
                /return 0
        }
        | Check spawn for line of sight - no mq2nav
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${PVPullMob}].LineOfSight} && ${PullMoveUse.Equal[los]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No line of sight \agLine#: ${Macro.CurLine}
                /return 0
        }
        | Check spawn for Level Range
        /if (${Spawn[${PVPullMob}].Level}<${PullMin} || ${Spawn[${PVPullMob}].Level}>${PullMax}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].Level} invalid target Reason: Invalid NPC Level \agLine#: ${Macro.CurLine}
            /return 0
        }
        | Check if any PC/toon is near the mob
        /if (${SpawnCount[loc ${Spawn[${PVPullMob}].X} ${Spawn[${PVPullMob}].Y} radius 15 pc]}>=1 && ${Pulling} && ${Math.Distance[${Spawn[${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${Me.Y},${Me.X}]}>=16) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: PCs near mob \agLine#: ${Macro.CurLine} \agLine#: ${Macro.CurLine}
                /return 0
        }
        | Check spawn for 100% health
        /if (${Spawn[${PVPullMob}].PctHPs}<=99) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Mob not 100% health \agLine#: ${Macro.CurLine} \agLine#: ${Macro.CurLine}
            | If chain pulling then target mob to update server.
            /if (${PFlag} && ${Spawn[${PVPullMob}].Distance}<=360 && ${Target.ID}!=${PVPullMob}) {
                /Echo Mob not at 100% HPs Double checking for server lag PFlag: ${PFlag} PVPullMob: ${PVPullMob} - ${Spawn[${PVPullMob}].CleanName} MobCount: ${MobCount} 
                /target id ${Spawn[${PVPullMob}].ID} 
                /delay 20 ${Target.ID}==${PVPullMob} && ${Target.BuffsPopulated}==TRUE
                /if (${Target.PctHPs}>99) {
                    /return 1
                } else /squelch /alert add 1 id ${PVPullMob}
            }
            /return 0                
        }
        /if (${Spawn[${PVPullMob}].Named} && ((${PFlag} && ${MobCount} && ${Me.XTarget[${XTSlot}].ID}) || !${PFlag})) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No Pull Names with Mobs in Camp \agLine#: ${Macro.CurLine}
            /return 0
        }
    /return 1    
|-------------------------------------------------------------------------------- 
|SUB: CheckRampPets - Writtten by Trehuggindruid for KissAssist
|-------------------------------------------------------------------------------- 
    Sub CheckRampPets
        /declare i int local
        /if (!${Me.CombatState.Equal[COMBAT]}) {
            | Wait for rampage pets to poof before pulling.
            /for i 0 to 20
                /if (${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /echo +++ My rampage pet is up: (${Spawn[${Me.CleanName}`s_pet0${i}]}|${Spawn[${Me.CleanName}`s_pet0${i}].ID}), HOLDING . . .
                :WaitOnRampagePets
                /delay 1
                /if (!${Me.CombatState.Equal[COMBAT]} && ${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /goto :WaitOnRampagePets
            /next i
        }
    /return    
| -------------------------------------------------------------------------------------
| SUB: Pull
| -------------------------------------------------------------------------------------
    Sub Pull
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}==0) /return
        /if (!${Pulling}) /return
        /if (${DPSPaused}) /return
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Enter \agLine#: ${Macro.CurLine}
        /declare PullAttempts int local 0 
        /declare StuckCount int local 0 
        /declare PullDist float local ${PullRange}
        /declare WasTwistingPull bool local ${Twist}
        /declare AdvpathPaused int local 0
        /declare WPCurrent int local 0
        /declare AdvpathDirection string local
        /declare AutoFireOff int local ${AutoFireOn}
        /declare X1 int local
        /declare Y1 int local
        /declare X2 int local
        /declare Y2 int local
        /declare AdjustHeadingTimer timer local 0
        /declare WasInRange int local 0
        /varset Pulled 0
        /varset PullTooFar 0
        /varset PullTimer 50
        /varset CantHit 0
        /varset ToClose 0
        /if (${GroupWatchOn}) /call GroupWatch
        /if (${DebugPull}) /echo \atDEBUGPULL Pull: PullWith:${PullWith} PullDist: ${PullDist} \agLine#: ${Macro.CurLine}
        | Set autofire setting off during pulls if not using ranged item to pull
        /if (${AutoFireOff}) /varset AutoFireOn 0
        /if (${IAmABard} && !${PullTwistOn} && ${WasTwistingPull}) { 
            /squelch /twist off
            /stopsong
        }
        /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand        
        /if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}!=${Me.ID}) {
            /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}>${CampRadius}) /call PullModeToggle TurnOn
        }
        /varset BeginMobID ${Me.XTarget[${XTSlot}].ID}
       :PullAgain
        /doevents 
        /if (!${DragCorpse}) {
            /call GrabCorpse
            /if (${DragCorpse}) {
                /goto :DonePulling
            }
        }
        /if (${DPSPaused}) /return  
        | vars used to determine if we are stuck
            /varset X1 ${Int[${Me.X}]}
            /varset Y1 ${Int[${Me.Y}]}            
            /if (${PullAggroTargetID}) {
                /if (${DebugPull}) /echo Pulling 1.1 \agLine#: ${Macro.CurLine}
                /varset Pulled 1
                /varset MyTargetID ${AggroTargetID}
                /varset MyTargetName ${Spawn[${AggroTargetID}].CleanName}
                /call StopMoving
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Aggro detected \agLine#: ${Macro.CurLine}
                /goto :DonePulling
            }
            | Exit pull and reset if timed out or wandered too far from camp
            /if (${DebugPull}) /echo Pulling 1.2 PullTimer: ${PullTimer} Distance: ${Math.Distance[${CampYLoc},${CampXLoc}]} Distance3D: ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} MaxRadius: ${Math.Calc[${MaxRadius}*.90]} PullAttempts: ${PullAttempts} MyTargetID: ${Spawn[${MyTargetID}].ID}  Target LOS: ${Spawn[${MyTargetID}].LineOfSight} \agLine#: ${Macro.CurLine}
            /if (${PullTimer}==0 || (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} >= ${Math.Calc[${MaxRadius}*.90]}) || (${PullAttempts}>=7 && !${Spawn[${MyTargetID}].LineOfSight} && !${Select[${Role},hunter,hunterpettank]}) || !${Spawn[${MyTargetID}].ID} || ${PullAttempts}>=100) {
                /if (${MyTargetID}) /squelch /alert add 1 id ${MyTargetID}
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: /echo Adding ${Spawn[${MyTargetID}].CleanName} ID: ${MyTargetID} to temp ignore list \agLine#: ${Macro.CurLine}
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: Done Pulling-Timer expired, Mob unreachable or exceeded max pull radius. \agLine#: ${Macro.CurLine}
                /call BackToCampReset
                /if (${Macro.Return}) /return
            }
            /if (((${AggroTargetID} && !${ChainPull}) || (${Me.XTarget[${XTSlot2}].ID} && ${ChainPull})) && ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                /echo Looks like mobs in camp aborting pull.
                /call PullReset
                /if (!${ChainPull}) /call CheckForCombat 0 Pull
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Mobs in camp detected \agLine#: ${Macro.CurLine}
                /return
            }
            /if (${PullWith.Equal[Ranged]}) {
                /call PullWithRanged ${PullDist} 0
            }
            | - Filter to prevent pulling until AA/Disc/Spell/Item is ready.
            /if (${DebugPull}) /echo \atDEBUGPULL Check Ability: ${AggroTargetID} ${PullAggroTargetID} ${ChainPull} ${Select[${PullWith},Melee,Pet,Ranged]} ${Me.SpellReady[${PullWith}]} ${Me.AltAbilityReady[${PullWith}]} ${Me.CombatAbilityReady[${PullWith}]} ${Me.ItemReady[${PullWith}]} ${PullWith} ${PullWith.Equal[Ranged]} ${Me.RangedReady} \agLine#: ${Macro.CurLine}
            /if (${PullTimer} && (!${AggroTargetID} && !${ChainPull}) && ((!${Select[${PullWith},Melee,Pet,Ranged]} && !${Select[TRUE,${Me.SpellReady[${PullWith}]},${Me.AltAbilityReady[${PullWith}]},${Me.CombatAbilityReady[${PullWith}]},${Me.ItemReady[${PullWith}]}]}) || (${PullWith.Equal[Ranged]} && !${Me.RangedReady}))) /goto :PullAgain
            /if (${DebugPull}) /echo \atDEBUGPULL Pull Starting \agLine#: ${Macro.CurLine}
            /varset PullAttempts 0
            | Set group role puller to adjust for merc running up while pulling if soloing
            /if (${Group}==1 && !${Group.Puller.Name.Equal[${Me}]} && ${Select[${Role},puller]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) /call AssignGroupRole set "${Me.CleanName}" 3
|------------------------------------------------------------------------Pull Begin Move-------------------------------------------------------------------------------------------|            
            /if ((${Spawn[${MyTargetID}].Distance3D}>${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}<${MaxRadius}) {
                :WeThereYet
|------------------------------------------------------------------------MQ2AdvPath-------------------------------------------------------------------------------------------|                
                | Advpath pull does not use max pull radius. It uses pullwith radius
                /if (${PullMoveUse.Equal[advpath]}) {
                    /call PullUsingAdvPath ${MyTargetID} ${PullDist}
                    /if (!${MyTargetID}) /return
|------------------------------------------------------------------------MQ2Nav-------------------------------------------------------------------------------------------|
                } else /if (${PullMoveUse.Equal[nav]} && !${Select[${Role},hunter,hunterpettank]}) {
                    /call PullUsingNav ${MyTargetID} ${PullDist} 
                    /if (!${MyTargetID}) /return
|------------------------------------------------------------------------LOS-------------------------------------------------------------------------------------------|
                | We are pulling by LOS.  
                } else /if (${Spawn[${MyTargetID}].LineOfSight}) {
                    /if (${Me.FeetWet}) {
                        |/echo ${PullDist} ${Math.Calc[${Spawn[${MyTargetID}].Distance3D}-${Spawn[${MyTargetID}].Distance}]}
                        /if (${X2}==0) /varcalc PullDist ${PullDist}-(${Spawn[${MyTargetID}].Distance3D}-${Spawn[${MyTargetID}].Distance})
                        /moveto id ${MyTargetID} uw mdist ${PullDist}
                    } else {
                        /moveto id ${MyTargetID} mdist ${PullDist}
                    }
                    /delay 10
                    /varset X2 ${Int[${Me.X}]}
                    /varset Y2 ${Int[${Me.Y}]}            
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull LOS ${Spawn[${MyTargetID}].LineOfSight} ${PullDist} \agLine#: ${Macro.CurLine}
|------------------------------------------------------------------------Mob OOR Return to Camp-------------------------------------------------------------------------------------------|                    
                } else {
                    /if (${X2}!=0) { 
                        /if (${Math.Distance[${Me.Y},${Me.X}:${Y2},${X2}]}>200) {
                            /echo Mob is no Longer in LOS. Returning to Camp.
                            /if (${MyTargetID}) /squelch /alert add 1 id ${MyTargetID}
                            /if (${MoveTo.Moving}) /moveto off
                            /call BackToCampReset
                            /if (${Macro.Return}) /return
                        } else /if ((!${Me.Moving} || !${MoveTo.Moving}) && ${PullDist}<${Spawn[${MyTargetID}].Distance}) {
                            /if (${Me.FeetWet}) {
                                /moveto id ${MyTargetID} uw mdist ${PullDist}
                            } else {
                                /moveto id ${MyTargetID} mdist ${PullDist}
                            }
                            /delay 10
                        }
                    }
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull NO-LOS ${Spawn[${MyTargetID}].LineOfSight} ${Spawn[${MyTargetID}].Distance3D} ${PullDist} \agLine#: ${Macro.CurLine}
                }
            }
|------------------------------------------------------------------------End Pull Move-------------------------------------------------------------------------------------------|            
            /if (${Spawn[${MyTargetID}].Distance3D}<=${PullDist}&& ${Target.FeetWet}==${Me.FeetWet}) /varset WasInRange 1
            /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}>${MaxRadius}) {
                /if (!${PullIgnore1.Find[|${MyTargetID}]} && ${MyTargetID}>0) {
                    /squelch /alert add 1 id ${MyTargetID}
                    /varset PullIgnore1 ${PullIgnore1}|${MyTargetID}
                    /echo Added ${MyTargetID} to ignor pull list. ${PullIgnore1}
                }
            }
            /varset CantSee 0
            /doevents
            /if (${Pulled}) /goto :DonePulling
            |Checking to see if you are far from camp to try and fix the exceed to far from camp check.
            /if ((${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]}>=${Math.Calc[${MaxRadius}*.90]})) /goto :PullAgain
            /if (${DPSPaused}) /return 
            | Extending PullTimer if moving closer or target moving && !${Select[${Role},hunter]})
            /if (${PullMoveUse.Equal[nav]}) {
                /if ((${Navigation.Active} || ${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed}>25 && ${Spawn[${MyTargetID}].Distance3D}>${PullRange}))) /varcalc PullTimer ${PullTimer}+50
            } else /if (${PullMoveUse.Equal[los]} && !${Select[${Role},hunter,hunterpettank]}) {
                /if ((${Me.Moving} || ${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed}>25 && ${Spawn[${MyTargetID}].Distance3D}>${PullRange}))) /varcalc PullTimer ${PullTimer}+50
            
            }
            | Pull counter used to in conjunction with 1s delay for timing
            /varcalc PullAttempts ${PullAttempts}+1
            | Try and pull again after 7 seconds or 3 seconds if target is moving
            /if (${Select[${PullMoveUse},los,nav]}>=1) {
                /if (${PullAttempts}>=7) {
                    | Make range smaller to creep closer to mob if not los
                    /if (${Spawn[${MyTargetID}].Distance3D}<=${PullDist} && !${Spawn[${MyTargetID}].LineOfSight}) /varcalc PullDist ${PullDist}*.6
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull PullDist: ${PullDist} - PullLoops: ${PullAttempts} LineOfSight: ${Spawn[${MyTargetID}].LineOfSight} \agLine#: ${Macro.CurLine}
                    /goto :PullAgain
                } else /if (${PullAttempts}>=3 && ${Spawn[${MyTargetID}].Speed}>25 && ${WasInRange} && ${Spawn[${MyTargetID}].Distance3D}>${PullDist}) {
                    | Make range smaller to creep closer to mob if Mob is Moving
                    /varcalc PullDist ${PullDist}*.6
                    /varset WasInRange 0
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull PullDist: ${PullDist}*.6 - PullLoops: ${PullAttempts} \agLine#: ${Macro.CurLine}
                    /goto :PullAgain
                }
            }
            | 1s timer used in conjunction with PullAttempts to control pulling
            /delay 10
|------------------------------------------------------------------------Are We Stuck-------------------------------------------------------------------------------------------|                       
        | - Check to see if we are stuck
        /if ((${Int[${Me.X}]}==${X1}) && (${Int[${Me.Y}]}==${Y1})) {
            /varcalc StuckCount (${StuckCount})+1
            /if (${StuckCount}>=2) {
                /if (${IAmDead} || ${Me.Hovering}) {
                    /call Stopmoving
                    /return
                } else {
                    /call Stuck
                } 
            }
            /if (${StuckCount}>=7 && !${PullAggroTargetID}) {
                /echo I am stuck aborting pull
                /if (${MyTargetID}) /squelch /alert add 1 id ${MyTargetID}
                /call StopMoving
                /call BackToCampReset
                /if (${Macro.Return}) /return            
            }
        }
|------------------------------------------------------------------------Are We Stuck End-------------------------------------------------------------------------------------------|                        
        /if (${DebugPull})  /echo \atDEBUGPULL Pull Loop Count: ${PullAttempts} ${Me.Moving} ${MoveTo.Moving} ${Me.Speed} ${Spawn[${MyTargetID}].Distance3D} ${PullRange} \agLine#: ${Macro.CurLine}
        | Not using advpath
        /if (${Select[${PullMoveUse},los,nav]}>=1) {
            | Distance loop check until mob in range to pull
            /if ((${Spawn[${MyTargetID}].Distance3D}>${PullRange} || !${Spawn[${MyTargetID}].LineOfSight} || ${Target.FeetWet}!=${Me.FeetWet}) && !${PullAggroTargetID}) {
                /if (!${Me.Moving} || ${WasInRange}) /varcalc PullDist ${PullDist}*.8 
                /goto :WeThereYet
            }
            | If mob moves out of line of sight during pull try moveto mob again
            /if (!${Spawn[${MyTargetID}].LineOfSight} && !${Select[${Role},hunter,hunterpettank]} && ${PullTimer}) {
                /varcalc PullDist ${PullDist}*.8
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Decrease pull distance to ${PullDist} \agLine#: ${Macro.CurLine}
                /goto :PullAgain
            }
            /if (${PullAggroTargetID}) /goto :PullAgain
        }
        /if (${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance3D}<${PullRange} && ${Target.FeetWet}==${Me.FeetWet} && !${PullAggroTargetID}) {
            /if (${PullMoveUse.Equal[advpath]}) /varset WasInRange 1
            /call StopMoving
            | Target mob before Aggroing
            /target id ${MyTargetID}
            /delay 20 ${Target.ID}==${MyTargetID}
            | Validate target one more time before pulling
            /call ValidateTarget
            /if (${ValidTarget}==0) {
                /if (${Target.ID}) /squelch /alert add 1 id ${Target.ID}
                /squelch /target clear
                /echo Aborting Pull! Target invalid now! Reason:${Macro.Return}
                /call StopMoving
                /call BackToCampReset
                /if (${Macro.Return}) /return
            }
            /if (${PullWith.Equal[Ranged]} && ${Spawn[${MyTargetID}].Distance3D}<30) /varset ToClose 1
|------------------------------------------------------------------------Pull with Melee-------------------------------------------------------------------------------------------|            
            | Handle pulling with Melee setting
            /if (${PullWith.Equal[Melee]} || (${PullWithAlt.Equal[Melee]} && ${ToClose})) {
                /call PullWithMelee
|------------------------------------------------------------------------Pull with Ranged-------------------------------------------------------------------------------------------|                         
            | Pull with ranged
            } else /if (${PullWith.Equal[Ranged]} && !${ToClose}) {
                /call PullWithRanged ${PullDist} 1
                /if (${Macro.Return}>=1) /varset PullDist ${Int[${Macro.Return}]}
|------------------------------------------------------------------------Pull with Pet-------------------------------------------------------------------------------------------|                                 
            | Pull with pet
            } else /if (${PullWith.Equal[Pet]}) {                
                /call PullWithPet
|------------------------------------------------------------------------Pull with Cast-------------------------------------------------------------------------------------------|                          
            | Pull with cast
            } else {
                /call PullWithCast ${PullDist}
                /if (${Macro.Return}>=1) {
                    /varset PullDist ${Int[${Macro.Return}]}
                    /goto :PullAgain
                }
            }
|------------------------------------------------------------------------Pull with End-------------------------------------------------------------------------------------------|                      
            |- Toggle puller mode off if option enabled.
            /if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}==${Me.ID}) /call PullModeToggle TurnOff            
        } else /if (${PullAggroTargetID}) {
            | The else /if fixes when puller stalls because puller grabs aggro with out getting to pull.
            /varset Pulled 1
        }
        | If pull failed start over while timer > 0
        /if (${Select[${PullMoveUse},los,nav]}>=1 && !${Pulled}) /goto :PullAgain
        :DonePulling
        | reset mq2moveutils mdist back to 10 from pull distance to ensure correct movement 
        /moveto mdist 10
        /if (${PullWith.Equal[Ranged]}) {
            /call PullWithRanged ${PullDist} 2
        }
        /varset Pulling 0
        | Turn autofire back on
        /if (${AutoFireOff}) {
            /if (${DebugPull}) /echo \atDEBUGPULL Pull AutoFire on \agLine#: ${Macro.CurLine}
            /varset AutoFireOff 0
            /varset AutoFireOn 1
        }
        /if (${Select[${Role},hunter,hunterpettank]} && ${MyTargetID}) {
            /call PullHunter
            /return
        }
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Done Pulling ${ReturnToCamp} ${Pulled} \agLine#: ${Macro.CurLine}
        /if (${ReturnToCamp}) {
            /if (${Pulled}) {
                /call WaitForMob
                /varset Pulled 0
            } else {
                /call DoWeMove 1 pull
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Leave Mob ID:${Spawn[${MyTargetID}].ID} \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------------
| SUB: BacktoCampReset
|--------------------------------------------------------------------------------------
    Sub BacktoCampReset  
        /if (${DebugPull}) /echo \atDEBUGPULL BacktoCampReset: Enter \agLine#: ${Macro.CurLine}
        /if (${ReturnToCamp}) {
            /call DoWeMove 0 backtocampreset
        }
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
            /call PullReset
            /return TRUE
        }
        /if (${DebugPull}) /echo \atDEBUGPULL BacktoCampReset: Leave \agLine#: ${Macro.CurLine}
    /return 0
|--------------------------------------------------------------------------------------
| SUB: Stop Moving
|--------------------------------------------------------------------------------------
    Sub StopMoving
        /if (${DebugPull}) /echo \atDEBUGPULL StopMoving: Enter \agLine#: ${Macro.CurLine}
        /if (${MoveTo.Moving}) /moveto off
        /if (${PullMoveUse.Equal[nav]}) {
            /if (${Navigation.Active}) /nav stop
        }
        /if (${PullMoveUse.Equal[advpath]}) {
            /if (${AdvPath.State}) /play off
        }
        /delay 30 !${Me.Moving}
        /if (${DebugPull}) /echo \atDEBUGPULL StopMoving: Leave \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------------
| SUB: Pull with Melee
| -------------------------------------------------------------------------------------
    Sub PullWithMelee
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithMelee: Enter \agLine#: ${Macro.CurLine}
        /if (!${Select[${Role},hunter,hunterpettank]}) {
            | Turn off mq2melee function so puller and pullertank doesn't attack mob on pull
            /if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=0
            :AttackAgain
                /moveto id ${MyTargetID} mdist 15
                /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                /look 0
                /if (${Target.Distance}<20) /attack on
                /if (${PullMeleeStick} && !${PullAggroTargetID}) /stick id ${MyTargetID} 70%
                /delay 5
            /if (!${PullAggroTargetID} && ${Target.PctHPs}==100) /goto :AttackAgain
            | Turn off combat so puller returns to camp. You mean run like hell.
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]}) {
                    /attack off
                    /if (${Stick.Active}) /stick off
                    /squelch /target clear
                |/echo ${Me.Combat} ${PullAggroTargetID} ${Target.PctHPs}
                | Turn on mq2melee function back on after pull
                /if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=1
            }
        }
        /varset Pulled 1
        /varset ToClose 0
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithMelee: Leave \agLine#: ${Macro.CurLine}
    /return 
|-------------------------------------------------------------------------------------
| SUB: Pull With Ranged
| -------------------------------------------------------------------------------------
    Sub PullWithRanged(int PullDistRanged,int RSwitch)
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithRanged: Enter \agLine#: ${Macro.CurLine}
        /declare TryCount int local 0
        /declare AmmoCount int local 0
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithRanged: Ranged \agLine#: ${Macro.CurLine}
        | Cursor check sometimes summoned items get stuck on cursor.
        /if (${Cursor.ID}) /autoinventory
        /if (${RSwitch}==0) {
            /if (${OrigRanged.NotEqual[${PullItem}]} && ${OrigRanged.NotEqual[null]} && !${RangedSwitch}) {
                |/call CheckCasting 50
                /exchange "${PullItem}" ranged
                /varset RangedSwitch 1
                /delay 10
            }
            /if (${TempAmmo.NotEqual[null]} && ${TempAmmo.NotEqual[${PullAmmo}]} && !${AmmoSwitch}) {
                |/call CheckCasting 50
                /exchange "${PullAmmo}" ammo
                /delay 10
                /if (${TempAmmo.NotEqual[${PullAmmo}]}) /varset AmmoSwitch 1
            }
        }
        /if (${RSwitch}==1) {
            :RangedAgain
                /varcalc TryCount ${TryCount}+1
                /doevents
                /if (${DPSPaused}) /return 
                /if (${PullAggroTargetID}) {
                    /varset Pulled 1
                    /return
                }
                /if (${CantSee}) {
                    /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                    /delay 10
                    /varset CantSee 0
                    /if (${DebugPull}) /echo Could Not see Target. Trying Again. \agLine#: ${Macro.CurLine}
                }
                | Mod for puller to turn back to camp after /range this saves on the puller turning AFTER mob is aggroed  and turns facing camp while waiting for mob to aggro.
                /if (${Me.Combat}) {
                    /Attack off
                    /delay 20 !${Me.Combat}
                }
                /if (${Stick.Active}) /stick off
                /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                /look 0
                /varset AmmoCount ${FindItemCount[=${PullAmmo}]}
                /delay 30 ${Me.Heading.ShortName.Equal[${Target.HeadingTo}]}
                /if (${Target.ID}==${MyTargetID} && ${Target.Distance3D}>=30) {
                    /while (${AmmoCount}==${FindItemCount[=${PullAmmo}]} && !${PullAggroTargetID} && ${Target.Distance3D}>=30 && ${Target.LineOfSight} && ${Target.FeetWet}==${Me.FeetWet}) {
                        /range
                        /doevents TooClose
                        /if (${ToClose}) {
                            /varset PullDistRanged 15
                            /return ${PullDistRanged}
                        }
                        /doevents CantHit
                        /if (${CantHit}) {
                            /varset CantHit 0
                            /varcalc PullDistRanged ${PullDistRanged}*.8
                            /return ${PullDistRanged}
                        }
                        /doevents TooFar
                        /if (${PullTooFar}) {
                            /varset PullTooFar 0
                            /varcalc PullDistRanged ${PullDistRanged}*.8
                            /return ${PullDistRanged}
                        }
                    }
                }
                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius}) {
                    /delay 10 ${PullAggroTargetID}
                    /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]} loc ${CampYLoc},${CampXLoc}
                }
                /if (!${PullAggroTargetID}) {
                    /delay ${Math.Calc[1+${Target.Distance}/50].Int}s ${PullAggroTargetID}
                    /varcalc PullTimer ${PullTimer}+10
                }
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: ${PullTimer} !${PullAggroTargetID} ${Target.PctHPs}==100 \agLine#: ${Macro.CurLine}
                /if (${PullTimer} && ${TryCount}<3 && !${PullTooFar} && !${PullAggroTargetID}) /goto :RangedAgain
            /if (${PullAggroTargetID}) {
                /varset Pulled 1
                /return
            }
        }
        /if (${RSwitch}==2) {
            /if (${RangedSwitch} && ${RSwitch}) {
                |/call CheckCasting 50
                /exchange "${OrigRanged}" ranged
                /varset RangedSwitch 0
                /delay 10
            }
            /if (${AmmoSwitch}) {
                |/call CheckCasting
                /if (${Cursor.ID}) /autoinventory
                /exchange "${TempAmmo}" ammo
                /varset AmmoSwitch 0
                /delay 10
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithRanged: Leave \agLine#: ${Macro.CurLine}
    /return
|-------------------------------------------------------------------------------------
| SUB: Pull With Casting
| -------------------------------------------------------------------------------------
    Sub PullWithCast(int PullDistCast)
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithCas:t Enter \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL PullWithCast: Casting to pull mob \agLine#: ${Macro.CurLine}
            /delay 5s !${Me.Moving} || ${PullAggroTargetID}
            /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0                 
            /if (${PullAggroTargetID}) /return ${PullDistCast}
            /if (!${Spawn[${MyTargetID}].LineOfSight}) {
                /varcalc PullDistCast ${PullDistCast}*.8
                /return ${PullDistCast}
            }
            /if (!${Me.Moving}) /call CastWhat "${PullWith}" ${Target.ID} Pull
            /if (${Macro.Return.Equal[CAST_SUCCESS]} || ${Macro.Return.Equal[CAST_RESIST]} || ${PullAggroTargetID}) /varset Pulled 1
            /delay 10 ${PullAggroTargetID}
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithCast: Leave \agLine#: ${Macro.CurLine}
    /return      
|-------------------------------------------------------------------------------------
| SUB: Pull With Pet Written by TreeHuginDruid for RedGuides
| -------------------------------------------------------------------------------------
    Sub PullWithPet
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithPet: Enter \agLine#: ${Macro.CurLine}
        /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
        |- Ensure we are in pull range and pet is following!                              
        /if (${Me.Pet.Stance.NotEqual[FOLLOW]}) /pet follow
        | - Send in pet if I don't have a mob in extended target)               
       :SendInPet
        /echo Pulling with PET now !
        /if (!${PullAggroTargetID}) {
            /pet attack
            /delay 10 ${PullAggroTargetID}
            | Fix for HunterPetTank
            /if (${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Type.NotEqual[corpse]} && !${PullAggroTargetID}) /goto :SendInPet
        }
        | - If I have a extended target, flag as pulled.
        /if (${PullAggroTargetID}) {
            /varset Pulled 1
            /if (${PetHoldOn}) /pet ${PetHold} on
            /pet back off
        } 
        /if (${DebugPull}) /echo \atDEBUGPULL PullWithPet: Leave \agLine#: ${Macro.CurLine}
    /return 
|--------------------------------------------------------------------------------------
| SUB: Pull Hunter
|--------------------------------------------------------------------------------------
    Sub PullHunter
        /if (${DebugPull}) /echo \atDEBUGPULL PullHunter Enter \agLine#: ${Macro.CurLine}
            /if (${PullWith.Equal[Melee]} && ${Target.Moving}) {
                /moveto id ${MyTargetID} mdist 10
                /if (${Target.ID}) /face nolook
                /if (${Me.FeetWet}) {
                    /stick uw ${StickHow} ${StickDistUW} id ${MyTargetID}
                } else {
                    /stick ${StickHow} ${StickDist} id ${MyTargetID}
                }
            }
            /call Combat
            /call CombatReset 0 pullhunter
            /call PullReset
            | Try to return home if exceeding max radius while in ANY hunter mode
            /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${Math.Calc[${MaxRadius}*.95]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullHunter Returning hunter to camp \agLine#: ${Macro.CurLine}
                /echo ${Role}: Reached edge of ${MaxRadius} hunting radius. Trying to return to camp.
                /varset ReturnToCamp 1
                /call DoWeMove 0 pullhunter
            }    
        /if (${DebugPull}) /echo \atDEBUGPULL PullHunter Enter \agLine#: ${Macro.CurLine}
            /return
|-------------------------------------------------------------------------------------
| SUB: Pull Using MQ2Nav
| -------------------------------------------------------------------------------------
    Sub PullUsingNav(int BeginMobNavID,float NavPullDist) 
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingNav Enter \agLine#: ${Macro.CurLine}
        /varset PullTimer 30
        /varset PullNavTimer 3m
        /nav id ${MyTargetID}
        | Timer for /nav to adjust heading when mob is moving
        :DistanceCheck
        /doevents
        /if (!${DragCorpse}) {
            /call GrabCorpse
            /if (${DragCorpse}) {
                /varset PullNavTimer 0
                /return TRUE 
            }
        }
        | Return if in sub for more than 3 min
        /delay 10
        | Corrects heading when mob is moving and your using Navigation.
        /if (${Spawn[${MyTargetID}].Speed}>25) {
            /squelch /nav id ${MyTargetID}
        }
        | Check for Unexpected Aggro
        /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobNavID})) && ${ChainPull})) /return 0
        | Check for being to far from camp.
        |/if (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${Math.Calc[${MaxRadius}*.90]}) {
        /if ((${Math.Distance[${CampYLoc},${CampXLoc}]}>=${Math.Calc[${MaxRadius}*.90]} && ${Spawn[${MyTargetID}].Distance}>${Math.Calc[${MaxRadius}*.10]}) || ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${MaxRadius} || ${PullNavTimer}==0) {
            /if (${Navigation.Active}) /nav stop
            /call BackToCampReset
            /varset PullNavTimer 0
            /return TRUE
        }
        /if (${Me.Moving} && ${Navigation.Active}) /varset PullTimer 30
        /if ((${Spawn[${MyTargetID}].Distance3D}>${NavPullDist} || !${Spawn[${MyTargetID}].LineOfSight} || ${Spawn[${MyTargetID}].FeetWet}!=${Me.FeetWet}) && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull}))) /goto :DistanceCheck
        /if (${Navigation.Active} && ${Spawn[${MyTargetID}].LineOfSight} && ${Spawn[${MyTargetID}].Distance3D}<=${NavPullDist} && ${Target.FeetWet}==${Me.FeetWet} ) {
            /nav stop
            /if (!${Spawn[${MyTargetID}].LineOfSight}) {
                /nav id ${MyTargetID}
                /goto :DistanceCheck
            }
        }
        /varset PullNavTimer 0
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingNav Pulling ${NavPullDist} ${Target.Distance} \agLine#: ${Macro.CurLine}
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingNav Leave \agLine#: ${Macro.CurLine}
    /return 0
|-------------------------------------------------------------------------------------
| SUB: Pull Using AdvPath
| -------------------------------------------------------------------------------------
    Sub PullUsingAdvPath(int BeginMobAPID,float APPullDist)  
            /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath Enter \agLine#: ${Macro.CurLine}
            /if (${MoveTo.Moving}) /moveto off
            /play ${PullPath} nodoor smart normal 
            /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath /play ${PullPath} nodoor smart normal \agLine#: ${Macro.CurLine}
        :RunningThePath 
            /if (${DebugPull}) /delay 5 
            /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath /echo Waypoint: ${AdvPath.NextWaypoint} Target: ${Target.ID} MyTargetID: ${MyTargetID} Aggro: ${AggroTargetID} MobToWPDist: ${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}<${APPullDist} MeToWPDist: ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}>50 WP<NWP: ${AdvPath.NextWaypoint}>=${AdvpathPointNum} \agLine#: ${Macro.CurLine}
            | Do we have aggro?
            /if (${AggroTargetID}) /goto :StopPath
            | Has the mob move out of range from the original way point
            /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}>${APPullDist}) /goto :StopPath
            | Is mob within pull range and LOS
            /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${Me.Y},${Me.X}]}<${APPullDist} && ${Spawn[${MyTargetID}].LineOfSight} && ${Target.FeetWet}==${Me.FeetWet}) /goto :StopPath
            | Stop at our waypoint
            /if (${AdvPath.NextWaypoint}>=${AdvpathPointNum} && ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}<=5) {
                |/varset WPCurrent ${AdvPath.NextWaypoint}
                /goto :StopPath
            }
        /goto :RunningThePath
        :StopPath
        /play off
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath /play ${PullPath} nodoor smart normal \agLine#: ${Macro.CurLine}  
        /if (${DebugPull}) /echo \atDEBUGPULL PullUsingAdvPath Leave ${AdvPath.NextWaypoint} \agLine#: ${Macro.CurLine}        
    /return ${AdvPath.NextWaypoint}
| -------------------------------------------------------------------------------------
| SUB: Wait for Mob
| -------------------------------------------------------------------------------------
    Sub WaitForMob
        /if (${Select[${Role},hunter,hunterpettank]} || ${DPSPaused}) /return
        /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Enter \agLine#: ${Macro.CurLine}
        /varset WaitTimer 45s
        /if (${Pulled}) {
            /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Waiting for mob \agLine#: ${Macro.CurLine}
            /call DoWeMove 1 waitformob
            /if (${ChainPull}) /varset LastMobPullID ${Target.ID}
            /declare FaceTimer timer local 0
            /if (${InvSlot[ranged].Item.Name.NotEqual[${OrigRanged}]} && ${OrigRanged.NotEqual[null]}) {
                |/call CheckCasting 50
                /exchange "${OrigRanged}" ranged
            }
            |When you target a mob and another mob aggros you, but your target never gets aggroed.
            /if (${PullAggroTargetID} && ${Target.ID}!=${PullAggroTargetID} && ${Target.AggroHolder.ID}==0) {
                /target id ${AggroTargetID}
            }
            :WaitForMob
                /if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID})) /face ${If[${FaceMobOn}==1,fast nolook,nolook]}
                /doevents
                /call MobRadar ${CampRadius} WaitForMob
                | If NOT chain pulling and multiple mobs in camp. /return
                /if (${MobCount}>=2 && !${ChainPull}) {
                    /call PullReset
                    /return
                } 
                /if (${DebugPull}) /echo \atDEBUGPULL - WaitTimer: ${WaitTimer} Target Distance: ${Target.Distance} Mob Dist from Camp: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>=${CampRadius} Mob Dist from tank: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Me.Y},${Me.X}]}>=20 \agLine#: ${Macro.CurLine}
                | if target lost somehow add to ignore list and continue pulls
                /if ((!${AggroTargetID} && !${ChainPull}) || ${WaitTimer}==0) {
                    /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob /return no AggroTargetID \agLine#: ${Macro.CurLine}
                    /if (${Target.ID}) /squelch /alert add 1 id ${Target.ID}
                    /call PullReset 
                    /return
                }
                /varset FaceTimer 1s
                /delay 1s
                | I am PULLER with PET TANK            
                /if (${Select[${Role},pullerpettank]}) {
                    |- Make sure pet is returning to camp with me.
                    /if (${Me.Pet.ID} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${Me.Y},${Me.X}]}>20) {
                        /pet back off
                        /delay 10
                        /pet follow
                    } 
                    | If the mob is within pet attack distance from camp send the pet in to attack
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${PetAttackRange}) /goto :WaitForMob
                    /if (!${PetAttack}) /call CombatPet
                }
                | I am PULLER TANK
                /if (${Select[${Role},pullertank]}) {
                    | Wait in camp for mob if timer active and mob is outside of camp radius and mob is farther away from tank than 20 feet
                    /if (${WaitTimer} && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>${MeleeDistance}) /goto :WaitForMob
                }
                | If I am PULLER and NOT chain pulling
                /if (${Select[${Role},puller]} && !${ChainPull}) {
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${CampRadius} && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20) /goto :WaitForMob
                    /if (${MercOn} && !${MercAssisting} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
                }
                | If I am PULLER and chain pulling
                /if (${Select[${Role},puller]} && ${ChainPull}) {
                    | Leave if multi mobs or no mobs 
                    /if (${MobCount}>=2 || !${MyTargetID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot2}].ID})) { 
                        /call PullReset
                        /return
                    }
                    /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20 && ${Target.ID}==${Spawn[${MyTargetID}].ID} && ${Me.TargetOfTarget.ID}==${Me.ID}) /goto :WaitForMob                 
                }
        }
        /if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Spawn[${MyTargetID}].Distance}<=${MeleeDistance}) /call AssignGroupRole unset "${Me.CleanName}" 3            
        /if (${MyTargetID} && !${PullAggroTargetID}) /call PullReset
        /if (${IAmABard}) /call DoBardStuff
        /varset WaitTimer 0
        /call MercsDoWhat
        /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Reset Pull variables
| -------------------------------------------------------------------------------------
    Sub PullReset
        /if (${DebugPull}) /echo \atDEBUGPULL PullReset Enter \agLine#: ${Macro.CurLine}
        /moveto mdist 10
        /varset Pulling 0
        /varset Pulled 0
        /varset MyTargetID 0
        /varset MyTargetName
        /varset ToClose 0
        /attack off
        /if (${MoveTo.Moving}) /moveto off
        /if (${PullMoveUse.Equal[nav]}) {
            /if (${Navigation.Active}) /nav stop
        }
        /varset WaitTimer 0
        /varset DragCorpse 0
        /squelch /target clear
        /if (${DebugPull}) /echo \atDEBUGPULL PullReset Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullModeToggle
| -------------------------------------------------------------------------------------
    Sub PullModeToggle(ToggleState)
        /if (!${Select[${Me},${Group.Leader}]} || !${SpawnCount[group mercenary]}) /return
        /if (${ToggleState.Equal[TurnOn]}) {   
            :TurnOnPullRole
            /if (${Target.Distance}>${CampRadius}) {                
                /if (${Group.Puller.ID}!=${Me.ID}) /grouproles set ${Me.CleanName} 3
                /delay 10 ${Group.Puller.ID}==${Me.ID}
                /if ((${Target.Distance}>${CampRadius}) && (${Group.Puller.ID}!=${Me.ID})) /goto :TurnOnPullRole  
                /if (${Group.Puller.ID}==${Me.ID}) /echo + You have been set be group puller.        
            }
        }
        /if (${ToggleState.Equal[TurnOff]}) {    
            :TurnOffPullRole
            /if ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})) {        
                /if (${Debug}) /echo KICKIT! ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})) \agLine#: ${Macro.CurLine}
                /if (${Group.Puller.ID}==${Me.ID}) /grouproles unset ${Me.CleanName} 3
            } else {
                /if ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius})) /moveto loc ${CampYLoc} ${CampXLoc} mdist 10
            }
            /delay 10 ${Group.Puller.ID}!=${Me.ID}    
            /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} || (${Group.Puller.ID}==${Me.ID})) /goto :TurnOffPullRole   
            /if (${Group.Puller.ID}!=${Me.ID}) /echo + You are no longer group puller.
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: GroupWatch
| -------------------------------------------------------------------------------------
    Sub GroupWatch
        /if (!${GroupWatchOn} ) /return 
        /if (${AggroTargetID} && !${ChainPull}) /return
        /if (${Debug}) /echo \atDEBUG GroupWatch Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare GrpMemType string local
        /declare GrpMemName string local
        /declare GrpMemClass string local
        /declare GrpMemStat string local
        /if (!${Spawn[=${MainAssist}].ID} && !${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]} && ${CampZone}==${Zone.ID}) {
            /echo I am not detecting Main Assist pausing.
            :WaitForMA
                /doevents
                /call CheckForCombat 0 GroupWatch
                /call WaitSubs
                /if (${Spawn[=${MainAssist}].ID}) {
                    /echo Main Assist is back resuming action.
                    /return
                }
                /delay 10
            /goto :WaitForMA
        }
        /if (${ChainPullHold}==1) /varset ChainPullHold 0
        /for i 1 to 5
            /if (!${Group.Member[${i}].ID} || ${Group.Member[${i}].Type.Equal[corpse]} ) {
                /if (${ChainPull} && ${Group.Member[${i}].Type.Equal[corpse]}) /varset ChainPullHold 1
                /continue
            }
            /if (${GroupWatchOn}==2 && !${Select[${Group.Member[${i}].Class.ShortName},CLR,DRU,SHM]}) /continue
            /varset GrpMemType ${Group.Member[${i}].Type}
            /varset GrpMemName ${Group.Member[${i}].CleanName}
            /varset GrpMemClass ${Group.Member[${i}].Class.ShortName}
            /if (${Select[${GrpMemClass},BER,MNK,ROG,WAR]}) {
                /varset GrpMemStat Endurance
            } else {
                /varset GrpMemStat Mana
            }
            /if (${Debug}) /echo \atDEBUG ${i} /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" ${GrpMemStat} ${GroupWatchPct} 90 \agLine#: ${Macro.CurLine}
            /call CheckStats 1 "${GrpMemName}" ${GrpMemClass} ${GrpMemType} ${GrpMemStat} ${GroupWatchPct} 90
            /if (${Select[${GrpMemClass},BST,PAL,RNG,SHD]}) /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" Endurance ${GroupWatchPct} 90
        /next i
        /if (${Debug}) /echo \atDEBUG GroupWatch Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckStats
| -------------------------------------------------------------------------------------
    Sub CheckStats(int statcheck, charname, ckclass, cktype, stat, int pause,int resume)
        /if (!${statcheck}) /return
        /if (!${Spawn[${ckclass} ${cktype} ${charname}].ID}) /return
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}>${pause}) /return
        /if (${Debug}) /echo \atDEBUG CheckStats Enter \agLine#: ${Macro.CurLine}
        /if (${Debug}) /echo \atDEBUG statcheck ${statcheck} charname ${charname} ckclass ${ckclass} stat ${stat} pause ${pause} resume ${resume} \agLine#: ${Macro.CurLine}
        /if (${Role.Equal[puller]} && ${ChainPull} ) {
                /call MobRadar ${MeleeDistance} CheckStats
                /if (${MobCount}>0) {
                 /varset ChainPullHold 1
             /return
            }
        }
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} t "Waiting for >> ${charname} << to med up to ${resume}% ${stat}."
        } else {
            /echo  Waiting for >> ${charname} << to med up to ${resume}% ${stat}.
        }
        | target toon to make sure they aren't at full mana due to lag
        /target id ${Spawn[${ckclass} ${cktype} ${charname}].ID}
        /delay 10
        /varset Pulling 0
        | Only twist med if song no aggro others fighting willnegate bard fast med
        /if (${IAmABard} && ${TwistMed} && ${TwistOn} && ${AggroTargetID}) /squelch /twist ${TwistMed}
        /varset Medding 1
        :wait_for_resume
            /doevents
            /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15 ) {
                /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
                /call DoWeMove 0 checkstats
                /delay 100 ${MoveTo.Stopped}
            }
            |/delay 10
            |/call CheckCasting 50
            /delay 10
            /if (!${MedCombat}) /call WaitSubs
            /if (${AggroTargetID}) {
                /call CheckForCombat 0 CheckStats
                /varset Medding 0
                /return
            }
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}<${resume}) /goto :wait_for_resume
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} t "${charname} is now above ${resume}% ${stat} resuming activity."
        } else {
            /echo ${charname} is now above ${resume}% ${stat} resuming activity.
        }
        /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
        /varset Medding 0
        /varset ChainPullHold 0 
        /if (${IAmABard} && ${TwistMed}) {
            /squelch /twist off
            /stopsong
        }
        /if (${ChainPull} && ${ChainPullPause.NotEqual[0]}) /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
        /if (${Debug}) /echo \atDEBUG CheckStats Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: alert clear
| -------------------------------------------------------------------------------------
    Sub AlertClearList(int ListToClear, string SentFrom)
        /if (${DebugPull}) {
            /echo \atDEBUGPULL AlertClearList Enter  \agLine#: ${Macro.CurLine}
            /echo \atDEBUGPULL Clearing Alert list ${ListToClear}. \agLine#: ${Macro.CurLine}
        }
        /squelch /alert clear ${ListToClear}
        /if (${DebugPull}) /echo \atDEBUGPULL AlertClearList Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Assign Group Role
| -------------------------------------------------------------------------------------
    Sub AssignGroupRole(ASGOnOff, AGRName, AGRRole)
        /if (${Debug}) /echo \atDEBUG AssignGroupRole ${ASGOnOff} ${AGRName} ${AGRRole} \agLine#: ${Macro.CurLine}
        /docommand /grouproles ${ASGOnOff} ${AGRName} ${AGRRole}
        /delay 10
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantSee CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantSee
        /if (${Debug}) /echo \atDEBUG Event_CantSee \agLine#: ${Macro.CurLine}
        | Reset position via stick
        /if (${Pulling}) {
           /varset CantSee 1
           /return
        }
        /if (${Attacking}) {
            /if (${Debug}) /echo Can't See my target. Moving Closer. \agLine#: ${Macro.CurLine}
            /if (${Me.Sitting}) /stand
            /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0
            /if (${StickHow.NotEqual[0]}) {
                /if (${Me.FeetWet}) {
                    /if (${Stick.Active}) /Stick off
                    /if (${Target.ID}) /face
                    /moveto id ${Target.ID} mdist 8
                    /delay 10
                    /if (${MainAssist.Equal[${Me}]}) {
                        /stick ${StickDistUW} uw id ${MyTargetID} moveback
                    } else {
                        /stick ${StickDistUW} uw behindonce id ${MyTargetID} moveback
                    }
                }
            } else {
                /if (${Me.FeetWet}) {
                    /stick ${StickDistUW} uw id ${MyTargetID} moveback
                } else {
                    /stick ${StickDist} pin id ${MyTargetID}
                }
            }
        }
        /if (${Debug}) /echo Leave Event_CantSee \agLine#: ${Macro.CurLine}
        /doevents flush CantSee
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantHit
        /if (${Debug}) /echo Event_CantHit \agLine#: ${Macro.CurLine}
        | Reset position via stick
        /if (${Pulling}) {
            /varset CantHit 1
            /if (${PullWith.Equal[Ranged]} && ${Target.Distance}<=30 && ${Target.LineOfSight}) /varset ToClose 1
        }
        /if (${Debug}) /echo Leave Event_CantHit \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event Missing
| -------------------------------------------------------------------------------------
    Sub Event_Missing

    /return 1
| ----------------------------------------------------------------------------
| SUB: Bind Switch
| ----------------------------------------------------------------------------
    Sub Bind_Switch
        /declare WasAttacking int local ${Attacking}
        /echo New target called!
        /call CombatReset 1 switch
        /call Assist
        /if (${WasAttacking}) {
            /squelch /attack on
            /varset Attacking 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind SwitchMA
| ----------------------------------------------------------------------------
    Sub Bind_SwitchMA(string newMA, string newRole, int DoWhatFlag)
        /return
        /declare newRole1 string local ${newRole}
        /if (${newMA.Length}==0 || ${newMA.Equal[null]}) /return
        /if (${newRole1.Length}==0 || ${newRole1.Equal[null]}) /varset newRole1 Tank
        /if (${DoWhatFlag}==0) {
            /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
                /bcg //switchma ${newMA} ${newRole1} 1
            } else {
                /echo SwitchMA Command requires MQ2EQBC Plugin to be loaded and EQBCOn turned on.
            }
        }
        /echo Switching Main Assist to ${newMA}
        /if (${newMA.Equal[${Me}]}) {
            |/varset MainAssist ${Me}
            /varset MainAssistType ${Me.Type}
            /varset MainAssistClass ${Me.Class.ShortName}
            /if (${Role.Equal[${MyOriginalRole}]} ) {
                /varset Role ${newRole1}
            } else {
                /varset Role ${MyOriginalRole}
            }
        } else /if (${Me.Pet.ID} && ${newMA.Equal[${Me.Pet.CleanName}]}) {
            |/varset MainAssist ${Me}
            /varset MainAssistType ${Me.Type}
            /varset MainAssistClass ${Me.Class.ShortName}
            /varset Role pettank
            | assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank
        } else {
            /varset MainAssist = ${newMA}
            /varset MainAssistType ${Spawn[=${newMA}].Type}
            /varset MainAssistClass ${Spawn[=${newMA}].Class.ShortName}
            /if (${Select[${MyOriginalRole},puller,assist,petassist]}==0) {
                /varset Role Assist
            } else /if (${Role.NotEqual[${MyOriginalRole}]} ) {
                /varset Role ${MyOriginalRole}
            }
            
        }
        /call CheckRoles 0
        /call CombatReset 0 switchma
        /call Assist
        |/call Combat
    /return
| ----------------------------------------------------------------------------
| SUB: Event GotHit - Written by TreeHuginDruid for RedGuides
| ----------------------------------------------------------------------------
    Sub Event_GotHit(string Line, string AttackingMob)
        /declare GotHitDistChk int local 10
        /varset GotHitToggle 1
        /declare AttackingMobID int local
        /if (${AggroTargetID} && !${Target.ID} && !${ReturnToCamp}) {
            /call CheckForCombat 0 Event_GotHit
        }
        /if (${Pulled} && ${WaitTimer} && ${Select[${Role},pullertank,pullerpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
            /if (${NearestSpawn[npc los radius ${CampRadius} targetable].ID}!=${MyTargetID}) {
                /varset MyTargetID 0
                /varset MyTargetName
            }
            /varset WaitTimer 0s
            /echo I got hit by >>${AttackingMob}<< ID:${AttackingMobID} while waitng for mob.
        }     
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]}) {   
            /doevents flush GotHit        
            /varset AttackingMobID ${NearestSpawn[npc radius 39 targetable "${AttackingMob}"].ID}
            /squelch /target id ${Spawn[${AttackingMobID}].ID}                         
            /delay 10 ${Target.ID}==${AttackingMobID}            
            |- If mob that hit me still too close, move to camp or away from mob.
            /if (${GotHitToggle} && ${AttackingMobID}>0) {
                /echo I got hit by >>${AttackingMob}<< ID:${AttackingMobID}!
                /moveto mdist 10
                /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && !${Select[${Role},hunterpettank]} && ${ReturnToCamp}) {
                    |- Only move away from mob if MoveWhenHit enabled (1)
                    /if (${MoveWhenHit}) {
                        /echo Moving back to camp!
                        /moveto loc ${CampYLoc} ${CampXLoc}
                    }
                } else {
                    |- If mob is in pet attack range from camp, send pet in.
                    /if (${Me.Pet.ID} && ${Math.Distance[${Target.Y},${Target.X}:${Me.Pet.Y},${Me.Pet.X}]}<=${PetAttackRange}) /pet attack
                    |- Only move away from mob if MoveWhenHit enabled (1)
                    /if (${MoveWhenHit}) {
                        /echo Trying to get away from >>${AttackingMob}<<.
                        /if (${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}<=${GotHitDistChk}) /moveto loc ${Target.Y} ${Math.Calc[${Target.X}-${GotHitDistChk}]}
                    }
                }
            }
            /if (${MoveWhenHit}) /delay 15 ${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}>${GotHitDistChk}
            /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0
        }
        /varset GotHitToggle 0
        /doevents flush GotHit
    /return
| ----------------------------------------------------------------------------
| SUB: Event Zoned
| ----------------------------------------------------------------------------
    Sub Event_Zoned(Message)
        /if (${Message.Find[Drunken Monkey]} || ${Message.Find[effects]}) /return
        /delay 60s ${Me.ID} && ${Zone.ID}
        /if (!${JustZoned}) /echo Just zoned
        /call CombatReset 0 zoned
        /varset JustZoned 200
        /varset CampOnDeathTimer 10m
        /if (${ReturnToCamp} && ${CampZone}!=${Zone.ID}) /varset RememberCamp 1
        /if (${LastZone}!=${Zone.ID}) {
            /if (${Zone.Name.Find[,]} || ${Zone.Name.Find[']}) {
                /varset ZoneName ${Zone.ShortName}${If[${Me.InInstance},_I,]}
            } else {
                /varset ZoneName ${Zone}${If[${Me.InInstance},_I,]}
            }
        }
        /varset LastZone ${Zone.ID}
        | Shut down combat and mez in GH, GL, PoK, PoT, and Abysmal
        /if (${Select[${Zone.ID},345,344,202,203,279]}) {
            /varset DMZ 1
        } else {
            /varset DMZ 0
        }
        /if (${ReturnToCamp} && ${CampZone}!=${Zone.ID}) /varset ReturnToCamp 0
        /if (${RememberCamp} && ${CampZone}==${Zone.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=100) {
            /varset ReturnToCamp 1
            /varset RememberCamp 0
        }
        /call CombatReset 0 zoned
        /call WinTitle
    /return
| ----------------------------------------------------------------------------
| SUB: Event Joined 20s switch to prevent heals from firing off
| ----------------------------------------------------------------------------
    Sub Event_Joined(string Jmessage,string Joinee)
         /echo ${Joinee} has joined the party.
         /varset JoinedParty 200
     /return
| ----------------------------------------------------------------------------
| SUB: Event Too Close
| ----------------------------------------------------------------------------
    Sub Event_TooClose
        /if (${MyTargetID} && ${AutoFireOn} && ${CombatStart} && ${UseMQ2Melee}) {
            /varset AutoFireOn 0
            /killthis
            /timed 300 /varset AutoFireOn 1
        }
        /if (${Pulling} && ${PullWithAlt.Equal[Melee]}) {
           /echo Mob Too Close for ${PullWith}... Switching to Melee.
           /varset ToClose 1
        }
        /doevents flush TooClose
    /return
| ----------------------------------------------------------------------------
| SUB: Event Banestrike - by Petesampras
| ----------------------------------------------------------------------------
   Sub Event_Banestrike
    /if (${Target.ID} && !${Banestrike.Find[|${Target.Race}|]}) /varset Banestrike ${Banestrike}${Target.Race}|
   /return
| ----------------------------------------------------------------------------
| SUB: Event Camping - end macro
| ----------------------------------------------------------------------------
    Sub Event_Camping        
        /if (${IAmABard} && ${Twist}) /squelch /twist off
        /stopsong
        /end
    /return
| ----------------------------------------------------------------------------
| SUB: Event Too Far
| ----------------------------------------------------------------------------
    Sub Event_TooFar
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /if (${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius} && ${MeleeOn} && ${CombatStart} ) {
            /if (${Me.FeetWet}) {
                /face 
                /moveto id ${Target.ID} mdist 8
                /delay 10
                /if (${MainAssist.Equal[${Me}]}) {
                    /squelch /stick 8 uw id ${MyTargetID}
                } else {
                    /squelch /stick 8 uw behindonce id ${MyTargetID} moveback
                }
            } else {
                /squelch /stick 8 ${StickHow} id ${MyTargetID}
            }
        }
        /call ZAxisCheck ${ZDist} 4.1
        /if (${Select[${Role},pullertank,pullerpettank,puller]} && ${Pulling}) {
            /varset PullTooFar 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Change Var Int resets various interger settings from ini file
| ----------------------------------------------------------------------------
    Sub Bind_ChangeVarInt(ISection, IName, IVar)
        /if (${Debug}) Bind_ChangeVarInt ${ISection} ${IName} ${IVar} \agLine#: ${Macro.CurLine}
        /echo Changing ${IName} to ${IVar}
        /varset ${IName} ${IVar}
        /ini "${IniFileName}" "${ISection}" "${IName}" "${IVar}"
        /if (${IName.Find[mezon]} && !${Defined[MezTimer1]}) /call CreateTimersMez
        /if (${IName.Find[dpson]} && !${Defined[DPSTimer1]}) /call CreateTimersDPS
        /if (${IName.Find[buffson]} && !${Defined[Buffs1Timer0]}) {
            /call CreateTimersBuffs
            /echo Buffs on creating timers
        }
        /if (${IName.Equal[ChaseAssist]} && ${ReturnToCamp}) /varset ReturnToCamp 0
        /if (${IName.Equal[ChaseAssist]} && ${IVar}==0 && ${Stick.Active}) /squelch /stick off
        /if (${IName.Equal[ChaseAssist]} && ${IVar}==1 && !${Stick.Active}) /varset RebuffOn 300
        /if (${IName.Equal[MaxRadius]}) /varcalc CampRadiusExceed ${MaxRadius}+200
    /return
| ----------------------------------------------------------------------------
| SUB: Bind ChaseMe
| ----------------------------------------------------------------------------
    Sub Bind_ChaseMe
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //togglevariable ChaseAssist on ${Me.CleanName}
            /bcg //changevarint General ChaseAssist 1
        } else {
            /echo ChaseMe command requires MQ2EQBC plugin loaded and EQBCOn flag turned on.
        }
    /return    
| ----------------------------------------------------------------------------
| SUB: Event Task Update - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_TaskUpdate(Line,name)
       /call BroadCast ${IRCOn} ${EQBCOn} t "Task updated...(${name})"
    /return
| ----------------------------------------------------------------------------
| SUB: Event Gain Something - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_GainSomething(string Line,string text)
        /if (!${EQBCOn} && !${IRCOn}) /return
        /if (${Line.Find["ABILITY POINT!"]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} w "${Me.Name} gained an AA, now has ${Me.AAPoints} unspent"
        } else /if (${Line.Find[LEVEL]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} w "${Me.Name} gained a level, now is Level ${Me.Level}"
            /if (${GMailEvents.Find[level]}) /call GmailSend "${Me.Name} gained a level, I am Level ${Me.Level}"
           | Recalculate pull when level gained
            /if (${PullLevel.Find[auto]}) {
               /varcalc PullMin ${Me.Level}-5
               /varcalc PullMax ${Me.Level}+2       
            } 
        } 
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Edit - Edit ini file in MQ2NotePad
| ----------------------------------------------------------------------------
    Sub Bind_KissE
        /if (!${Bool[${Plugin[MQ2Notepad]}]}) {
            /echo This function requires MQ2Notepad to be loaded..
            /echo 1. Please copy MQUI_NotepadWindow.xml to your Everquest/UIFiles/default or custom ui folder
            /echo 2. then /Plugin MQ2notepad
        }
        /if (${Bool[${Plugin[MQ2Notepad]}]}) {
            /docommand /notepad kissassist_${Me}.ini
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Check - scan ini file for errors based on nostress KissNamechecker.mac
| ----------------------------------------------------------------------------
    Sub Bind_KissCheck
        /call ScanIni
    /return
| ----------------------------------------------------------------------------
| SUB: Event Invised Mainly to turn off bard twisting while invis.
| ----------------------------------------------------------------------------
    Sub Event_Invised
        /if (${IAmABard} && ${Twist}) {
            /squelch /twist off
            /stopsong
        }
    /return    
| ----------------------------------------------------------------------------
| SUB: Event ImDead
| ----------------------------------------------------------------------------
    Sub Event_ImDead(IDMessage)
        /if (${IAmDead}) /return
        /echo I have died and the Angels wept.
        /if (${GMailEvents.Find[dead]}) /call GmailSend "I have died. EQ Said ${IDMessage} Loc ${Me.X}  ${Me.X}"
        /varset IAmDead 1
        /call CombatReset 0 ImDead
        /doevents flush ImDead
        /if (${IAmABard}) {
            /squelch /twist off
            /stopsong
            /delay 10
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM On
| ----------------------------------------------------------------------------
   Sub Event_GoMOn
        /if (${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
            /doevents flush GoMOn
            /return
        }
        /if (!${CombatStart} || ${GoMTimer} || ${GoMByPass}) /return
        | Release timer after trying to cast for 10 secs
        /varset GoMTimer 3s
        /declare i int local
        /declare GoMCast string local
        /declare GoMTarget string  local
        /for i 1 to ${GoMSpell.Size}
            /if (!${ConditionsOn} || !${GoMCOn} || ${If[${GoMCond[${i}]},1,0]}) {
                /varset GoMCast ${GoMSpell[${i}].Arg[1,|]}
                /varset GoMTarget ${GoMSpell[${i}].Arg[2,|]}
                /if (${GoMCast.Equal[null]} || ${GoMCast.Find[spell]} || ${GoMSpellTimer${i}}) /continue
                /echo Gift of Mana detected! Trying to cast ${GoMCast}
                /doevents flush GoMOn
                /if (${GoMTarget.Equal[Mob]} || (${GoMTarget.Equal[NULL]} && ${MyTargetID})) /varset GoMTarget ${MyTargetID} 
                /if (${GoMTarget.Equal[Me]} && ${Me.ID}) /varset GoMTarget ${Me.ID}
                /if (${GoMTarget.Equal[MA]} && ${Spawn[=${MainAssist}].ID}) /varset GoMTarget ${Spawn[=${MainAssist}].ID} 
                /varset GoMActive 1
                /if (${GoMTarget.Equal[${MyTargetID}]} && (${Target.Type.Equal[Corpse]} || !${Spawn[id ${MyTargetID}].ID})) {
                    /if (${Debug}) /echo \atDEBUG Event_GoMOn [GoM] skipping because mob is dead or a corpse. \agLine#: ${Macro.CurLine}
                    /echo [GoM] being skipped, because target (${GoMTarget}) is a corpse.
                    /varset GoMTimer 0
                    /delay 10                        
                    /doevents GoMOff
                    /return
                }
                | Wait for global cooldown if active
                |/delay 60 ${Me.SpellInCooldown}==FALSE
                /while (${Me.SpellInCooldown}) {
                    /if (${MeleeOn}) {
                        /if (${WeaveArray.Size}>0) /call WeaveStuff ${MyTargetID}
                        /if (${MashArray.Size}>0) /call MashButtons
                    } else {
                        /delay 2
                    }
                }
                /if (${Me.SpellReady[${GoMCast}]}) {
                    /call CastWhat "${GoMCast}" ${GoMTarget} GoM
                } else {
                    /echo "${GoMCast}" is not ready!
                    /delay 10
                }
                /if (${Debug}) /echo Return: ${Macro.Return} \agLine#: ${Macro.CurLine}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Gift of Mana Casting >> ${GoMCast} << 
                    /varset GoMTimer 0
                    /varset GoMSpellTimer${i} (${Spell[${GoMCast}].Duration.TotalSeconds}*${DurationMod})*10
                    /doevents flush GoMOn
                    /delay 10
                    /doevents GoMOff
                    /return
                }
                :NextGOM
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM Off
| ----------------------------------------------------------------------------
    Sub Event_GoMOff
        /varset GoMActive 0
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo guild meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_GUEQBC(Message,GUName,GUText)
        /if (${GUName.Equal[${Me.CleanName}]}) /return
		/if (${Macro.IsTLO[EQBC]}) {
            /if (${EQBC.Connected} && ${Select[${EQBCOn},2,4]}) /call BroadCast ${IRCOn} ${EQBCOn} p "${GUName} tells Guild: ${GUText} "
		}
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo fellowship meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_FSEQBC(Message,FSName,FSText)
        /if (${FSName.Equal[${Me.CleanName}]}) /return
		/if (${Macro.IsTLO[EQBC]}) {
            /if (${EQBC.Connected} && ${Select[${EQBCOn},3,4]}) /call BroadCast ${IRCOn} ${EQBCOn} p "${FSName} tells Fellowship: ${FSText} "
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event EQBCIRC - Pick up commands from MQ2IRC or MQ2EQBC(todo)
| ----------------------------------------------------------------------------
   Sub Event_EQBCIRC(EIMessage,EISender,EICommand)
    /if (${EICommand.Left[1].Equal[/]} && ${EICommand.Left[2].NotEqual[/]}) /docommand ${EICommand}
    /doevents flush EQBCIRC
   /return
| ----------------------------------------------------------------------------
| SUB: AFK Tools from AHTools by Anonymous Hero
| ----------------------------------------------------------------------------
    Sub AFKTools
    /declare holding bool local
    /if (${CampZone}!=${Zone.ID} || (${HealsOn} && ${AggroTargetID}) ) /return
    /if (${Select[${AFKToolsOn},1,2]}) {
        :CZLockDown
        /if (${Macro.IsTLO[Posse]}) {
            /if (${Posse.Strangers}>=1) {
                /if (!${holding}) {
                    /echo [AHTools] Macro on hold due to player activity in camp radius.
                    /call BroadCast ${IRCOn} ${EQBCOn} r "**PCS DETECTED IN CAMP RADIUS**"
                    /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                    /varset holding 1
                }
                /delay 1s
                /call CheckForCombat 0 AFKTools
                /doevents
                /goto :CZLockDown
            }
        } else { /varset holding 0 }
    }
    /if (${Select[${AFKToolsOn},1,3]}) {
        /if (${GMailEvents.Find[GM]} && ${SpawnCount[GM]}>=1) /call GmailSend "GM in Zone, ${Zone.ShortName}" 
        :GMLockDown
        /if (${SpawnCount[GM]}>=1) {
            /if (${AFKGMAction}==1) {
                /if (!${holding}) {
                    /echo [AHTools] Macro on hold due to GM Presence
                    /call BroadCast ${IRCOn} ${EQBCOn} r "** GM DETECTED **"
                    /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                    /varset holding 1
                }
                /goto :GMLockDown
            } else {
                /varset holding 0
            }
            /if (${AFKGMAction}==2) /multiline ; /echo [AHTools] Ending Macro due to GM Presence ; /mq2log [AHTools] Ending Macro due to GM Presence ; /endmacro
            /if (${AFKGMAction}==3) /multiline ; /echo [AHTools] Unloading MQ2 due to GM Presence; /mq2log [AHTools] Unloading MQ2 due to GM Presence ; /unload
            /if (${AFKGMAction}==4) /multiline ; /echo [AHTools] Quitting out of EQ due to GM Presence ; /mq2log [AHTools] Quitting out of EQ due to GM Presence ; /quit
        }
    }
   /return
| ----------------------------------------------------------------------------
| SUB: Burn Section for new bind
| ----------------------------------------------------------------------------
    Sub Bind_Burn
        /call Event_Burn
    /return
| ----------------------------------------------------------------------------
| SUB: Burn Section
| ----------------------------------------------------------------------------
    Sub Event_Burn
        /if (${IAmDead} || ${Me.Hovering} || ${CampZone}!=${Zone.ID} || ${BurnText.Equal[null]} || !${BurnText.Length}) {
            /doevents flush Burn
            /return
        }
        /declare i int local
        /declare BurnSpell string local
        /declare BurnTarget string local
        /declare BurnTargetID int local
        /declare  BurnIfSpell string local
        /call BroadCast ${IRCOn} ${EQBCOn} r "BURN ACTIVATED => Autobots Transform <="
        /if (${UseTribute} && !${Me.TributeActive}) {
           /squelch /tribute personal on
           /varset TributeTimer 570s
        }
        /for i 1 to ${Burn.Size}
            /if (${Burn[${i}].Arg[2,|].Length}) {
                /varset BurnSpell ${Burn[${i}].Arg[1,|]}
                /varset BurnTarget ${Burn[${i}].Arg[2,|]}
            } else {
                /varset BurnSpell ${Burn[${i}]}
            }
            /if (${BurnSpell.Equal[null]} || ${Me.Hovering}) /continue
                /if (!${Burn[${i}].Arg[2,|].Length} || ${BurnTarget.Equal[Mob]}) /varset BurnTargetID ${MyTargetID}
                /if (${BurnTarget.Equal[Me]}) /varset BurnTargetID ${Me.ID}
                /if (${BurnTarget.Equal[MA]}) /varset BurnTargetID ${Spawn[=${MainAssist}].ID}
                /if (${BurnTarget.Equal[Pet]}) /varset BurnTargetID ${Me.Pet.ID}
                | /delay 10
                | Conditional Added to skip entry
                /if (${ConditionsOn} && ${BurnCOn} && ${If[${BurnCond[${i}]},0,1]}) /continue
                /if (${Burn[${i}].Arg[3,|].Length} && ${Burn[${i}].Arg[4,|].Length}) { 
                    /if (${Burn[${i}].Arg[3,|].Equal[if]}) {
                        /varset BurnIfSpell ${Burn[${i}].Arg[4,|]}
                        /if (${Me.Buff[${BurnIfSpell}].ID} || ${Me.Song[${BurnIfSpell}].ID} || ${Me.ActiveDisc.Name.Find[${BurnIfSpell}]}) {
                            /echo ${BurnIfSpell} is active trying to cast ${BurnSpell}
                            |/goto :CastBurn
                        } else {
                            /continue
                        }
                    } else /if (${Burn[${i}].Arg[3,|].Equal[notif]}) {
                        /varset BurnIfSpell ${Burn[${i}].Arg[4,|]}
                        /if (!${Me.Buff[${BurnIfSpell}].ID} && !${Me.Song[${BurnIfSpell}].ID} && !${Me.ActiveDisc.Name.Find[${BurnIfSpell}]}) {
                            /echo ${BurnIfSpell} is NOT active trying to cast ${BurnSpell}
                            |/goto :CastBurn
                        } else {
                            /continue
                        }
                    }
                }
                :CastBurn
                /call CastWhat "${BurnSpell}" ${BurnTargetID} Burn
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting >> BURN${i}:${BurnSpell}
                    /delay 10
                }
            :SkipBurnEntry
        /next i
        /doevents flush Burn
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  Code from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Event_TooSteep
        /varset CampfireOn 0
        /echo Setting CampfireOn to 0. You are on a hill.
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  OriginalCode from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Bind_Campfire
    /if (${Select[${Zone.ID},33506]}) /return
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=10) {
            /if (${Me.FeetWet}) {
                /moveto set useback off
                /moveto loc ${CampYLoc} ${CampXLoc} ${CampZLoc} uw mdist 10
            } else {
                /moveto set useback on
                /moveto loc ${CampYLoc} ${CampXLoc} ${CampZLoc} mdist 5
            }
            /delay 10
        }
        /delay 50 !${MoveTo.Moving}
        /if (${MoveTo.Moving}) /moveto off
        /windowstate FellowshipWnd open
        /delay 10
        /nomodkey /notify FellowshipWnd FP_Subwindows tabselect 2
        /if (!${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]}) {
            /nomodkey /notify FellowshipWnd FP_DestroyCampsite leftmouseup
            /delay 5s ${Window[ConfirmationDialogBox].Open}
            /if (${Window[ConfirmationDialogBox].Open}) {
                /nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
            }
            /delay 5s !${Me.Fellowship.Campfire}
        }
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_RefreshList leftmouseup
        /delay 1s        
        /nomodkey /notify FellowshipWnd FP_CampsiteKitList listselect 1
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_CreateCampsite leftmouseup
        /delay 5s ${Me.Fellowship.Campfire}
        /windowstate FellowshipWnd close
        /if (${Me.Fellowship.Campfire}) /echo Campfire Dropped
    /return
| ----------------------------------------------------------------------------
| SUB: Sort Array
| ----------------------------------------------------------------------------
    Sub SortArray(ArrayName, CArrayName, HiLo, SortHow)
        /declare i                  int     local
        /declare j                  int     local
        /declare k                  int     local
        /declare l                  int     local
        /declare m                  int     local
        /declare TempSortedName     string  local ${HiLo}
        /declare TempPos            int     local 0
        /declare NewArrayPos        int     local 0
        /declare NewArraySize       int     local 0
        /declare TempArray[${${ArrayName}.Size}] string     local 0
        /declare TArray2[${${ArrayName}.Size}]   string     local 0
        /declare CArray[${${ArrayName}.Size}]    string     local TRUE
        /declare MArrayCount int    local 1
        /declare WArrayCount int    local 1
        /declare TempSwapHold       string  local
        /declare Swapped            int     local 1
        /if (${Select[${CArrayName},NULL,GoMCond,HealsCond,DPSCond,BurnCond,GHCond,SHCond,MashCond,WeaveCond,AggroCond]}==0) {
            /echo ${CArrayName} is an invalid Conditional. Supported Conditionals for DPS, GOM, Burn, Heals, Mash, Weave and Aggro. 
            /beep
        }
        | Assign Array to temp array
        /for i 1 to ${${ArrayName}.Size}
            /if (${Debug}) /echo ${i} ${${ArrayName}[${i}]} \agLine#: ${Macro.CurLine}
            /varset TempArray[${i}] ${${ArrayName}[${i}]}
            /if (${CArrayName.NotEqual[null]}) {
                /vardata CArray[${i}] ${CArrayName}[${i}]
            }
        /next i
        /if (${ArrayName.Equal[dps]}) {
            /for i 1 to ${TempArray.Size}
                /if (${TempArray[${i}].Find[|weave]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset WeaveArray[${WArrayCount}] ${TempArray[${i}].Arg[1,|]}|${TempArray[${i}].Arg[2,|]}
                    /vardata WeaveCond[${WArrayCount}] CArray[${i}]
                    /if (${Debug}) /echo ${WeaveArray[${WArrayCount}]}
                    /if (${WArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc WArrayCount ${WArrayCount}+1
                } else /if (${TempArray[${i}].Find[|mash]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset MashArray[${MArrayCount}] ${TempArray[${i}].Arg[1,|]}|${TempArray[${i}].Arg[2,|]}
                    /vardata MashCond[${MArrayCount}] CArray[${i}]
                    /if (${Debug}) /echo ${MashArray[${MArrayCount}]}
                    /if (${MArrayCount}) /varset TempArray[${i}] NULL
                    /varcalc MArrayCount ${MArrayCount}+1
                }
            /next i
        }
        | Move Array to Temp Array leaving out useless entries.
        /for m 1 to ${${ArrayName}.Size}
            /if (${TempArray[${m}].Length} && !${TempArray[${m}].Find[|0]} && ${TempArray[${m}].NotEqual[null]}) {
                /varcalc NewArrayPos ${NewArrayPos}+1
                /varset TArray2[${NewArrayPos}] ${TempArray[${m}]}
                /varcalc NewArraySize ${NewArraySize}+1
                /if (${CArrayName.NotEqual[null]} && ${m}!=${NewArrayPos}) {
                     /vardata CArray[${NewArrayPos}] CArray[${m}]
                     /varset CArray[${m}] null
                }
            } else {
                /if (${CArrayName.NotEqual[null]}) /varset CArray[${m}] null
            }
        /next m
        |Sort the Array if needed
        /if (!${Select[${ArrayName},Buffs,Burn,Aggro]} && ${NewArraySize}>1) {
            /varset m ${NewArraySize}
            /while (${Swapped} && ${m}>1) {
                /varset Swapped 0
                /for k 2 to ${m}
                    /varcalc j ${k}-1
                    /if (${TArray2[${j}].Arg[2,|]} ${SortHow} ${TArray2[${k}].Arg[2,|]}) {
                        /varset TempSwapHold ${TArray2[${j}]}
                        /varset TArray2[${j}] ${TArray2[${k}]}
                        /varset TArray2[${k}] ${TempSwapHold}
                        /varset Swapped 1
                        /if (${CArrayName.NotEqual[null]}) {
                            /vardata TempSwapHold CArray[${j}]
                            /vardata CArray[${j}] CArray[${k}]
                            /vardata CArray[${k}] TempSwapHold
                        }
                    }
                /next k
                /varcalc m ${m}-1
            }
        }
        | Bail if array is empty and turn off switch
        /if (!${NewArraySize}) {
            /if (${Defined[${ArrayName}On]}) {
                /varset ${ArrayName}On 0
                /echo ERROR: ${ArrayName}On=1 but section is empty. Turning ${ArrayName} off. Please check your ini file.
                /beep
                /delay 20
            }
            /return
        }
        /deletevar ${ArrayName}
        /declare ${ArrayName}[${NewArraySize}] string outer
        /for l 1 to ${NewArraySize}
            /varset ${ArrayName}[${l}] ${TArray2[${l}]}
            /if (${Debug}) /echo  ${${ArrayName}[${l}]} \agLine#: ${Macro.CurLine}
        /next l
        /if (${CArrayName.NotEqual[null]}) {
            /deletevar ${CArrayName}
            /declare ${CArrayName}[${NewArraySize}] string outer
            /for l 1 to ${NewArraySize}
                /vardata ${CArrayName}[${l}] CArray[${l}]
            /next l
        }
        /if (${ArrayName.Equal[buffs]}) /call CreateTimersBuffs
        /if (${ArrayName.Equal[dps]}) /call CreateTimersDPS
        /if (${Debug}) /echo ${${ArrayName}.Size} \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers DPS
| ----------------------------------------------------------------------------
    Sub CreateTimersDPS    
        | Declare timers for DPS duration spells and Attack buffs
        /declare i int local
        /varset DebuffCount 0
        /for i 1 to ${DPS.Size}
            /if (${Int[${DPS[${i}].Arg[2,|]}]}<101) { 
                /declare DPSTimer${i}       timer         outer 5
                /declare ABTimer${i}        timer         outer 0
                /declare FDTimer${i}        timer         outer 0
            } else {
                /declare DBOTimer${i}       timer         outer 0
                /declare DBOList${i}        string        outer 
                /varcalc DebuffCount ${DebuffCount}+1
            }
        /next i
    /return    
| ----------------------------------------------------------------------------
| SUB: Assign single heals - seperate single heals from group heals
| ---------------------------------------------------------------------------
    Sub FindSingleHeals
        /if (${Debug}) /echo Enter FindSingleHeals \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare SHCount int 0
        /declare HealHighPoint int  local 0
        /declare HealHighestPoint int  local 0
        /declare HealHighestPointMA int  local 0
        /declare HealPointTag string  local 0
        /declare HealSpell string  local
        /for i 1 to ${Heals.Size}
            /varset HealSpell ${Heals[${i}].Arg[1,|]}
            /varset HealPointTag ${Heals[${i}].Arg[3,|]}
            /if (${HealPointTag.Equal[MA]}) {
                /varset HealHighestPointMA ${Heals[${i}].Arg[2,|]}
            } else {
                /varset HealHighPoint ${Heals[${i}].Arg[2,|]}                
            }
            /if (${Debug}) /echo ${i} ${HealSpell} ${Spell[${HealSpell}].TargetType} ${Select[${Spell[${HealSpell}].TargetType},SingleHeal,Self]} \agLine#: ${Macro.CurLine}
            /if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
                /vardata SHCond[${SHCount}] HealsCond[${i}]
                /goto :NextSH
            }
            /if (${Select[${Me.Class.Name},Druid,Shaman]} && (${HealSpell.Find[Intervention]} || ${HealSpell.Find[Survival]})) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
                /vardata SHCond[${SHCount}] HealsCond[${i}]
                /goto :NextSH
            }
            /if (${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${Heals[${i}].Arg[3,|].Find[tap]} || ${Heals[${i}].Arg[3,|].Find[pet]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && ${Select[${Heals[${i}].Arg[3,|]},MA,ME,pet]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
                /vardata SHCond[${SHCount}] HealsCond[${i}]
                /goto :NextSH
            }
            /if (${Spell[${HealSpell}].TargetType.Equal[Free Target]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
                /vardata SHCond[${SHCount}] HealsCond[${i}]
                /goto :NextSH
            }
            :NextSH
            /if (${HealPointTag.NotEqual[MA]} && ${HealHighPoint}>${SingleHealPoint}) /varset SingleHealPoint ${HealHighPoint}
            /if (${HealPointTag.Equal[MA]} && ${HealHighestPointMA}>${SingleHealPointMA}) /varset SingleHealPointMA ${HealHighestPointMA}
            /if (${Debug}) /echo ${SingleHealPoint} \agLine#: ${Macro.CurLine}
        /next i
        /if (${SHCount}) /call SortArray SingleHeal SHCond 100|100 >
        /if (!${SingleHealPoint}) /varset SingleHealPoint 99
        /if (!${SingleHealPointMA}) /varset SingleHealPointMA ${SingleHealPoint}
        /for j 1 to ${SingleHeal.Size}
             /if (${Debug}) /echo ${j} ${SingleHeal[${j}]} ${Spell[${SingleHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration} \agLine#: ${Macro.CurLine}
             
        /next j 
        /if (${Debug}) /echo Leave FindSingleHeals \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: Assign Group heals
| ---------------------------------------------------------------------------
    Sub FindGroupHeals
        /if (!${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) /return
        /if (${Debug}) /echo Enter FindGroupHeals \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare GHCount int 0
        /declare HealSpell string  local
        /for i 1 to ${Heals.Size}
            /varset HealSpell ${Heals[${i}].Arg[1,|]}    
            /if (${Debug}) /echo ${HealSpell} \agLine#: ${Macro.CurLine}
            /if (!${HealSpell.Length} || ${HealSpell.Equal[null]} || ${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]}) /goto :NextGH
            /if (${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) /goto :NextGH
            /if (${Me.Class.Name.Equal[Shaman]} && ${Spell[${HealSpell}].Name.Find[Intervention]} || ${Me.Class.Name.Equal[Druid]} && ${Spell[${HealSpell}].Name.Find[Survival]}) /goto :NextGH
            /if (${Spell[${HealSpell}].TargetType.Find[group v]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && !${Select[${Heals[${i}].Arg[3,|]},MA,ME]}) {
                /varcalc GHCount ${GHCount}+1
                /varset GroupHeal[${GHCount}] ${Heals[${i}]}
                /vardata GHCond[${GHCount}] HealsCond[${i}]
                /goto :NextGH
            }
            :NextGH
        /next i
        /if (${Debug}) /echo ${GHCount} \agLine#: ${Macro.CurLine}
        /if (${GHCount}) {
            /call SortArray GroupHeal GHCond 100|100 >    
            /for j 1 to ${GroupHeal.Size}
                /if (${Debug}) /echo ${j} ${GroupHeal[${j}]} ${Spell[${GroupHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${GroupHeal[${j}].Arg[1,|]}].Duration} \agLine#: ${Macro.CurLine}
            /next j 
        }
        /if (${Debug}) /echo Leave FindGroupHeals \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: Create Timers Heals
| ----------------------------------------------------------------------------
    Sub CreateTimersHeals    
        | Declare timers for Heal duration spells
        /declare j int local
        /declare k int local
        /declare q int local
        /for j 1 to ${GroupHeal.Size}
            | Group Heal duration timers
            /declare SpellGH${j}    timer   outer   0
        /next j
        /for j 1 to ${SingleHeal.Size}
            /for k 0 to 13
                | Self and MA duration heal timers for  out of group including Pets.
                /declare Spell${j}GM${k}     timer   outer   0
                /if (${Debug}) /echo \atDEBUG Group heal Timers Spell${j}GM${k} ${Spell${j}GM${k}} \agLine#: ${Macro.CurLine}
            /next k
        /next j
       | Declare timers for Pet heals
        /for q 1 to ${SingleHeal.Size}
            /declare PetHealTimer${q} timer outer 0
        /next q
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Rez
| ----------------------------------------------------------------------------        
    Sub CreateTimersRez    
        | Declare timers for Rez duration spells
        /declare m int local
        /for m 1 to 5
            /declare BattleRezTimer${m} timer outer 0
        /next m
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Mez
| ----------------------------------------------------------------------------    
    Sub CreateTimersMez
        | Declare timers for mezzing
        /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
            /declare l int local
            /for l 1 to 30
                /declare MezTimer${l} timer outer 0
                /declare MMTimer${l} timer outer 0
            /next l
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Creat Timers Buffs
| ----------------------------------------------------------------------------
    Sub CreateTimersBuffs
        | Declare timers for Buff duration spells
        /declare o int local
        /declare p int local
        | Create buff timer for all buff in array
        /for o 1 to ${Buffs.Size}
           | Create timers for everyone in group plus 2 extra for MA buffs
            /for p 0 to 7
                /declare Buff${o}GM${p}     timer   outer   0
                /if (${Debug}) /echo \atDEBUG Buff Timers:Buff${o}GM${p} ${Buff${o}GM${p}} \agLine#: ${Macro.CurLine}
            /next p
        /next o
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers GoM
| ----------------------------------------------------------------------------        
    Sub CreateTimersGoM    
        | Declare timers for Rez duration spells
        /declare i int local
        /for i 1 to ${GoMSpell.Size}
            /declare GoMSpellTimer${i} timer outer 0
        /next i
    /return    
| ----------------------------------------------------------------------------
| SUB: ZCheck /call ZAxisCheck current ,Z to check, difference
| ----------------------------------------------------------------------------
    Sub ZAxisCheck(float Zcur, float Zdiff)
        | Move down if Z distance more than Zcheck due to levitation
        /if (${Debug}) /echo \atDEBUG ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} Enter. \agLine#: ${Macro.CurLine}
        /if (${Zcur}>=${Zdiff}) {
            /keypress CMD_MOVE_DOWN hold
            /delay 10 ${Math.Distance[${CampZLoc}:${Me.Z}]}<=${Zdiff}
            /keypress CMD_MOVE_DOWN
        }
        /if (${Debug}) /echo \atDEBUG ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} leave. \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Event_PTaunt 
| ----------------------------------------------------------------------------
    Sub Event_PTaunt
        /varset PetTauntOn 1
    /return
| ----------------------------------------------------------------------------
| SUB: Event_WornOff - secondary check to rebuff
| ----------------------------------------------------------------------------
    Sub Event_WornOff(string Line, string wospell, string wotarget)
        /if (!${RebuffOn}) /return
        /if (${wotarget.Equal[${Me}]}) /return
        /if (${AggroTargetID}) /return
        /if (${Me.Class.Name.Find[bard]}) /return
        /if (${wospell.Find[promised]}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS Event_WornOff Enter ${wospell} ${wotarget} \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare WOSpellTT string local 0
        /declare WOTries int local 0
        /if (${Me.Book[${wospell}]}) {
            /varset WOSpellTT ${Spell[${Me.Book[${Me.Book[${wospell}]}].ID}].TargetType}
        } else {
            /varset WOSpellTT ${Spell[${wospell}].TargetType}
        }
        /for i 1 to ${Buffs.Size}
            /for j 1 to 5
                /if (${Group.Member[${j}].CleanName.Equal[${wotarget}]} && ${Buffs[${i}].Find[${wospell}]}) {
                    /varset Buff${i}GM${j} 0
                    /echo ${wotarget} needs ${wospell} because it wore off.
                    :MakeSureCO
                    /if (${WOTries}>5) /break
                    /if (${Select[${WOSpellTT},single,group]} && ${Me.Buff[${wospell}].ID})  {
                        /if (${Select[${EverQuest.Server},fippy,vulak,ragefire,lockjaw]}==0) /removebuff "${wospell}"
                        | reset spell timer on caster
                        /varset Buff${i}GM0 0
                        /varcalc WOTries ${WOTries}+1
                        /if (${Me.Buff[${wospell}].ID}) {
                              /if (${DebugBuffs}) /echo Spell: ${WOSpellTT} Slot: ${Me.Buff[${wospell}].ID} Buff: ${i} GM: ${j}
                            /goto :MakeSureCO
                        }
                    }
                }
            /next j
            /if (${WOTries}>5) /break
            | If MA out of group listen for buffs wearinig off
            /if (!${Spawn[${MainAssist} ${MainAssistType} group].ID} && ${Spawn[=${MainAssist}].CleanName.Equal[${wotarget}]} && ${Buffs[${i}].Find[${wospell}]}) {
                /varset Buff${i}GM7 0
                /echo ${wotarget} needs ${wospell} because it wore off.
            }
        /next i
        :SkipWO
        /varset ReadBuffsTimer 0
        /if (${IniNextTimer}) /varset IniNextTimer 0
         /if (${DebugBuffs}) /echo \atDEBUGBUFFS Event_WornOff Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Merc state 4 = no gold membership
| ----------------------------------------------------------------------------
    Sub WriteBuffsMerc  
        /if (!${Spawn[mercenary ${Group.Member[1].ID}].ID}) /return
        /if (${WriteBuffsMercTimer}) /return
        /if (!${Redguides}) /return
        /if (${AggroTargetID}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsmerc Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        /target id ${Spawn[mercenary ${MyMerc}].ID}
        /delay 20
        /for i 1 to 15
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc ${i} ${Target.Buff[${i}]} \agLine#: ${Macro.CurLine}
            /if (${Target.Buff[${i}].Name.Length}) {
                /varset BuffList ${Target.Buff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Buffs "${Writebufflist}"
        /delay 15
        /varset WriteBuffsMercTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Pet
| ----------------------------------------------------------------------------
    Sub WriteBuffsPet
        /if (!${Me.Pet.ID}) /return
        /if (${AggroTargetID}) /return        
        /if (!${Select[${Role},pettank,pullerpettank]} && ${Spawn[${MainAssist} ${MainAssistType}].ID}!=${Me.Pet.ID}) /return
        /if (${WriteBuffsPetTimer}) /return
        /if (!${Redguides}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffPet Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        /target id ${Me.Pet.ID}
        /delay 20
        /for i 1 to 50
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffPet ${i} ${Target.Buff[${i}]} \agLine#: ${Macro.CurLine}
            /if (${Me.PetBuff[${i}].Name.Length}) {
                /varset BuffList ${Me.PetBuff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffPet: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs "${Writebufflist}"
        /delay 15
        | Open Blocked Pet Buffs window temporarily to read blocked buffs
        /if (!${Window[BlockedPetBuffWnd].Open} && !${BPBWindowOpen}) {
            /windowstate BlockedPetBuffWnd open
            /varset BPBWindowOpen 120m
            /delay 10
        }
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 0 to 39
            /varset Blockedbuff ${Window[BlockedPetBuffWnd].Child[BW_BLOCKEDPETBUFF${k}_Button].Child[BPBuff${k}].Tooltip}
            /if (${Blockedbuff.Length}) {
                 /varset Blockedbufflist ${Blockedbufflist}|${Blockedbuff}
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedPetBuffWnd].Open}) /windowstate BlockedPetBuffWnd close
        /varset WriteBuffsPetTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsPet Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Clean Buffs File
| ----------------------------------------------------------------------------
    Sub CleanBuffsFile
        /if (${CleanBuffsTimer}) /return
        /declare i int local
        /declare SectionList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare SectionListCount int local ${SectionList.Count[|]}
        /if (${SectionListCount}==0) /return
        /varcalc SectionListCount ${SectionListCount}-1
        /declare SectionName string local
        /for i 1 to ${SectionListCount}
            /varset SectionName ${SectionList.Arg[${i},|]}
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CleanBuffsFile ${i} ${SectionName} ${Math.Calc[${Ini["KissAssist_Buffs.ini",${SectionName},Day]}-${Time.Day}]} ${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]} Day: ${Time.Day} Hour: ${Time.Hour} \agLine#: ${Macro.CurLine}
            /if (${Ini["KissAssist_Buffs.ini",${SectionName},Day].NotEqual[${Time.Day}]}) {
                /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
                /continue
            }
            /if (${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]}!=0) /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
        /next i
        /varset CleanBuffsTimer 10m
    /return
| ----------------------------------------------------------------------------
| SUB: AE check - cast area effect spells depending on set number of mobs
| ----------------------------------------------------------------------------
    Sub AECheck
        /if (!${AEOn}) /return
        /if (${Target.Type.Equal[corpse]}) /return
        /if (!${AggroTargetID}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare k int local
        /declare l int local
        /declare AESpell string local
        /declare AEMobCount int local
        /declare AETarget string local
        /declare AETargetID int local
        /declare ArrayCount int local 0
        /declare AEIfSpell string local
        /declare AENotIfSpell string local
        /declare MobCountTemp int local 0
        /declare CheckSpawnID
        /call MobRadar ${AERadius} AECheck
        | Adjust mobcount by subtracting mobs not on xtarget
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Mobcount:${MobCount} \agLine#: ${Macro.CurLine}
        /if (!${MobCount}) /return
        /varset MobCountTemp ${MobCount}
        /for j 1 to ${MobCount}
            /varset CheckSpawnID ${NearestSpawn[${j},npc targetable los radius ${AERadius} zradius 50 noalert 3].ID}
            /for i 1 to ${XSlotTotal}
                /if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].ID}) {
                    /if (${CheckSpawnID}==${Me.XTarget[${i}].ID}) {
                        /varcalc ArrayCount ${ArrayCount}+1
                    }
                }
            /next i
            /if (${ArrayCount}==0) {
               /varcalc MobCountTemp ${MobCountTemp}-1 
               /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck MobCountTemp:${MobCountTemp} after xtarget spawn check \agLine#: ${Macro.CurLine}
            }
            /varset ArrayCount 0
        /next j
        /if (${MobCountTemp}<=0) /return
        /for k 1 to ${AE.Size}
            /varset AESpell ${AE[${k}].Arg[1,|]}
            /varset AEMobCount ${AE[${k}].Arg[2,|]}
            /varset AETarget ${AE[${k}].Arg[3,|]}
            /varset AEIfSpell
            /varset AENotIfSpell
            | Check if AEspell is ready to use if not skip it
            /if (${AESpell.NotEqual[burn]} && !${Me.SpellReady[${Spell[${AESpell}].RankName}]} && !${Me.AltAbilityReady[${AESpell}]} && !${Me.CombatAbilityReady[${Spell[${AESpell}].RankName}]} && !${Me.AbilityReady[${AESpell}]}) /goto :NextAE
            | Check if AEspell if an item is ready to use. if not skip it
            /if (${FindItem[=${AESpell}].ID} && !${Me.ItemReady[=${AESpell}]}) /goto :NextAE
            /if (${AEMobCount}<=${MobCountTemp}) {
                /if (${AETarget.Equal[null]} || ${AETarget.Equal[Mob]} || ${AETarget.Equal[Single]}) /varset AETargetID ${MyTargetID}
                /if (${AETarget.Equal[Me]}) /varset AETargetID ${Me.ID}
                /if (${AETarget.Equal[MA]}) /varset AETargetID ${Spawn[=${MainAssist}].ID}
                /if (${AETarget.Equal[Pet]}) /varset AETargetID ${Me.Pet.ID}
                /if (${AESpell.Equal[burn]} && !${BurnActive}) {
                    /echo AE-> ${MobCountTemp} Mobs: Activating BURN
                    /varset BurnActive 1
                    /call Event_Burn
                    /return
                }
                /if (${Spawn[npc id ${AETargetID}].ID} && ${SpawnCount[npc xtarhater loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} radius ${Spell[${AESpell}].AERange}]} < ${SpawnCount[npc loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} radius ${Spell[${AESpell}].AERange}]}) {
                    /if (${AETarget.NotEqual[Single]}) /echo AE-> Casting ${Spell[${AESpell}].Name} now would aggro more mobs than we have on xtarget
                    /goto :NextAE
                }
                /if (${AE[${k}].Arg[3,|].Length} && ${AE[${k}].Arg[4,|].Length} && ${AE[${k}].Arg[3,|].Equal[if]}) {
                    /varset AEIfSpell ${AE[${k}].Arg[4,|]}
                    /if (${AE[${k}].Arg[5,|].Equal[mob]}) {
                        /varset AETargetID ${MyTargetID}
                        /if (${Int[${Target.Buff[${AEIfSpell}].ID}]}>0)
                        /echo AE-> ${MobCountTemp} Mobs: ${AEIfSpell} is active on Target trying to cast ${AESpell}
                        /goto :CastAE
                    } else { 
                        /if (${Me.Buff[${Spell[${AEIfSpell}].RankName}].ID} || ${Me.Song[${Spell[${AEIfSpell}].RankName}].ID} || ${Me.ActiveDisc.Name.Find[${AEIfSpell}]}) {
                            /echo AE-> ${MobCountTemp} Mobs: ${AEIfSpell} is active trying to cast ${AESpell}
                            /goto :CastAE
                        } else {
                            /goto :NextAE
                        }
                    }
                }
                /if (${AE[${k}].Arg[3,|].Length} && ${AE[${k}].Arg[4,|].Length} && ${AE[${k}].Arg[3,|].Equal[notif]}) {
                    /varset AENotIfSpell ${AE[${k}].Arg[4,|]}
                    /if (${AE[${k}].Arg[5,|].Equal[mob]}) {
                        /varset AETargetID ${MyTargetID}
                        /if (${Int[${Target.Buff[${AENotIfSpell}].ID}]}==0)
                        /echo AE-> ${MobCountTemp} Mobs: ${AENotIfSpell} is Not active on Target trying to cast ${AESpell}
                        /goto :CastAE
                    } else { 
                        /if (!${Me.Buff[${Spell[${AENotIfSpell}].RankName}].ID} && !${Me.Song[${Spell[${AENotIfSpell}].RankName}].ID} && !${Me.ActiveDisc.Name.Find[${AENotIfSpell}]}) {
                            /echo AE-> ${MobCountTemp} Mobs: ${AENotIfSpell} is NOT active trying to cast ${AESpell}
                            /goto :CastAE
                        } else {
                            /goto :NextAE
                        }
                    }
                }
                :CastAE
                /if (!${ConditionsOn} || !${AECOn} || ${If[${AECond[${k}]},1,0]}) {
                /if (${MobCountTemp}==1 && ${AETarget.Equal[Single]}) {
                    /call CastWhat "${AESpell}" ${AETargetID} AoE
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo AE-> ${AESpell} on Single target  >> ${Spawn[${AETargetID}].CleanName} <<
                    }
                        |/goto :NextAE
                        /continue
                } else /if (${MobCountTemp}>=2 && ${AETarget.Equal[Single]}) {
                        |/goto :NextAE
                        /continue
                } else {
                    /call CastWhat "${AESpell}" ${AETargetID} AoE
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo AE-> ${MobCountTemp} Mobs: Casting AE ${AESpell}
                    }
                } 
            }
            }
            :NextAE
        /next k
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: WriteDebuffs
| ----------------------------------------------------------------------------
    Sub WriteDebuffs
    /if (${DebugHeal}) /echo \amDEBUGHEALS WriteDebuffs Enter \agLine#: ${Macro.CurLine}
        /declare DebuffList string local 
        /declare IAmDeBuffed int local ${Math.Calc[${Int[${Me.Poisoned.ID}]}+${Int[${Me.Diseased.ID}]}+${Int[${Me.Cursed.ID}]}+${Int[${Me.Corrupted.ID}]}]}
        /if (${IAmDeBuffed} && !${NeedCuring}) {
            /varset NeedCuring 1
            /varset DebuffList ${IAmDeBuffed}|${Int[${Me.Poisoned.ID}]}|${Int[${Me.Diseased.ID}]}|${Int[${Me.Cursed.ID}]}|${Int[${Me.Corrupted.ID}]}
            /ini "KissAssist_Buffs.ini" "${Me.ID}" Debuffs "${DebuffList}"
            /delay 10
            /if (${DebugHeal}) /echo \amDEBUGHEALS WriteDebuffs Writing debuffs to ini file \agLine#: ${Macro.CurLine}
        }
        /if (!${IAmDeBuffed} && ${NeedCuring}) {
            /varset NeedCuring 0
            /varset DebuffList 
            /ini "KissAssist_Buffs.ini" "${Me.ID}" Debuffs "${DebuffList}"
            /delay 10
            /if (${DebugHeal}) /echo \amDEBUGHEALS WriteDebuffs Clearing debuffs from ini file \agLine#: ${Macro.CurLine}
        }
        /if (${DebugHeal}) /echo \amDEBUGHEALS WriteDebuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: CheckCures
| ----------------------------------------------------------------------------
    Sub CheckCures
        /if (!${CuresOn}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${Medding} && ${MedCombat}) /return
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures Enter  \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        /declare IniDebuffCount string local 0
        /declare IniDebuffList string local
        /declare CuretoCast string local 
        /declare CTID int local
        /for i 1 to ${Cures.Size}
            /if (!${Cures[${i}].Length}) /goto :NextCure
            /for j 1 to ${IniIDCount}
                /varset CuretoCast
                /varset IniDebuffCount ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${j},|]},"Debuffs"]} 
                /varset CTID ${Spawn[${IniIDList.Arg[${j},|]}].ID}
                /if (${IniDebuffCount.Arg[1,|]} && ${Spawn[${IniIDList.Arg[${j},|]}].ID} && ${Spawn[${IniIDList.Arg[${j},|]}].Distance}<100) {
                    /if (${IniDebuffCount.Arg[1,|]} && ${Cures[${i}].Arg[2,|].Length}==0) {
                        /varset CuretoCast ${Cures[${i}]}
                    } else /if (${IniDebuffCount.Arg[2,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[poison]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
                    } else /if (${IniDebuffCount.Arg[3,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[disease]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
                    } else /if (${IniDebuffCount.Arg[4,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[curse]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}    
                    } else /if (${IniDebuffCount.Arg[5,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[corruption]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}    
                    }  
                    | Check cures for group component since they don't seem to work on out of group toons
                    /if (${Spell[${CuretoCast}].TargetType.Find[group v]} && !${Spawn[id ${IniIDList.Arg[${j},|]} group].ID}) {
                        /if (!${Defined[CureTimer${CTID}${i}]}) {
                            /declare CureTimer${CTID}${i} timer outer 30s
                            /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures /echo declare CureTimer${CTID}${i} \agLine#: ${Macro.CurLine}
                        } else /if (!${CureTimer${CTID}${i}}) {
                            /varset CureTimer${CTID}${i} 30s
                            /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures /echo varset CureTimer${CTID}${i} \agLine#: ${Macro.CurLine}
                        }  
                        /if (${DebugHeal} && !${CureTimer${CTID}${i}}) /echo CURING: >> ${Spawn[${IniIDList.Arg[${j},|]}].CleanName} << is not in your group and >> ${CuretoCast} << is a group spell.
                        /goto :NextID
                    }
                    /if (${Me.SpellReady[${Spell[${CuretoCast}].RankName}]} || ${Me.AltAbilityReady[${CuretoCast}]} || ${Me.CombatAbilityReady[${Spell[${CuretoCast}].RankName}]} || ${Me.AbilityReady[${CuretoCast}]}) {
                        /call CastWhat "${CuretoCast}" ${IniIDList.Arg[${j},|]} Cure
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} o "CURING: >> ${Spawn[${IniIDList.Arg[${j},|]}].CleanName} << with ${CuretoCast}"
                        /delay 10
                    }
                }
                :NextID
            /next j
            :NextCure
        /next i
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: WaitSubs - bunch of crap to call while medding standing around etc
| ----------------------------------------------------------------------------
    Sub WaitSubs
        /if (!${Me.Mount.ID} && !${Me.Sitting}) /sit
        /if (${HealsOn}) /call CheckHealth
        /call WriteDebuffs
        /if (${CuresOn}) /call CheckCures
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) {
                /varset GoMByPass 1
                /call DoMezStuff WaitSubs
                /varset GoMByPass 0
            }
        }
        /call WriteBuffs
        /if (${AutoRezOn}) /call RezCheck
        /call CanIDoStuff
        /call CastMana WaitSubs
        /if (${PetOn}) /call DoPetStuff
        /if (${BuffsOn}) /call CheckBuffs
        /if (${MercOn}) /call MercsDoWhat
    /return
| ----------------------------------------------------------------------------
| SUB: BroadCast - Handles echos and messages in mq2irc and mq2eqbc
| ----------------------------------------------------------------------------
    Sub BroadCast(doirc, doeqbc, eqbcolor, message)
        /if (${eqbcolor.Equal[null]}) /varset eqbcolor w
        /if (${doeqbc}) {
            /if (${Macro.IsTLO[EQBC]}) {
                /if (${EQBC.Connected}) {
                    /if (TRUE) /${EQBCSay} [+${eqbcolor}+] [${Time}] ${message} [+x+]
                } else {
                    /echo You are NOT connected to an EQBC Server. Please check your connection.
                    /echo ${message}
                }
            } else {
                /echo EQBC is Required, but the plugin is NOT Loaded.
                /echo ${message}
            }
        } else {
            /echo ${message}
        }
        /if (${Bool[${Plugin[MQ2IRC]}]} && ${doirc}) /i say ${message}
        /echo ${message}
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire ${Window[FellowshipWnd].Child[FP_CampPage].Child[FP_CampsiteViewer].Text}
| ----------------------------------------------------------------------------
    Sub Campfire
        /if (!${CampfireOn}) /return
        /if (${CampfireTimer}) /return
        /if (${Me.Fellowship.Campfire} && (${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]} || ${Me.Fellowship.CampfireZone.Name.Find[guild hall]})) /return
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) /return
        /if (${AggroTargetID}) /return
        /if (${CombatStart}) /return
        /declare FellowCount int local 0
        /declare i int local
        /declare j int local
        /for i 1 to ${SpawnCount[pc radius 50]}
            /for j 1 to ${Me.Fellowship.Members}
                /if (${NearestSpawn[${i},PC radius 50].CleanName.Equal[${Me.Fellowship.Member[${j}]}]}) /varcalc FellowCount ${FellowCount}+1
            /next j
        /next i
        /if (${FellowCount}>=3) {
            /call Bind_Campfire
        } else {
            /echo Not enough fellowsip members trying again in 5 minutes
            /varset CampfireTimer 5m
        }
        /doevents TooSteep
    /return
| ----------------------------------------------------------------------------
| SUB: NamedWatch
| ----------------------------------------------------------------------------
    Sub NamedWatch
    /if (!${BurnAllNamed} && !${GMailEvents.Find[named]}) /return
    /if (${BurnAllNamed}==1 && ${Spawn[${MyTargetID}].Named}) {
        /popup *** Mob:(${Target.CleanName}) is a NAMED!
        /echo *** Mob:(${Target.CleanName}) is a NAMED!
        /if (${BurnAllNamed}) /call Event_Burn
        /varset NamedCheck 1 
        /if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
    } else {
        /declare i int local
        /for i 1 to 25        
            /if (${MobsToBurn.Find[null]}) /return
            /if (${MobsToBurn.Arg[${i},,].Length} && !${MobsToBurn.Find[null]} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${MyTargetID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Target.CleanName}]}) {
                /if (${BurnAllNamed}) /call Event_Burn
                /popup *** Mob:(${Target.CleanName}) is a NAMED!
                /echo *** Mob:(${Target.CleanName}) is a NAMED!    
                /if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
                /varset NamedCheck 1 
            }
        /next i
    }
    /return
| ----------------------------------------------------------------------------
| SUB: Scan ini file for errors in spelling or missing items
| ----------------------------------------------------------------------------
    Sub ScanIni
    /declare i int local 1
    /declare j int local 1 
    /declare Section1 string local Buffs
    /declare Section2 string local DPS
    /declare Section3 string local Burn
    /declare Section4 string local Heals
    /declare Section5 string local AE
    /declare Section6 string local Cures
    /declare Section7 string local Pet
    /declare Section8 string local PetBuffs
    /declare Section9 string local GoM
    /declare CountEnrties int local 0
    /declare CountErrors int local 0
    /declare iniKey string local
    /declare SummonedStuff string local null

        /for i 1 to ${BuffsSize}
        /varset iniKey ${Ini["${IniFileName}",Buffs,Buffs${i}]}
        /if (${iniKey.NotEqual[null]}) {
            /if (${iniKey.Arg[2,|].Equal[summon]}) {
                /if (${SummonedStuff.Equal[null]}) {
                    /varset SummonedStuff ${iniKey.Arg[3,|]}|
                } else {
                    /varset SummonedStuff ${SummonedStuff}${iniKey.Arg[3,|]}|
                }
            }
        }
    /next i

    /for j 1 to 9
        /echo ---------------->> Scanning ${Section${j}} <<----------------
        /varset CountEnrties 0
        /varset CountErrors 0
        /for i 1 to 20            
            /varset iniKey ${Ini["${IniFileName}",${Section${j}},${Section${j}}${i}]}
            /if (${Section${j}.Equal[Pet]} && ${i}==1) /varset iniKey ${Ini["${IniFileName}",${Section${j}},PetSpell]}
            /if (${Section${j}.Equal[Pet]} && ${i}==2) /varset iniKey ${Ini["${IniFileName}",${Section${j}},PetShrinkSpell]}
            /if (${Section${j}.Equal[PetBuffs]}) /varset iniKey ${Ini["${IniFileName}",Pet,Petbuffs${i}]}
            /if (${Section${j}.Equal[GoM]}) /varset iniKey ${Ini["${IniFileName}",GoM,GomSpell${i}]}                                    
            /if (${Section${j}.Equal[Buffs]} && ${iniKey.Arg[2,|].Equal[summon]}) /varset iniKey null                                    
            /if (${Section${j}.Equal[Buffs]} && ${SummonedStuff.NotEqual[null]} && ${SummonedStuff.Find[${iniKey.Arg[1,|]}|]}) /varset iniKey null 
            /if (${iniKey.NotEqual[null]}) {
                /if (${Debug}) /echo ScanIni: ${Section${j}}${i}=${iniKey}  \agLine#: ${Macro.CurLine}
                | find out if there is a Rank and fix spell name.
                /call SpellRankCheck "${iniKey}"
                /varset iniKey ${Macro.Return}
                /if (${Debug}) /echo ScanIni: ${iniKey} after return  \agLine#: ${Macro.CurLine}
                /if (${iniKey.Find[|]}) /varset iniKey ${iniKey.Arg[1,|]}
                /if (${Section${j}.Equal[GoM]} && ${iniKey.Find[Gift Of Mana]}) /goto :SkipInientry
                /if (${Section${j}.Equal[AE]} && ${iniKey.Find[Burn]}) /goto :SkipInientry
                /if (!${Me.Book[${iniKey}]} && !${Me.CombatAbility[${iniKey}]} && !${Me.AltAbility[${iniKey}]} && !${FindItem[=${iniKey}].ID} && ${iniKey.NotEqual[banestrike]} && !${Me.Ability[${iniKey}]}) {
                    /echo ...ERROR: ${Section${j}}${i}=${iniKey} unable to find as a  AA, Combat Ability,  Item, Skill, or Spell
                    /varcalc CountErrors ${CountErrors}+1
                }
                /varcalc CountEnrties ${CountEnrties}+1
            }
            :SkipInientry
            /if (!${CountEnrties} && ${i}==20) {
                /echo -- Nothing defined in this section
            }
            /if (!${CountErrors} && ${CountEnrties} && ${i}==20) {
                /echo -- No Spelling Errors or Missing Items Detected
            }       
        /next i
    /next j
    /return
| ----------------------------------------------------------------------------
| SUB: IniWrite - quick ini entry for spells,  aas, discs, items
| ----------------------------------------------------------------------------
    Sub Bind_IniWrite(IWSection, IWE1, IWE2, IWE3, IWE4, IWE5, IWE6)
    /if (${Debug}) /echo Bind_IniWrite: Enter  \agLine#: ${Macro.CurLine}
    /declare keyNum int local 0
    /declare IWPercent int local 100
    /declare IWSlot int local 1
    /declare IWType string local ${IWE1}
    /declare IWTypeSingle string local
    /declare IWArray int local ${${IWSection}.Size}
    /declare IWEmptySlot string local 0
    /declare IWEntry string local
    /declare i int local
    /declare j int local
    /declare k int local
    | Determine if single type 
    /if (${Select[${IWType},aa,disc,item,spell,clear]}) {
        | Set Item
        /if (${IWType.Equal[item]}) {
            /if (!${Cursor.ID}) {
                /echo ..SET${IWSection}: You need to put the item on your cursor.
                /return
            }
            /varset IWTypeSingle ${Cursor.Name}
            /echo ${IWTypeSingle}
        }
        | Set Spell
        /if (${IWType.Equal[spell]}) {
            /if (!${Me.Gem[${IWE2}].Name.Length}) {
                /echo ..SET${IWSection}: You need to mem a spell
                /return
            }
            /varset IWTypeSingle ${Me.Gem[${IWE2}].Name}
         }
        | Set AA
        /if (${IWType.Equal[aa]}) {
            /if (!${Me.AltAbility[${IWE2}]}) {
                /echo ..SET${IWSection}: You don't have that AA
                /return
            }
            /varset IWTypeSingle ${Me.AltAbility[${IWE2}].Name}
        }
        | Set Disc/Combat Ability
        /if (${IWType.Equal[disc]}) {
            /if (!${Select[${IWE2},1,2,3,4,5,6,7,8]}) {
                /echo ..SET${IWSection}: Disc # must be a Combat Abilty Button 1-8 
                /return
            }
            /if (!${Me.CombatAbility[${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}]}) {
                /echo ..SET${IWSection}: You don't have that Disc or Combat Ability button ${IWE2} is empty.
                /return
            }
            /varset IWTypeSingle ${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}
        }
        | Final Catchall for error control
        /if (!${IWTypeSingle.Length}) {
            /echo ..SET${IWSection}: ${IWType} parameter is blank. Please provide a ${IWType}
            /return
        }
        | Find empty slot & check if entry exists
        /echo ..SET${IWSection}: Looking of for spot to write ${IWTypeSingle}
        /for k 1 to ${IWArray}
            /varset IWEntry ${Ini[${IniFileName},${IWSection},${IWSection}${k}]}
            /if (${IWSection.Equal[DPS]}) /varset IWPercent 90
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            /if (${Debug}) /echo ${${IWSection}[${k}].Length} \agLine#: ${Macro.CurLine}
            /if (${IWEntry.Find[${IWTypeSingle}]}) {
                /echo ..SET${IWSection}: Duplicate entry ${IWSection}${k}=${IWTypeSingle} skipping.
                /return
            }
            /if (${IWEntry.Equal[null]} && ${IWEmptySlot}==0) {
                /varset IWEmptySlot ${k}
            }
            /if (${k}==${IWArray} && !${IWEmptySlot}) /varset IWEmptySlot ${k}
        /next k
        /if (${IWEmptySlot}==${IWArray}) {
            /echo ..SET${IWSection}: No empty slots in ${IWSection} to write
            /return
        }
        /if (${Select[${IWSection},DPS,Heals]}) {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}|${IWPercent}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}|${IWPercent}
        } else {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}
        }
        /return
    }    
    /echo ..SET${IWSection}: This command will write over current ${IWSection} settings 
    /for i 1 to ${IWArray}
        /varset keyNum ${i}
        /if (${Me.Gem[${IWE${i}}].Name.Length} && ${i}<7) {
            /if (${IWSection.Equal[DPS]}) /varcalc IWPercent ${IWPercent}-5
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            /if (${Select[${IWSection},DPS,Heals]}) {
                /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}|${IWPercent}"
                /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}|${IWPercent}
            }
            /if (${Select[${IWSection},Buffs]}) {
                /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}"
                /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}
            }
            /varcalc IWSlot ${IWSlot}+1
            /delay 10
        }
    /next i
    /return
|-----------------------------------------------------------------------------
| SUB: Campfire back to camp
| ----------------------------------------------------------------------------
    Sub CampfireBack
        /if (!${ClickBacktoCamp}) /return
        /if (${CampfireClickTimer}) /return
        /if (${Me.Hovering}) /return
        /varset CampfireClickTimer 1m
        | Am I Dead?
        /if (${Me.Buff[Revival Sickness].ID} && ${CampZone} != ${Zone.ID}) /varset IAmDead 1
        /if (${IAmDead}) {
            | Does Campfire Exist?
            /if (!${Me.Fellowship.Campfire}) {
                /echo There is no campfire up.
                /return
            }
            | Am I & the campfire in the same zone?
            /if (${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]}) {
                /echo I'm back in the same zone as my campfire. 
                /varset IAmDead 0
                /return
            }
            /if (${FindItem[Fellowship Registration Insignia].TimerReady} == 0) {
                /echo Time to get back to work. Clicking Fellowship Insignia in 30 seconds.
                | Delay for rest state to kick in
                /delay 30s
                /squelch /nomodkey /itemnotify "Fellowship Registration Insignia" rightmouseup
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Debug All
| ----------------------------------------------------------------------------
    Sub Bind_DebugAll
            /if (${EverQuest.CurrentUI.NotEqual[Default]}) {
                /echo You are using a Custom UI. Please switch to Default UI before Posting.
            }
        /if (!${DebugAllOn}) {
            /varset DebugAllOn 1
            /echo \atDEBUG ALL On
        } else {
            /varset DebugAllOn 0
            /echo \atDEBUG ALL Off
        }
        /varset Debug ${DebugAllOn}
        /varset DebugBuffs ${DebugAllOn}
        /varset DebugCombat ${DebugAllOn}
        /varset DebugHeal ${DebugAllOn}
        /varset DebugMez ${DebugAllOn}
        /varset DebugMove ${DebugAllOn}
        /varset DebugPet  ${DebugAllOn}
        /varset DebugPull ${DebugAllOn}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd1
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateAdd1
        /varset PetActiveState  0
        /varset PetSuspendState 1
        /varset PetTotCount     1
        /if (${DebugPet}) /echo PetSusStateAdd1 triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd2
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateAdd2
        /varset PetActiveState  1
        /varset PetSuspendState 1
        /varset PetTotCount     2
        /if (${DebugPet}) /echo PetSusStateAdd2 triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateSub
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateSub
        /varset PetActiveState  1    
        /varset PetSuspendState 0
        /varset PetTotCount     1
        /if (${DebugPet}) /echo PetSusStateSub triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return   
|-----------------------------------------------------------------------------  
| SUB: Back Off and stop melee  
| ----------------------------------------------------------------------------      
    Sub Bind_BackOff(string OnOffFlag)
        /if (${Select[${OnOffFlag},on,off,1,0]}>0) {
            /if (${Select[${OnOffFlag},on,1]}>0) {
                /varset DPSPaused 0
            } else {
                /varset DPSPaused 2
            }
        }
        /if (${DPSPaused}) {  
            /if (${DPSPaused}==2 && ${UseMQ2Melee}) /squelch /melee on
            /varset DPSPaused 0  
            /echo Resetting. No Longer Backing off.  
        } else {  
            /varset DPSPaused 1  
            /varset CombatStart 0  
            /if (${UseMQ2Melee}) /squelch /melee off
            /squelch /attack off  
            /if (${Stick.Active}) /stick off 
            /call CombatReset 0 backoff
            /varset DPSPaused 2 
            /echo Backing off - All Combat has been reset.
        }  
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {  
            /call DoWeMove 0 bind_backoff
        }  
        /doevents flush BackOff  
    /return 
| -------------------------------------------------------------------------------------
| SUB: Event PetToysPlease 
| -------------------------------------------------------------------------------------    
    Sub Event_PetToysPlease(Message,string MTPet)
        /if (!${MTPet.Length}) /return
        /if (${MTPet.Find[null]}) /return
        /if (${Spawn[${MTPet}].Type.NotEqual[Pet]} && ${MTPet.NotEqual[group]}) /return
        /declare PTPPetID int local
        /declare GMemID int local
        /declare GMemShortName string local
        /declare GMemPetName string local
        /declare i int local 0
        /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: Enter \agLine#: ${Macro.CurLine}
        | If group command give all pets in group toys
        /if (${MTPet.Find[GROUP]}) {
            /echo I am giving pet toys to every Pet in Group except mine.
            | Start at 1 my pet doesn't need toys
            /for i 1 to 5
            /varset GMemID ${Group.Member[${i}].ID};
            /varset PTPPetID ${Group.Member[${i}].Pet.ID}
            /varset GMemShortName ${Group.Member[${i}].Class.ShortName} 
            /varset GMemPetName ${Group.Member[${i}].Pet.CleanName}
            /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: ${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]} \agLine#: ${Macro.CurLine}
            /if (${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}) {
                /if (${PetToysOn}) /call pettoys ${GMemPetName}
            }
            /next i
        } else {
            | Individual Pet.
            /if (${PetToysOn}) {
                /echo Giving pet toys to (${MTPet}).
                /call pettoys ${MTPet}
            }
        }
        /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Add stuff to alert list  
| -------------------------------------------------------------------------------------      
    Sub AlertAddToList(int whatlist, MvarList, IDvarList)
        /if (${Debug}) /echo \atDEBUG AlertAddToList List:${whatlist} Mlist: ${MvarList} \agLine#: ${Macro.CurLine}
        /declare k int local
        | Clear ignore mobs alert from list before assigning from ini list
        /squelch /alert clear ${whatlist}
        /if (${MvarList.Length} && !${MvarList.Find[null]}) {
            /for k 1 to 25
                /if (${MvarList.Arg[${k},,].Length} && !${MvarList.Find[null]} && ${Debug}) /echo \atDEBUG ADD ${MvarList.Arg[${k},,]} to ${MvarList}
                /if (${MvarList.Arg[${k},,].Length}) {
                    /if (${MvarList.Arg[${k},,].Find[*]}) {
                        /squelch /alert add ${whatlist} "${MvarList.Arg[${k},,].Replace[*,]}"
                    } else {
                        /squelch /alert add ${whatlist} "=${MvarList.Arg[${k},,]}"
                    }
                    /if (${Debug}) /echo \atDEBUG AlertAddToList Add ${MvarList.Arg[${k},,]} to Alert List ${whatlist} \agLine#: ${Macro.CurLine}
                }
            /next k
        }
        | Add by mob ID for mobs that wonder out of range when trying to pull.
        /if (${IDvarList.Length} && ${IDvarList.NotEqual[null]}) {
            /varset k 1
            /while (${IDvarList.Arg[${k},|].Length} && ${IDvarList.Arg[${k},|].NotEqual[null]} && ${Int[${IDvarList.Arg[${k},|]}]}>0) {
                /if (${Debug}) /echo \atDEBUG ADD ${IDvarList.Arg[${k},|]} to ${MvarList}
                /if (${Int[${IDvarList.Arg[${k},|]}]}>0) /squelch /alert add ${whatlist} id ${IDvarList.Arg[${k},|]}
                /if (${Debug}) /echo \atDEBUG AlertAddToList Add ${IDvarList.Arg[${k},|]} to Alert List ${whatlist} \agLine#: ${Macro.CurLine}
                /varcalc k ${k}+1
            }
        }
        /if (${Debug}) /echo \atDEBUG AlertAddToList Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mount
| -------------------------------------------------------------------------------------      
    Sub CastMount
        /if (${Me.Mount.ID}) /return
        /if (!${MountOn}) /return
        /if (${Me.Invis}) /return
        /if (${HealsOn} && ${AggroTargetID}) /return
        /declare i int local
        /for i 1 to ${Buffs.Size}
        | Cast mount
        /if (${Buffs[${i}].Arg[2,|].Equal[Mount]} && !${Buffs[${i}].Find[0]} && !${Me.Mount.ID} && !${Attacking} && ${MountOn} && !${Me.FeetWet}) {
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Mount \agLine#: ${Macro.CurLine}
            /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} CastMount
            /delay 1s
            /if (${Macro.Return.Equal[CAST_OUTDOORS]}) /varset MountOn 0
            |/call CheckCasting 80
        }
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mana
| -------------------------------------------------------------------------------------      
    Sub CastMana(string SentFrom)
        /if (${Me.Invis}) /return
        /if (${DebugBuffs}) /echo \atDEBUG CastMana Enter ${SentFrom} \agLine#: ${Macro.CurLine}
        /declare i int local
        /for i 1 to ${Buffs.Size}    
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) {
                /varset GoMByPass 1
                /call DoMezStuff CastMana
                /varset GoMByPass 0
            }
        }
        /if (${HealsOn}) /call CheckHealth
        | Check and Cast mana type spells/aas/items - Canni/Paragon/Harvest - prevent toon from using before rez after zoning for 2 min
        /if (!${ConditionsOn} || !${BuffsCOn} || ${If[${BuffsCond[${i}]},1,0]}) {
            /if (${Buffs[${i}].Arg[2,|].Equal[Mana]} && !${Me.Buff[Revival Sickness].ID} && !${JustZoned}) {
                /if (${Buffs[${i}].Arg[1,|].Equal[Dichotomic Psalm]} && (${IAmABard}|| ${Me.CurrentEndurance}<6600)) /goto SkipMe
                /if (${Me.PctMana}<=${Buffs[${i}].Arg[3,|]} && ${Me.PctHPs}>${Buffs[${i}].Arg[4,|]}) {
                    /if (${Cursor.ID}) /call CheckCursor CastMana
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS Canni/Paragon/Harvest \agLine#: ${Macro.CurLine}
                        /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} Buffs
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Casting >> ${Buffs[${i}].Arg[1,|]} << for mana
                }
                :SkipMe
            }
        }
        /if (${Buffs[${i}].Arg[2,|].Equal[Managroup]} && (!${Medding} || (!${MedCombat} && ${Medding}))) /call RegenOther "${Buffs[${i}].Arg[1,|]}" Mana ${Buffs[${i}].Arg[3,|]} 0
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: You Hit DPS Meter
| -------------------------------------------------------------------------------------      
    Sub Event_YouHit(string Line, string YHMob, string YHDamage, string YHSpell)
        /if (!${Defined[YHSpell]}) {
            /declare YHSpell string local null
        }    
        /if (!${DPSMeter}) {
            /doevents YouHit flush
            /return
        }
        /if (!${Defined[DPSTimeStart${MyTargetID}]}) {
            /declare DPSTimeStart${MyTargetID} int outer ${Time.SecondsSinceMidnight}
            /varset DPSTarget ${Target.ID}
        }
        /declare DPSType string local
        /declare DPSTime int local 
        /varset DPSTime ${Math.Calc[${Time.SecondsSinceMidnight}-${DPSTimeStart${MyTargetID}}]}
        /if (${YHSpell.Equal[null]}) {
            /if (${Line.Find[backstab]}) /varset DPSType Backstab        
            /if (${Line.Find[bash]}) /varset DPSType Bash
            /if (${Line.Find[bite]}) /varset DPSType Bite
            /if (${Line.Find[claw]}) /varset DPSType Claw
            /if (${Line.Find[crush]}) /varset DPSType Crush
            /if (${Line.Find[frenz]}) /varset DPSType Frenzy
            /if (${Line.Find[kick]}) /varset DPSType Kick
            /if (${Line.Find[maul]}) /varset DPSType Maul
            /if (${Line.Find[non-melee]}) /varset DPSType Non-melee
            /if (${Line.Find[pierce]}) /varset DPSType Pierce
            /if (${Line.Find[punch]}) /varset DPSType Punch
            /if (${Line.Find[slash]}) /varset DPSType Slash
            /if (${Line.Find[slam]}) /varset DPSType Slam
            /if (${Line.Find[slice]}) /varset DPSType Slice        
            /if (${Line.Find[sting]}) /varset DPSType Sting
        }
        /if (${YHSpell.Length}>=1) /varset DPSType Spell
        /if (${Line.Find[${Me.Pet.CleanName}]})  /varset DPSType Pet
        /if (${Line.Find[${Me}`s pet]})  /varset DPSType Pet
        /if (${Line.Find[${Me}`s warder]})  /varset DPSType Pet
 
        /varcalc DPSCounter ${DPSCounter}+1
        /if ((${Line.Find[${Me.Pet.CleanName}]} || ${Line.Find[${Me}`s pet]} ||  ${Line.Find[${Me}`s warder]}) && ${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0) /varcalc DPSPetTotal ${DPSPetTotal}+${YHDamage}
        /if (${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0 && ${DPSType.NotEqual[pet]}) /varcalc DPSTotal ${DPSTotal}+${YHDamage}
        | Return to avoid divide by 0 errors in calculations
        /if (${DPSTime}<=0 || !${DPSTarget}) /return
        /if (${DPSSpam} && ${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0) /echo Mob/ID: ${YHMob}/${DPSTarget} -  Type: ${DPSType}/${YHDamage} - Total Damage: ${DPSTotal} - Time: ${DPSTime}s - DPS: ${Math.Calc[${DPSTotal}/${DPSTime}]}
        /varset DPSLastTime ${DPSTime}
    /return
| -------------------------------------------------------------------------------------
| SUB: Comma Me Bro - CommaNation Domination
| ------------------------------------ -------------------------------------------------           
    Sub CommaMeBro(string cmbnumber)
        /declare CommaNator string local 
        | Strip out any decimal points 
        /varset cmbnumber ${cmbnumber.Arg[1,.]}
        /if (${cmbnumber.Length}<=3 ) /varset CommaNator ${cmbnumber}
        /if (${cmbnumber.Length}>3 && ${cmbnumber.Length}<=6) /varset CommaNator  ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-3]}]},${cmbnumber.Right[3]}
        /if (${cmbnumber.Length}>6  && ${cmbnumber.Length}<=9) /varset CommaNator ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-6]}]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-5]},3]},${cmbnumber.Right[3]}
        /if (${cmbnumber.Length}>9) /varset CommaNator ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-9]}]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-8]},3]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-5]},3]},${cmbnumber.Right[3]}
    /return ${CommaNator}
| -------------------------------------------------------------------------------------
| SUB: Event_Timer 
| ------------------------------------ -------------------------------------------------           
    Sub Event_Timer(Timer, OriginalValue)
        /if (${Debug}) /echo \atDEBUGBUFFS Event_Timer Enter \agLine#: ${Macro.CurLine}
        /if (${Select[${Timer},TributeTimer,AggroOffTimer,TellTimer]}==0) /return
        /if (${Timer.Equal[TributeTimer]}) {
            /if (${UseTribute} && ${Me.TributeActive}) {
                /if (!${AggroTargetID} || (${Target.ID} && !${Target.Named})) {
                    /squelch /tribute personal off
                } else {
                    /if (${Target.ID} && ${Target.Named}) /varset ${Timer} 580s
                }      
            }
        }
        /if (${Timer.Equal[AggroOffTimer]}) {
            /if (${Me.Feigning}) /stand
            /if (${Me.Invis}) /makemevisible
        }
        /doevents flush Timer
        /if (${Debug}) /echo \atDEBUGBUFFS Event_Timer leave \agLine#: ${Macro.CurLine}
        /return
| -------------------------------------------------------------------------------------
| SUB: SpellRankCheck
| ------------------------------------ -------------------------------------------------           
    Sub SpellRankCheck(Rk_Check_What)
        /declare DebugRk                int         local 0
        /declare rkCheck                string      local null
        /declare rkCheck1               string      local 
        /declare rkdCheck               string      local
        /declare rkTemp                 string      ${Rk_Check_What.Arg[1,|]}
        /declare rkdTemp                string      ${Rk_Check_What.Arg[3,|]}
        |/varset DebugRk 1
        /if (${DebugRk}) /echo \atDEBUG SpellRankChecks: Enter \agLine#: ${Macro.CurLine}
        /if (${Rk_Check_What.Left[1].Equal[0]} || ${Int[${Rk_Check_What.Left[1]}]}>0) /return ${Rk_Check_What}
        | Check for Rk. in spell name and Remove it.   
        /if (${rkTemp.Find[ Rk.]}) {
            /varset rkTemp ${rkTemp.Left[${Math.Calc[${rkTemp.Find[ Rk.]}-1]}]} 
        }
        /if (${Int[${Me.Book[${rkTemp}]}]}==0 && ${Int[${Me.Book[${Spell[${rkTemp}].RankName}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}==0 && ${Int[${Me.CombatAbility[${Spell[${rkTemp}].RankName}]}]}==0) /return ${Rk_Check_What}
        /if (${DebugRk}) /echo \atDEBUG SpellRankChecks: 1 rkCheck: "${rkCheck}" rkTemp: "${rkTemp}" rkdCheck: "${rkdCheck}" rkdTemp: "${rkdTemp}"  \agLine#: ${Macro.CurLine}
        | If this is NOT an Alt Ability then it must be a spell.
        /if (${Int[${Me.AltAbility[${rkTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
           /if (${DebugRk}) /echo 1a. well we think ${rkTemp} is an AA
           /varset rkCheck ${rkTemp}
        } else {
           /if (${DebugRk}) /echo 1c. well ${rkTemp} is not an AA or CombatAbility
           /varset rkCheck ${Spell[${rkTemp}].RankName}
        }
        | check for null
        /if (${DebugRk}) /echo \atDEBUG SpellRankChecks: 2 rkCheck: ${rkCheck} rkTemp: ${rkTemp} Rk_Check_What: ${Rk_Check_What} \agLine#: ${Macro.CurLine}
        | must NOT be null so lets fix Rk_Check_What.
        /if (${rkCheck.NotEqual[${rkTemp}]}) {
            /if (${Rk_Check_What.Find[|]}>0) {
                /varset rkCheck1 ${rkCheck}${Rk_Check_What.Right[-${Math.Calc[${Rk_Check_What.Find[|]}-1]}]} 
                /varset rkCheck ${rkCheck1}
            }
        } else {
            /varset rkCheck ${Rk_Check_What}
        }
        /if (${Rk_Check_What.Arg[2,|].Equal[dual]}) {
           /if (${rkdTemp.Find[ Rk.]}) {
               /varset rkdTemp ${rkdTemp.Left[${Math.Calc[${rkdTemp.Find[ Rk.]}-1]}]} 
           }
           /if (${Int[${Me.AltAbility[${rkdTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
               /varset rkdCheck ${Spell[${rkdTemp}].RankName}
           } else {
               /if (${Me.Subscription.NotEqual[gold]}) {
                   /varset rkdCheck ${rkdTemp}
               } else {
                   /varset rkdCheck ${Spell[${rkdTemp}].RankName}
               }
           }
           /if (${DebugRk}) /echo \atDEBUG SpellRankChecks: 3 rkdCheck: ${rkdCheck} rkdTemp: ${rkdTemp} Rk_Check_What: ${Rk_Check_What} \agLine#: ${Macro.CurLine}
           /varset rkCheck ${rkCheck.Arg[1,|]}|dual|${rkdCheck}
        }
        /if (${DebugRk}) /echo \atDEBUG SpellRankChecks: 4 Rk_Check_What: ${Rk_Check_What} rkCheck: ${rkCheck} rkTemp: ${rkTemp}  \agLine#: ${Macro.CurLine}
        /if (${DebugRk}) /echo \atDEBUG SpellRankChecks: leave \agLine#: ${Macro.CurLine}
        |/varset DebugRk 0
    /return ${rkCheck}
| -------------------------------------------------------------------------------------
| SUB: Check cursor
| -------------------------------------------------------------------------------------           
    Sub CheckCursor(string SentFrom)
        /if (${Debug}) /echo \atDEBUG CheckCursor: enter \agLine#: ${Macro.CurLine}
        :inventory
            /if (${Debug} && ${Cursor.ID}) /echo Dropping ${Cursor} ${SentFrom}
            /autoinventory
            /delay 10
        /if (${Cursor.ID}) /goto :inventory
        /if (${Debug}) /echo \atDEBUG CheckCursor: leave \agLine#: ${Macro.CurLine}
    /return      
| -------------------------------------------------------------------------------------
| SUB: Event LeftGroup
| ------------------------------------------------------------------------------------- 
    Sub Event_LeftGroup(Line,LGName)
        /if (${GMailEvents.Find[leftgroup]}) /call GmailSend "${LGName} has left the group."
        /doevents flush LeftGroup
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind ZoneInfo
| ------------------------------------------------------------------------------------- 
    Sub Bind_ZoneInfo
        /declare LineInfo string local
        /echo -------------------------------------------------------------------------
        /echo  ${ZoneName}
        /echo -------------------------------------------------------------------------
        /echo MezImmune: ${Ini[${InfoFileName},${ZoneName},MezImmune]}
        /echo MobsToPull: ${Ini[${InfoFileName},${ZoneName},MobsTopull]}
        /echo MobsToIgnore: ${Ini[${InfoFileName},${ZoneName},MobsToIgnore]}
        /echo MobsToBurn: ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
        /echo -------------------------------------------------------------------------
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind WriteMySpell
| ------------------------------------------------------------------------------------- 
    Sub Bind_WriteMySpells
        /declare i int local
            /for i 1 to 13
            /echo Gem ${i}: ${Me.Gem[${i}].Name}
            /ini "${IniFileName}" "MySpells" "Gem${i}" "${Me.Gem[${i}].Name}"
        /next i
    /return  
| -------------------------------------------------------------------------------------
| SUB: Bind MemMySpells
| ------------------------------------------------------------------------------------- 
   Sub Bind_MemMySpells(Message)
        /declare temppCharName          string      local
        /declare pCharName              string      local ${Message}
        /declare tempIniFileName        string      local
        /declare pKV                    string      local
        /declare i                      int         local
        /declare ii                     int         local
        /declare SpellToMem             string      local       
        /declare tempSpellName          string      local 
        
        /if (${Debug}) /echo \atDEBUG MemMySpells: Enter \agLine#: ${Macro.CurLine}
        /if (!${pCharName.Length} || ${pCharName.Equal[null]}) {
           /varset temppCharName ${Me.CleanName}
        } else {
           /varset temppCharName ${pCharName}
        }
		/if (${temppCharName.NotEqual[${Me.CleanName}]}) {
        /if (${Ini[${MacroName}_${EverQuest.Server}_${temppCharName}.ini,General,KissAssistVer].Length}) {
            /varset tempIniFileName ${MacroName}_${EverQuest.Server}_${temppCharName}.ini
            /echo Server Name ini file detected using ${tempIniFileName}
        } else {
            /varset tempIniFileName ${MacroName}_${temppCharName}.ini
        }
		} else /if (!${PIniSet}) {
		    /varset tempIniFileName ${MacroName}_${temppCharName}.ini
		} else {
		    /varset tempIniFileName ${IniFileName}
		}
        /varset pKV ${Ini[${tempIniFileName},General,KissAssistVer]}
        /if (${Int[${pKV}]}==0) {
           /echo Invalid INI file: ${tempIniFileName} for memorizing spells. Returning.
           /return
        }
        /varset pKV ${Ini[${tempIniFileName},"MySpells",Gem1]}
        /if (${Int[${pKV.Length}]}==0) {
           /echo No Spells found in INI file: ${tempIniFileName}. Use /writespells and try again. Returning.
           /return
        }
        /for i 1 to 13
            /varset SpellToMem ${Ini[${tempIniFileName},"MySpells",Gem${i}]}
            /if (${SpellToMem.Length} && ${SpellToMem.NotEqual[null]}) {
                /if (${SpellToMem.Find[ Rk.]}) {
                   /varset tempSpellName ${SpellToMem.Left[${Math.Calc[${SpellToMem.Find[ Rk.]}-1]}]} 
                } else {
                   /varset tempSpellName ${SpellToMem} 
                }
                /varset SpellToMem ${Spell[${tempSpellName}].RankName}
                /if (${Me.Book[${SpellToMem}]}) {
                    /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && ${Int[${Me.Gem[${SpellToMem}]}]}!=${i}) {
                        /varcalc ii ${Int[${Me.Gem[${SpellToMem}]}]}-1
                        /notify CastSpellWnd CSPW_Spell${ii} rightmouseup
                        /delay 20 ${Int[${Me.Gem[${SpellToMem}]}]}==0
                    }
                    /if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${SpellToMem}]}) {
                        /varset DontMoveMe 1
                        /while (${Me.Moving}) {
                            /delay 5
                        }
                        /echo Meming ${SpellToMem} in slot ${i}
                        /if (${Stick.Active}) {
                            /stick pause
                            /MemSpell ${i} "${SpellToMem}"
                            /delay 90 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]}
                            /stick unpause
                        } else {
                            /MemSpell ${i} "${SpellToMem}"
                            /delay 90 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]}
                        }
                        /varset DontMoveMe 0
                    }
                } else {
                    /echo Could Not find the spell ${SpellToMem} in your spell book.
                }
            }
        /next i   
    /if (${Debug}) /echo \atDEBUG MemMySpells: leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind Parse
| -------------------------------------------------------------------------------------
    Sub Bind_Parse(TimeToParse)
        /if (${Debug}) /echo \atDEBUGBUFFS Bind_Parse Enter \agLine#: ${Macro.CurLine}
        /if (!${Defined[ParseDPS]}) /declare ParseDPS     timer       outer       0
        /echo Parsing combat for ${TimeToParse} seconds
        /tar npc dummy
        /delay 10 ${Target.ID}
        /varset MyTargetID ${Target.ID}
        /varset MyTargetName ${Target.CleanName}
        /varset ParseDPS ${TimeToParse}s
        /call Combat
        /call CombatReset 0 parse
        /target clear
        /attack off
        /stick off
        /endmacro
        /if (${Debug}) /echo \atDEBUGBUFFS Bind_Parse Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind_TrackMeDown
| -------------------------------------------------------------------------------------
    Sub Bind_TrackMeDown(int StickOff, int UseNavOnly, int IgnoreDistance)
        /if (${DontMoveMe}) {
            /echo WAIT UP! I was told not to move. Leaving TrackMeDown.
            /return
        }
        /if (${Debug}) /echo \atDEBUG Bind_TrackMeDown Enter \agLine#: ${Macro.CurLine}
        /declare tmdChaseAssist int local ${ChaseAssist}
        /declare tmdReturnToCamp int local ${ReturnToCamp}
        /declare tmdChaseDistance int local ${ChaseDistance}
        /declare tmdCampRadiusExceed int local ${CampRadiusExceed}
        | Check if I am Dead.
        /if (${Me.Hovering} || ${IAmDead}) /return
        | Check if Who to chase character is in the zone.
        /if (${Spawn[pc ${WhoToChase}].ID}==0) /return
        /varset BindActive 1
        | Check if we are to use Navigation and it is loaded with a valid Mesh and Path.
        /if (${UseNavOnly} ) {
            /if (${PullMoveUse.NotEqual[nav]} || !${Navigation.MeshLoaded}) {
                /echo I can't Track Down ${WhoToChase}. Navigation not loaded or bad Mesh.
                /return
            } else {
                /if (${Navigation.PathExists[id ${Spawn[pc ${WhoToChase}].ID}]}==FASLE)
                /echo I can't Track Down ${WhoToChase}. No Valid Path too destination.
                /return
            }
        }
        /varset ChaseAssist 2
        /varset ReturnToCamp 0
        /varset ChaseDistance 20
        /if (${IgnoreDistance}) /varset CampRadiusExceed 100000
        
        /if (${Me.Casting.ID}) /Interrupt
        | Go chase them down.
        /call DoWeChase TrackMeDown
        
        | Set things back
        /if (${tmdReturnToCamp}) {
            /varset CampXLoc ${Me.X}
            /varset CampYLoc ${Me.Y}
            /varset CampZLoc ${Me.FloorZ}
            /varset LookForward ${Me.Heading.DegreesCCW}
            /echo >> New camp set ${Me.Y}, ${Me.X}
        }
        /if (${StickOff}) {
            /if (${Stick.Active}) /squelch /stick off
        }
        /varset ChaseAssist ${tmdChaseAssist}
        /varset ReturnToCamp ${tmdReturnToCamp}
        /varset ChaseDistance ${tmdChaseDistance}
        /varset CampRadiusExceed ${tmdCampRadiusExceed}
        /varset BindActive 0
        /if (${Debug}) /echo \atDEBUG Bind_TrackMeDown Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| Task Code
| -------------------------------------------------------------------------------------
| SUB: Unmount
| -------------------------------------------------------------------------------------
    Sub Event_KTDismount
        /if (${MountOn}) /varset MountOn 0
        /if (${Me.Mount.ID}) /dismount
    /return
|-----------------------------------------------------------------------------
| SUB: Target NPC
| ----------------------------------------------------------------------------        
    Sub Event_KTTarget(Line, NPCName)
        /echo Targeting ${NPCName}
        /if (${NPCName.Equal[null]}) {
            /echo NPC Name is Null. Check your variables.
            /return FALSE
        }
        /if (!${Spawn[npc ${NPCName}].ID}) {
            /echo ${NPCName}? You must be in the wrong palce, no one here by that name
            /return FALSE
        }
        /target id ${Spawn[${NPCName}].ID}
        /delay 3s ${Target.ID}==${Spawn[${NPCName}].ID}
        /if (${Target.Distance}>15 && ${Target.Distance}<50) {
            /moveto id  ${Spawn[${NPCName}].ID}
            /delay 250 ${MoveTo.Stopped}
        }
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /call ZAxisCheck ${ZDist} 4.1
        /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
        /delay 10
        /return TRUE
|-----------------------------------------------------------------------------
| SUB: KTHail
| ----------------------------------------------------------------------------    
    Sub Event_KTHail(Line, KTMobID)
        /tar id ${Spawn[npc ${KTMobID}].ID}
        /delay ${Math.Rand[20]}
        /keypress h
        /doevents flush KTaskSay
    /return            
|-----------------------------------------------------------------------------
| SUB: KTSay
| ----------------------------------------------------------------------------    
    Sub Event_KTSay(Line, KTSayWhat)
        /delay ${Math.Rand[20]}
        /say ${KTSayWhat}
        /delay 10
        /doevents flush KTaskSay
    /return
|-----------------------------------------------------------------------------
| SUB: TaskDoorTarget
| ----------------------------------------------------------------------------    
    Sub Event_KTDoorClick(Line, int KTDoorID)
    /declare KTCDTimer timer local 10s
    /if (!${Defined[KTDoorID]}) {
        /doortarget 
        /delay 3
        /declare KTDoorID ${DoorTarget.ID}
    }
    /echo DoorID: ${KTDoorID}
        /delay 10
        /keypress FIRST_PERSON_CAMERA hold
        /delay 2
        /keypress FIRST_PERSON_CAMERA
        /delay 10
        /if (${Target.ID}) /squelch /tar clear
        /delay 3
        :retrydoortarget
        /echo target door id ${KTDoorID}
        /if (${KTDoorID}) {
            /doortarget id ${KTDoorID}
        } else /doortarget 
        /delay 3
        /echo ${DoorTarget.Name}
        /if (!${Switch.ID}) {
            /if (${KTCDTimer}) /goto :retrydoortarget
        }
        /face door
        /delay 3
        :retryopendoor
        /if (${DoorTarget.Distance}<=70)  {
        /echo Moving to Door 
            /if (${DoorTarget.Distance}>15) {
                /keypress forward hold
                /delay 3
                /keypress forward
            } else /if (${DoorTarget.Distance}<10) {
                /keypress back hold   
                /delay 1
                /keypress back
            }
        }
        /if (!${Switch.Open} || ${DoorTarget.Name.Length}) {
            /face door
            /delay 3
            /echo clicking door
            /click left door
            /delay 1s
            /if (${KTCDTimer}) /goto :retryopendoor
        }
        /if (${Window[largedialogwindow].Open}) {
            /notify largedialogwindow LDW_YesButton leftmouseup
        }
        /doevents flush KTDoorClick
    /return
|-----------------------------------------------------------------------------
| SUB: KTInvite
| ----------------------------------------------------------------------------       
    Sub Event_KTInvite
        /declare i int 
        /declare WhoToInvite ${SpawnCount[pc radius 75 guild]}
        /alert clear 6 
        /squelch /alert add 6 ${Me}
        /for i 1 to ${WhoToInvite}
            /target id ${NearestSpawn[radius 75 pc guild noalert 6].ID}
            /delay 10
            /invite
            /delay 20
            /bct ${Target.CleanName} //invite
            /delay 10 
            /squelch /alert add 6 id ${Target.ID}
        /next i
    /return
|-----------------------------------------------------------------------------
| SUB: AssignLooter
| ----------------------------------------------------------------------------       
    Sub AssignLooter
        /if (${Select[${Me},${Group.Leader}]}==0) /return
        /if (${LooterAssigned}) /return
        /if (${Group}<=0) /return
        /if (${Group.MasterLooter.ID}>=1) /return
        /if (${Debug}) /echo \atDEBUG Sub AssignLooter Enter \agLine#: ${Macro.CurLine}
        /declare k int local
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        | If I am group leader set Main Looter Tag for Group
        /if (${Select[${Me},${Group.Leader}]}) { 
            /if (${Debug}) /echo \atDEBUG AssignLooter: /echo I am group Leader \agLine#: ${Macro.CurLine}
            |Assign myself as MainLooter if LootOn=1
            /if (${LootOn}) {
            /if (${Debug}) /echo \atDEBUG AssignLooter: /echo I am the looter \agLine#: ${Macro.CurLine}
                /if (${Group.MasterLooter.Name.NotEqual[${Me}]} && ${Group.MasterLooter.Name.Length}) {
                    /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                    /delay 30 !${Group.MasterLooter.Name.Length}
                    /call AssignGroupRole set "${Group.MainAssist.Name}" 5
                    /call BroadCast ${IRCOn} ${EQBCOn} r "Assigning ${Me} as Master Looter in Group Window"
                    /varset LooterAssigned 1
                    /return
                }
            }
            /if (${LootOn}==0) {
                /if (${Debug}) /echo \atDEBUG AssignLooter: Looking for looter \agLine#: ${Macro.CurLine}
                /for k 1 to ${IniIDCount}
                    /if (${Debug}) /echo \atDEBUG AssignLooter: ${Spawn[${IniIDList.Arg[${k},|]}].ID} ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"AmILooting"]}  ${Spawn[${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} ${Spawn[id ${IniIDList.Arg[${k},|]} group].ID} \agLine#: ${Macro.CurLine}
                    | If toon is not the zone or not a PC skip to next ID
                    /if (!${Spawn[id ${IniIDList.Arg[${k},|]}].ID} || ${Spawn[id ${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} || !${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"AmILooting"]}) /goto :NextLooterCheck
                    /if (${Spawn[id ${IniIDList.Arg[${k},|]} pc group].ID}) {
                        | If Looter is someone else than who its suppose to be unset Group tag
                        /if (${Group.MasterLooter.Name.Length} && ${Group.MasterLooter.Name.NotEqual[${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName}]}) /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                        /delay 30 !${Group.MasterLooter.Name.Length}
                        /call AssignGroupRole set "${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName}" 5
                        /call BroadCast ${IRCOn} ${EQBCOn} r "LOOT: Assigning ${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName} as Master Looter in Group Window"
                        /varset LooterAssigned 1
                        /return
                    }
                :NextLooterCheck
                /next k
            }
        }
        /if (${Debug}) /echo \atDEBUG Sub AssignLooter Leave \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: GmailParse
| ----------------------------------------------------------------------------
    Sub GmailIniParse
        /if (${Debug}) /echo \atDEBUGBUFFS GmailSend Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare GMailEventCheck string local
        /for i 1 to ${GMail.Size}
            /varset GMailEventCheck ${Ini[${IniFileName},Gmail,Gmail${i}]}
            /if (${GMailEventCheck.Length} && ${GMailEventCheck.NotEqual[null]}) {
                /if (${Select[${GMailEventCheck},Dead,Drag,GM,Level,Named,Leftgroup]}) {
                     /if (${Debug}) /echo \atDEBUGBUFFS /echo ${i}. ${GMailEventCheck}
                    /if (${GMailEvents.Length}) {
                        /varset GMailEvents ${GMailEvents},${GMailEventCheck}m
                    } else {
                        /varset GMailEvents ${GMailEventCheck}
                    }
                }
            }
        /next i
        /if (${Debug}) /echo \atDEBUGBUFFS GmailSend Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: GmailSend
| ----------------------------------------------------------------------------
    Sub GmailSend(GMessage)
        /if (${Debug}) /echo \atDEBUGBUFFS GmailSend Enter \agLine#: ${Macro.CurLine}
        |Goofy time shit because Gmail fails if any entry has a colon : in it. 
        /declare GTime string local 
        /declare GtimeHour string local ${Time.Hour}
        /declare AMPM string local am
        /if (${Time.Hour}>=13) {
            /varset GtimeHour ${Int[${Math.Calc[${Time.Hour}-12]}]}
            /varset AMPM pm
        }    
        /varset GTime Date.${Time.Date} Time.${GtimeHour}.${Time.Minute} ${AMPM}
        | Ghetto fix for buffer overflow until MQ2GMail is fixed
        /squelch /plugin MQ2Gmail unload 
        /squelch /plugin MQ2Gmail
        /gmail "Kiss-${EverQuest.Server}-${Me}" "${GTime} - ${GMessage}"
        /echo GMAIL just sent "Kiss-${EverQuest.Server}-${Me}" "${GTime} - ${GMessage}"
        /varcalc GSent ${GSent}+1
        /if (${GSent}==5) {
            /varset GSent 0
        }
        /delay 10
        /if (${Debug}) /echo \atDEBUGBUFFS GmailSend Leave \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: Roguestuff
| ----------------------------------------------------------------------------
    Sub Roguestuff
        /if (${Debug}) /echo \atDEBUGBUFFS Roguestuff Enter \agLine#: ${Macro.CurLine}
        /if (${Me.Class.Name.Equal[Rogue]} && !${Me.Combat} && ${AutoHide}) {
            /if (${Me.AbilityReady[hide]} && ${Me.AbilityReady[sneak]}) {
                /doability hide
                /doability sneak
            }
        }
    /if (${Debug}) /echo \atDEBUGBUFFS Roguestuff Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: LoadSpellSet
| ----------------------------------------------------------------------------
    Sub LoadSpellSet
        /if (${Debug}) /echo \atDEBUGBUFFS LoadSpellSet Enter \agLine#: ${Macro.CurLine}   
        /declare GemNum      int local
        /declare ValidSpells int local 0
            
        /if (${Debug}) /echo \atDEBUG Sub LoadSpellSet LoadSpellSet=(${LoadSpellSet}) \agLine#: ${Macro.CurLine}
        /if (${LoadSpellSet}==1) {
            /if (${Debug}) /echo \atDEBUG Sub LoadSpellSet SpellSetName=(${SpellSetName}) \agLine#: ${Macro.CurLine}
            /echo Memming spellset (${SpellSetName}).
            /memspellset ${SpellSetName}    
        } else {       
            |---Test to see if we have MySpells section defined in INI or not.
            /for GemNum 1 to 13
                /call LoadIni MySpells Gem${GemNum} string NULL
                /if (${Gem${GemNum}.Length} && ${Gem${GemNum}.NotEqual[NULL]}) {
                    |-- We have found a good spell defined, one good spell is all it takes to be a valid MySpells config.
                    /varset ValidSpells 1
                }
            /next GemNum 
            /if (${LoadSpellSet}==2 && ${ValidSpells}==0) /echo You have no valid spells defined in your ini file [MySpells], load your spells now and do a /writespells command while in KissAsssist.
            /if (${LoadSpellSet}==2 && ${ValidSpells}==1) /call Bind_MemMySpells ${Me.CleanName}
        }
        |-- If we called this routine, make sure we update values for ReMemMiscSpell and ReMemMiscSpellLW since they might have changed after spellset load.
        /varset ReMemMiscSpell ${Me.Gem[${MiscGem}].Name}
        /varset ReMemMiscSpellLW ${Me.Gem[${MiscGemLW}].Name}
        /if (${Debug}) /echo \atDEBUGBUFFS LoadSpellSet Leave \agLine#: ${Macro.CurLine} 
    /return    
| ----------------------------------------------------------------------------
| SUB: Set Window Title Buffs
| ----------------------------------------------------------------------------    
    Sub WinTitle
        /if (${Debug}) /echo \atDEBUGBUFFS WinTitle Enter \agLine#: ${Macro.CurLine} 
        /SetWinTitle ${Me.Name} (Lvl:${Me.Level} ${Zone.ShortName})
        /if (${Debug}) /echo \atDEBUGBUFFS WinTitle Leave \agLine#: ${Macro.CurLine} 
    /return    
| ----------------------------------------------------------------------------
| SUB: Write Buffs 
| ----------------------------------------------------------------------------
    Sub WriteBuffs
        /if (${WriteBuffsTimer} || !${Redguides} || ${AggroTargetID}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffs Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        | Set block buffs count to 29 on emu servers and 39 on live
        /if (${MacroQuest.Build}==4) {
            /varset BlockedBuffsCount 29
        } else {
            /varset BlockedBuffsCount 39
        }    
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Blockedbuffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs
        /ini "KissAssist_Buffs.ini" "${Me.ID}" AmILooting ${LootOn}
        /ini "KissAssist_Buffs.ini" "${Me.ID}" MyRole ${Role}
        | Write all current buffs to Kissassist_Buffs.ini file
        /for i 0 to 40
            /if (${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip.Find[(]}) {
                /varset BuffList ${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip.Arg[1,(].Left[-1]}
            } else {
                /varset BuffList ${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip}
            } 
            /if (${BuffList.Length}) {
                /if (${Debug}) /echo \atDEBUG WriteBuffs: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /if (${BuffList.Find[:Permanent]}>1) /varset BuffList ${BuffList.Left[${Math.Calc[${BuffList.Find[:Permanent]}-1]}]}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs "${Writebufflist}"
        /delay 15
        | Open Blocked Buffs window temporarily to read blocked buffs
        /if (!${Window[BlockedBuffWnd].Open} && !${BBWindowOpen}) {
            /windowstate BlockedBuffWnd open
            /varset BBWindowOpen 120m
            /delay 10
        } 
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 0 to ${BlockedBuffsCount}
            /varset Blockedbuff ${Window[BlockedBuffWnd].Child[BW_BLOCKEDBUFF${k}_Button].Child[BBuff${k}].Tooltip}
            /if (${Blockedbuff.Length}) {
                /varset Blockedbufflist ${Blockedbufflist}|${Blockedbuff}
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedBuffWnd].Open}) /windowstate BlockedBuffWnd close
        /varset WriteBuffsTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Grab Corpse
| ----------------------------------------------------------------------------
    Sub GrabCorpse  
           /if (${SpawnCount[pc ${Me} corpse radius 89]} && !${DragCorpse}) {
               |/target ${Me}'s corpse
               |/delay 10 ${Target.ID}==${SpawnCount[pc ${Me} corpse radius 89].ID}
               /corpsedrag
               | /beep
               /varset DragCorpse 1
               /echo Hey I found my corpse. Running back to camp for a rez
               /varset Pulled 1
               /if (${GMailEvents.Find[drag]}) /call GmailSend "Hey I found my corpse. Running back to camp for a rez!"
           }
    /return