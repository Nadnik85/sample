| MedCombat bug fixed
| Fixed lowercase ${int
| Fixed /if (${DebugHeals}) /echo \amDEBUGHEALS WriteDebuffs Enter \agLine#: ${Macro.CurLine}
| Fixed /if (${GameState.Equal[CHARSELECT]}) /endmac
| Deleted reference to undefined local variable BookSpellTT
| bunch of other stuff in 1.51
| BugFix: renamed MyTargeID to MyTargetID
| More fixes
| Fixed EnduranceCost check in a couple places.
| - kissassist.mac v10.0.4 by Maskoi 09/12/2017. 1.55 Mod by eqmule 12/11/2017
| - kissassist.mac v10.0.4 by Maskoi 09/12/2017. 1.54 Mod by eqmule 09/30/2017
| - kissassist.mac v10.0.4 by Maskoi 09/12/2017. 1.53 Mod by eqmule 09/28/2017
| - kissassist.mac v10.0.4 by Maskoi 09/12/2017. 1.52 Mod by eqmule 09/07/2017
| - kissassist.mac v10.0.4 by Maskoi 07/01/2017. 1.5 Mod by eqmule 09/07/2017
| - kissassist.mac v10.0.4 by Maskoi 07/01/2017. 1.4 Mod by eqmule 09/01/2017
| - kissassist.mac v10.0.4 by Maskoi 07/01/2017. 1.3 Mod by eqmule 08/16/2017
| - kissassist.mac v10.0.4 by Maskoi 07/01/2017. 1.2 Mod by eqmule 08/07/2017
| - kissassist.mac v10.0.4 by Maskoi 07/01/2017. 1.1 Mod by eqmule 07/19/2017
| - kissassist.mac v10.0.4 by Maskoi 07/01/2017.
| - Contributions by anonymoushero, crystane, eqmule, thenomadman, william12.
| - ChainPull, Debuffs and combat rewrites by ctaylor22.
| - PetTank, PullerPetTank & HunterPetTank roles developed by TreeHuginDruid
| - KISS Assist - A simple multi class macro
| Requires plugins* MQ2Cast, MQ2Exchange, MQ2Melee, MQ2MoveUtils, MQ2Posse, MQ2Rez, & MQ2Twist (Bards), MQ2Gmail, Extended Target Window and ninjadvloot.inc file.
| Usage - /mac kissassist assist TankName 95
| or target Main Tank and /mac kissassist assist
| This macro was written exclusively for subscribers of Redguides.com
| -------------------------------------------------------------------------------------

#turbo 80
| #include custom.inc
#include ninjadvloot.inc

| #DEFINE /squelch " "
|****************************************| GENERAL EVENTS |***********************************************|
#Event Camping           "#*#seconds to prepare your camp."
#Event EQBCIRC           "<#1#> #2#"
#Event FSEQBC            "#1# tells the fellowship, #2#"
#Event GUEQBC            "#1# tells the guild, #2#"
#Event GainSomething     "#*#You have gained|#1#|"
#Event GotHit            "#1# bashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# crushes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# hits YOU for #*# points of damage.#*#"
#Event GotHit            "#1# kicks YOU for #*# points of damage.#*#"
#Event GotHit            "#1# mauls YOU for #*# points of damage.#*#"
#Event GotHit            "#1# pierces YOU for #*# points of damage.#*#"
#Event GotHit            "#1# punches YOU for #*# points of damage.#*#"
#Event GotHit            "#1# slashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# bites YOU for #*# points of damage.#*#"
#Event GotHit            "#1# tries to #*# YOU, but #*#"
#event GotHit		"#*#smashes YOU for#*#"
#event GotHit		"#*#gores YOU for#*#"
#event GotHit		"#*#rampages YOU for#*#" 
#Event Invised           "You Vanish #*#"
#Event Joined            "#1# has joined the group."
#Event KTDismount        "[MQ2] KTDismount#*#"
#Event KTDoorClick       "[MQ2] KTDoorClick #1#"
#Event KTDoorClick       "[MQ2] KTDoorClick#*#"
#Event KTHail            "[MQ2] KTHail #1#"
#Event KTInvite          "[MQ2] KTInvite #1#"
#Event KTSay             "[MQ2] KTSay #1#"
#Event KTTarget          "[MQ2] KTTarget #1#"
#Event LeftGroup         "#1# has left the group."
#Event MezBroke          "#1# has been awakened by #2#."
#Event Missing           "#*#You are missing some required components.#*#"
#Event PTaunt            "#*#Taunting attackers as normal, Master.#*#"
#Event PetSusStateAdd1   "#*# tells you, 'By your command, master.#*#"
#Event PetSusStateAdd2   "#*#You cannot have more than one pet at a time.#*#"    
#Event PetSusStateSub    "#*# tells you, 'I live again...'#*#"
#Event PetToysPlease     "#*#PetToysPlease #1#"
#Event TaskUpdate        "#*#Your task |#1#| has been updated#*#"
#Event Timer             Timer1
#Event TooSteep          "The ground here is too steep to camp"  
#Event WornOff           "Your #1# spell has worn off of #2#."
#Event Zoned             "LOADING, PLEASE WAIT#*#"
#Event Zoned             "You have entered#*#"
|****************************************| COMBAT EVENTS |***********************************************|
#Event Banestrike        "Your Banestrike fails because you have not yet mastered slaying this race."
#Event CantHit           "You can't hit them from here."
#Event CantSee           "You cannot see your target."
#Event GoMOff            "The gift of magic fades."
#Event GoMOff            "Your#*#gift of#*#mana fades."
#Event GoMOn             "#*#granted#*#gift of#*#mana#*#"
#Event GoMOn             "You feel strengthened by a gift of magic."
#Event GoMOn             "You feel strengthened by magic."
#Event ImDead            "#*#Returning to Bind Location#*#"
#Event ImDead            "You died."
#Event ImDead            "You have been slain by#*#"
#Event TooClose          "Your target is too close to use a ranged weapon!!"
#Event TooFar            "Your target is too far away, get closer!"
#Event YouHit            "#1# has taken #2# damage from your #3#."
#Event YouHit            "#1# was hit by non-melee for #2# points of damage."
#Event YouHit            "You backstab #1# for #2# points of damage."
#Event YouHit            "You bash #1# for #2# points of damage."
#Event YouHit            "You bite #1# for #2# points of damage."
#Event YouHit            "You claw #1# for #2# points of damage."
#Event YouHit            "You crush #1# for #2# points of damage."
#Event YouHit            "You frenzy on #1# for #2# points of damage."
#Event YouHit            "You hit #1# for #2# points of damage."
#Event YouHit            "You kick #1# for #2# points of damage."
#Event YouHit            "You maul #1# for #2# points of damage."
#Event YouHit            "You pierce #1# for #2# points of damage."
#Event YouHit            "You punch #1# for #2# points of damage."
#Event YouHit            "You slash #1# for #2# points of damage."
#Event YouHit            "You slice #1# for #2# points of damage."
#Event YouHit            "You sting #1# for #2# points of damage."
#Event YouHit            "You strike #1# for #2# points of damage."
#Event YouHit            "You try to #*#, but miss"
#Event YouHit            "|${Me.Pet.CleanName}| backstabs #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| bashes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| bitess #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| claws #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| crushes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| frenzies on #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me.Pet.CleanName}| hits #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| kicks #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| mauls #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| pierces #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| punches #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| slashes #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| slices #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| stings #1# for #2# points of damage."
#Event YouHit            "|${Me.Pet.CleanName}| strikes #1# for #2# points of damage."
#Event YouHit            "|${Me}| hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me}|`s pet backstabs #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet bashes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet bites #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet claws #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet crushes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet frenzies on #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet hit #1# for #2# points of non-melee damage."
#Event YouHit            "|${Me}|`s pet hits #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet kicks #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet mauls #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet pierces #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet punches #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet slashes #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet slices #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet stings #1# for #2# points of damage."
#Event YouHit            "|${Me}|`s pet strikes #1# for #2# points of damage."
| -------------------------------------------------------------------------------------
| New Binds to replace old Events
| -------------------------------------------------------------------------------------
#bind AddAFriend     /addfriend
#bind AddMezImmune   /addimmune
#bind AddToIgnore    /addignore
#bind AddToPull      /addpull
#bind BackOff        /backoff
#bind Burn           /burn
#bind Campfire       /campfire
#bind ChangeVarInt   /changevarint
#bind DebugAll       /debugall
#bind IniWrite       /iniwrite
#bind KissCheck      /kisscheck
#bind KissE          /kissedit
#bind MemMySpells    /memmyspells
#bind Parse          /parse
#bind Switch         /switchnow
#bind ToggleVariable /togglevariable
#bind WriteMySpells  /writespells
#bind ZoneInfo       /zoneinfo
#bind IVU            /ivu
#bind DoHalfCircle   /halfmoon
#Bind SheepMove	     /sheepmove
#Bind AssignMainAssist /changema
#Bind GoBackToCamp   /goback

Sub CheckAllPlugins
	/call CheckPlugin MQ2DamageParser
	/call CheckPlugin MQ2Cast
	/call CheckPlugin MQ2Exchange
	/if (${UseMQ2Melee}) /call CheckPlugin MQ2Melee
	/call CheckPlugin MQ2Moveutils
	/call CheckPlugin MQ2Posse
	/call CheckPlugin MQ2Rez
	/if (${IAmABard}) /call CheckPlugin MQ2Twist
/return

| -------------------------------------------------------------------------------------
| Sub Main
| -------------------------------------------------------------------------------------
| If we dont put this here, there is a chance it will fail due to a chat event which trigger the undeclared variables check
#Event Burn              "[MQ2] |${BurnText}|"
Sub Main
	/declare bCallCustom int outer 0
	|new variable to keep status if we are being hit
	/declare MeleeHit int outer 0
    |lets check a few plugins
	/declare mq2navloaded int outer 0
    /if (${Bool[${Plugin[MQ2Nav]}]}) {
	/varset mq2navloaded 1
    }
	/declare mq2advpathloaded int outer 0
    /if (${Bool[${Plugin[MQ2AdvPath]}]}) {
	/varset mq2advpathloaded 1
    }
    /if (!${Bool[${Plugin[MQ2Twist]}]}) {
	|Macro refer to "${Twist}" all over the place and its not a tlo that exist if the plugin is not loaded
	/declare Twist int outer 0
    }
    |set MacroModder to NULL when its not a modded version
    /declare MacroModder            string      outer       EqMule
    /declare ModVersion             string      outer       1.55

    /doevents flush
    | Define debug variables before everything else
    /declare Debug                  int         outer       0
    /declare DebugAllOn             int         outer       0
    /declare DebugBuffs             int         outer       0
    /declare DebugCombat            int         outer       0
    /declare DebugHeal              int         outer       0
    /declare DebugMez               int         outer       0
    /declare DebugMove              int         outer       0
    /declare DebugPet               int         outer       0
    /declare DebugPull              int         outer       0
    /declare DebugRK                int         outer       0
    /delay 5s
    | Need to check for plugin MQ2Bucles and unload it. Do this ASAP so can use /while commands from the start
    /if (${Bool[${Plugin[MQ2Bucles]}]}) {
        /squelch /plugin MQ2Bucles unload noauto
        /echo MQ2Bucles detected! This macro doesn't like it! Unloading ...
    }
    | ini file fix for zones with commas in them
    /declare ZoneName string outer ${Zone}
    /if (${ZoneName.Find[,]} || ${ZoneName.Find[']} ) {
        /echo ${ZoneName} has a comma or apostrophe in the name, setting Zone Short Name ...
        /varset ZoneName ${Zone.ShortName}
    }
    /declare MacroName              string      outer       KissAssist
    /declare MacroVer               string      outer       10.0.4.1.55
    /declare IniFileName            string      outer         
    /declare InfoFileName           string      outer       ${MacroName}_Info.ini
    /declare ConditionsFileName     string      outer       
    /declare BuffFileName           string      outer       ${MacroName}_Buffs.ini
    /declare PIniSet                int         outer       0
    /declare pi                     int         local       0
    /declare NumParams              int         local       0
    /declare GemStuckTimer          timer       outer       0
    /declare GoMTimer               timer       outer       0
    | Check for command line variables
    /if (${Macro.Params}) {
		/varset NumParams ${Math.Calc[${Macro.Params}-1]}
    }
	/if (${Macro.Params}) {
		/for pi 0 to ${NumParams}
			/if (${Defined[Param${pi}]}) {
				/declare PParam${pi} string outer ${Param${pi}}
			}
		/next pi
    	/call PParse 0 ${NumParams}
	}
    | if Kiss finds a Kissassist_ServerName_ToonName.ini file it will use that one
    /if (!${PIniSet}) {
        /if (${Ini[${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini,General,KissAssistVer].Length}) {
            /varset IniFileName ${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini
            /echo Server Name ini file detected using ${IniFileName}
        } else {
            /varset IniFileName ${MacroName}_${Me.CleanName}.ini
        }  
    }
    /declare KissAssistVer          string      outer       ${Ini[${IniFileName},General,KissAssistVer]}
    /if (${Debug}) /echo ${IniFileName} ${KissAssistVer} \agLine#: ${Macro.CurLine}
    /if (!${Ini[${IniFileName},General,KissAssistVer].Length}) /ini "${IniFileName}" "General" "KissAssistVer" "0.0"
| ************************* Aliases **************************************|
    /if (${Debug}) /echo \atDEBUG Ini/Alias info ${KissAssistVer.NotEqual[${MacroVer}]} "${KissAssistVer}" "${MacroVer}" \agLine#: ${Macro.CurLine}
    /if (${KissAssistVer.NotEqual[${MacroVer}]}) {
        /echo Version Mismatch Detected, Writing Aliases this can take up to 1 min
        /squelch /alias /afktoolson     /changevarint AFKTools AFKToolsOn
        /squelch /alias /assistat       /changevarint Melee AssistAt
        /squelch /alias /autofireon     /togglevariable AutoFireOn
        /squelch /alias /autorezon      /togglevariable AutoRezOn
        /squelch /alias /buffson        /togglevariable BuffsOn
        /squelch /alias /camphere       /togglevariable ReturnToCamp
        /squelch /alias /campradius     /changevarint General CampRadius
        /squelch /alias /chase          /togglevariable ChaseAssist
        /squelch /alias /chasedistance  /changevarint General ChaseDistance
        /squelch /alias /chaseoff       /changevarint General ChaseAssist 0        
        /squelch /alias /chaseon        /changevarint General ChaseAssist 1 
        /squelch /alias /conditions     /togglevariable conditions
        /squelch /alias /conditionsoff  /togglevariable conditions off
        /squelch /alias /conditionson   /togglevariable conditions on
        /squelch /alias /debug          /togglevariable Debug
        /squelch /alias /debugbuffs     /togglevariable DebugBuffs
        /squelch /alias /debugcombat    /togglevariable DebugCombat
        /squelch /alias /debugheal      /togglevariable DebugHeal
        /squelch /alias /debugmez       /togglevariable DebugMez
        /squelch /alias /debugmove      /togglevariable DebugMove
        /squelch /alias /debugpull      /togglevariable DebugPull
        /squelch /alias /debugrk        /togglevariable DebugRK
        /squelch /alias /dpsinterval    /changevarint DPS DPSInterval
        /squelch /alias /dpsmeter       /togglevariable DPSMeter
        /squelch /alias /dpson          /changevarint DPS DPSOn
        /squelch /alias /dpsskip        /changevarint DPS DPSSkip
        /squelch /alias /dpsspam        /togglevariable DPSSpam
        /squelch /alias /dpswrite       /togglevariable DPSWriteOn
        /squelch /alias /healson        /changevarint Heals HealsOn   
        /squelch /alias /interrupton    /togglevariable CastingInterruptOn     
        /squelch /alias /ktdismount     /echo KTDismount
        /squelch /alias /ktdoor         /echo KTDoorClick        
        /squelch /alias /kthail         /echo KTHail
        /squelch /alias /ktinvite       /echo KTInvite
        /squelch /alias /ktsay          /echo KTSay
        /squelch /alias /kttarget       /echo KTTarget  
        /squelch /alias /looton         /changevarint General LootOn
        /squelch /alias /maxradius      /changevarint Pull MaxRadius
        /squelch /alias /maxzrange      /changevarint Pull MaxZRange
        /squelch /alias /medcombat      /togglevariable MedCombat
        /squelch /alias /medstart       /changevarint General MedStart
        /squelch /alias /meleedistance  /changevarint Melee MeleeDistance
        /squelch /alias /meleeon        /togglevariable MeleeOn
        /squelch /alias /mercassistat   /changevarint Merc MercAssistAt
        /squelch /alias /mezon          /changevarint Mez MezOn
        /squelch /alias /movewhenhit    /togglevariable MoveWhenHit 
        /squelch /alias /pethold        /togglevariable PetHold
        /squelch /alias /peton          /togglevariable PetOn
        /squelch /alias /pettoyson      /togglevariable PetToysOn
        /squelch /alias /pettoysplz     /echo PetToysPlease
        /squelch /alias /rebuffon       /togglevariable RebuffOn
        /squelch /alias /returntocamp   /togglevariable ReturnToCamp
        /squelch /alias /scatteron      /togglevariable ScatterOn
        /squelch /alias /setae          /iniwrite AE
        /squelch /alias /setaggro       /iniwrite Aggro
        /squelch /alias /setbuffs       /iniwrite Buffs
        /squelch /alias /setburn        /iniwrite Burn
        /squelch /alias /setcure        /iniwrite Cure
        /squelch /alias /setdps         /iniwrite DPS
        /squelch /alias /setheals       /iniwrite Heals
        /ini "${IniFileName}" "General" "KissAssistVer" "${MacroVer}"
    }
    /if (${Debug}) /echo \atDEBUG Aliases processed  \agLine#: ${Macro.CurLine}
| ************************* General **************************************|
    | Edit settings in your KissAssist_ToonName.ini file
    /echo [${Time}] Loading INI Info
    /call LoadIni General Role                  string      Assist
    /call LoadIni General CampRadius            int         30
    /call LoadIni General CampRadiusExceed      int         400
    /call LoadIni General ReturnToCamp          int         0
    /call LoadIni General ChaseAssist           int         0
    /call LoadIni General ChaseDistance         int         25
    /call LoadIni General MedOn                 int         1
    /call LoadIni General MedStart              int         20
    /call LoadIni General MedCombat             int         0
    /call LoadIni General LootOn                int         0
    /call LoadIni General RezAcceptOn           string      0|96
    /call LoadIni General AcceptInvitesOn       int         1
    /call LoadIni General GroupWatchOn          string      0
    /call LoadIni General CastingInterruptOn    int         0
    /call LoadIni General TheWinTitle		string	    NULL
    /call LoadIni General GemStuckHelp          string      "Sometimes the spellgems get stuck in a foreverloop, casting a altability that has a cast time will unstick it, this is a eq bug."
    /call LoadIni General GemStuckAbility       string	    NULL

    /declare GroupWatchPct int outer 20
    /if (${GroupWatchOn.Find[|]}) {
        /varset GroupWatchPct ${GroupWatchOn.Arg[2,|]}
        /varset GroupWatchOn ${GroupWatchOn.Arg[1,|]}
    }
    /call LoadIni General EQBCOn                string      0
    /declare EQBCSay                            string      outer   bc
    /if (${EQBCOn.Arg[2,|].Length} && ${EQBCOn.Arg[1,|].Equal[2]}) {
        /if (${Debug}) /echo ${EQBCOn} ${EQBCOn.Arg[1,|]} ${EQBCOn.Arg[2,|]} \agLine#: ${Macro.CurLine}
        /varset EQBCSay bct ${EQBCOn.Arg[2,|]}
        /varset EQBCOn 2
    }
    /call LoadIni General IRCOn                 int         0
    /call LoadIni General MiscGem               int         8
    /call LoadIni General MiscGemLW             int         0
    /call LoadIni General MiscGemRemem          int         1
    /call LoadIni General HoTTOn                int         0
    /call LoadIni General CampfireOn            int         0 
    /if (${Int[${Ini[${IniFileName},General,CharInfo].Arg[2,|]}]}!=${Me.Level}) /ini "${IniFileName}" "General" "CharInfo" "${Me.Class}|${Me.Level}|${Me.Subscription}"
    /if (${Int[${Ini[${IniFileName},General,DefaultUI].Arg[1,|]}]}!=${EverQuest.CurrentUI.Equal[Default]}) /ini "${IniFileName}" "General" "DefaultUI" "${If[${EverQuest.CurrentUI.Equal[Default]},TRUE,FALSE|Custom UIs are not supported. Please switch to Default UI before posting bugs.]}"
    /declare GroupEscapeOn int     outer      0
    /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
        /call LoadIni General GroupEscapeOn     int         0
    }
    /call LoadIni General DPSMeter              int         1
    /call LoadIni General Scatter               int         0
    /call LoadIni General ConditionsOn          int         0
    /call LoadIni General MoveCloserIfNoLOS     int         0

    /if (${ConditionsOn}) {
        /if (${ConditionsOn}==1) {
            /varset ConditionsFileName ${IniFileName.Replace[.ini,]}_Conditions.ini
        } else {
            /varset ConditionsFileName ${IniFileName}
        }
    }
| ************************* SpellSet *************************************|
    /call LoadIni SpellSet LoadSpellSet          int         0
    /call LoadIni SpellSet SpellSetName          string      "KissAssist"   
| ************************* Buffs ****************************************|
    /call LoadIni Buffs BuffsOn                 int         0
    /call LoadIni Buffs BuffsCOn                int         0          NULL         FALSE          "${ConditionsFileName}"
    /call LoadIni Buffs BuffsSize               int         20
    /declare Buffs[${BuffsSize}]                string      outer
    /declare BuffsCond[${BuffsSize}]            string      outer      TRUE
    /call LoadIni Buffs Buffs                   string      NULL       Buffs        BuffsCond      "${IniFileName}" "${ConditionsFileName}"
    /call LoadIni Buffs RebuffOn                int         1
    /call LoadIni Buffs CheckBuffsTimer         int         10
    /call LoadIni Buffs PowerSource             string      NULL
| ************************* Melee ****************************************|
    /call LoadIni Melee AssistAt                int         95
    /if (${Select[${Me.Class.ShortName},BST,BER,MNK,PAL,RNG,ROG,SHD,WAR]}) {
        /call LoadIni Melee MeleeOn             int         1
    } else {
        /call LoadIni Melee MeleeOn             int         0
    }
    /call LoadIni Melee FaceMobOn               int         1
    /call LoadIni Melee MeleeDistance           int         75
    /call LoadIni Melee StickHow                string      "snaproll rear"
    /call LoadIni Melee AutoFireOn              int         0
    /call LoadIni Melee UseMQ2Melee             int         1
    /declare BeforeCombat string outer
    /if (${Select[${Me.Class.ShortName},BER]}) {
        /call LoadIni Melee BeforeCombat        string      "Cast Before Melee Disc"
    }

	/declare RogueTimerEight string         outer      Daggerslice
    /if (${Select[${Me.Class.ShortName},ROG]}) {
        /call LoadIni Melee AutoHide            int         1
        /call LoadIni Melee RogueTimerEight            string         Daggerslice
    }
| ************************* GoM ****************************************|
    /if (!${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
        /call LoadIni GoM GoMSHelp              string       "Format - Spell|Target, MA Me or Mob, i.e. Rampaging Servant Rk. II|Mob"
        /call LoadIni GoM GoMCOn                int         0          NULL         FALSE          "${ConditionsFileName}"
        /call LoadIni GoM GoMSize               int         3
        /declare GoMSpell[${GoMSize}]           string      outer
        /declare GoMCond[${GoMSize}]            string      outer       TRUE
        |string       sectionName, varName,     varType,    varValue,  varArray,    varArray2,     FileName,        FileName2
        /call LoadIni GoM GoMSpell              string      NULL       GoMSpell     GoMCond        "${IniFileName}" "${ConditionsFileName}"  
    }
| ************************* Gmail ****************************************|
    /call LoadIni GMail GMailHelp              string       "Events currently support - Dead,GM,Level,Named,Leftgroup"
    /call LoadIni GMail GMailOn                int         0
    /call LoadIni GMail GMailSize              int         5
    /declare GMail[${GMailSize}]               string        outer
    /call LoadIni GMail GMail                  string        NULL       GMail
| *************************  AE ******************************************|
    /call LoadIni AE AEOn                       int         0
    /call LoadIni AE AESize                     int         10
    /call LoadIni AE AERadius                   int         50
    /declare AE[${AESize}]                      string      outer
    /call LoadIni AE AE                         string      NULL        AE
| ************************* DPS ******************************************|
    /call LoadIni DPS DPSOn                     int         0
    /call LoadIni DPS DPSCOn                    int         0           NULL          FALSE           "${ConditionsFileName}"
    /call LoadIni DPS DPSSize                   int         20
    /call LoadIni DPS DPSSkip                   int         20
    /call LoadIni DPS DPSInterval               int         2
    /declare DPS[${DPSSize}]                    string      outer
    /declare DPSCond[${DPSSize}]                string      outer       TRUE
    |string       sectionName, varName,         varType,    varValue,   varArray,     varArray2,     FileName,        FileName2
    /call LoadIni DPS DPS                       string      NULL        DPS           DPSCond        "${IniFileName}" "${ConditionsFileName}"
    /call LoadIni DPS DebuffAllOn               int         0
| ************************* Bandolier ******************************************|
    /call LoadIni Bandolier BandolierOn         int         0    
    /call LoadIni Bandolier BandolierCOn        int         0           NULL          FALSE           "${ConditionsFileName}"
    /call LoadIni Bandolier BandolierSize       int	    2
    /declare Bandolier[${BandolierSize}]        string      outer
    /declare BandolierCond[${BandolierSize}]    string      outer       TRUE
    /call LoadIni Bandolier Bandolier           string      NULL        Bandolier           BandolierCond        "${IniFileName}" "${ConditionsFileName}"
| ************************* OhShit ******************************************|
	/declare OhShitTargetID int outer
    /call LoadIni OhShit OhShitOn         int         0    
    /call LoadIni OhShit OhShitCOn        int         0           NULL          FALSE           "${ConditionsFileName}"
    /call LoadIni OhShit OhShitSize          int	        2
    /declare OhShit[${OhShitSize}]        string      outer
    /declare OhShitCond[${OhShitSize}]    string      outer       TRUE
    |string       sectionName, varName,         varType,    varValue,   varArray,     varArray2,     FileName,        FileName2
    /call LoadIni OhShit       OhShit           string      NULL        OhShit        OhShitCond    "${IniFileName}" "${ConditionsFileName}"
| ************************* Aggro ******************************************|
    /call LoadIni Aggro AggroOn                 int         0
    /if (${Select[${Me.Class.ShortName},SHD,WAR,PAL]})  {
        /call LoadIni Aggro AggroSize           int         10
    } else {
        /call LoadIni Aggro AggroSize           int         5
    }
    /declare Aggro[${AggroSize}]                string      outer
    /declare AggroCond[${AggroSize}]            string      outer       TRUE
    /call LoadIni Aggro Aggro                   string      NULL        Aggro         AggroCond      "${IniFileName}" "${ConditionsFileName}"
| ************************* Bard *****************************************|
    /declare IAmABard                           bool        outer          ${Me.Class.Name.Equal[Bard]}
    /declare TwistOn      			int	    outer	   0
    /declare MeleeTwistOn			int	    outer	   0
    /if (${IAmABard}) {
        /call LoadIni General TwistOn           int         0
        /call LoadIni General TwistMed          int         "Mana song gem"
        /call LoadIni General TwistWhat         string      "Twist order here"
        /call LoadIni Melee MeleeTwistOn        int         0
        /call LoadIni Melee MeleeTwistWhat      string      "DPS twist order here"
        /call LoadIni Pull PullTwistOn          int         0
    }
| ************************* Heals ***************************************|
    /call LoadIni Heals Help                    string      "Format Spell|% to heal at i.e. Devout Light Rk. II|50"
    /call LoadIni Heals HealsOn                 int         0
    /call LoadIni Heals HealsCOn                int         0           NULL          FALSE           "${ConditionsFileName}"
    /if (${Select[${Me.Class.ShortName},CLR,SHM,DRU,PAL]})  {
        /call LoadIni Heals HealsSize           int         15
    } else {
        /call LoadIni Heals HealsSize           int         5
    }
    /declare Heals[${HealsSize}]                string      outer
    /declare HealsCond[${HealsSize}]            string      outer       TRUE
    /call LoadIni Heals Heals                   string      NULL        Heals         HealsCond      "${IniFileName}" ${ConditionsFileName} 
    /call LoadIni Heals XTarHeal                int         0
    /call LoadIni Heals XTarHeal2               int         0
    /declare AutoRezOn int outer 0
    /if (${Select[${Me.Class.ShortName},CLR,NEC,SHM,DRU,PAL]}) {
        /call LoadIni Heals AutoRezOn           int         0
        /call LoadIni Heals AutoRezWith         string      "Your Rez Item/AA/Spell"
    }
    /call LoadIni Heals HealGroupPetsOn         int         0
| ************************* Cures ***************************************|
    /call LoadIni Cures CuresOn                 int         0
    /call LoadIni Cures CuresSize               int         5
    /declare Cures[${CuresSize}]                string      outer
    /call LoadIni Cures Cures                   string      NULL        Cures
| ************************* Pet *****************************************|
	/declare PetForceHealOnMed int outer 0
	/declare PetOn int outer 0
	/declare PetFocus string outer NULL
	/declare PetToysGave string outer NULL
	/declare PetToysOn int outer 0
	/declare PetAssistAt int outer 95
	/declare PetCombatOn int outer 0
    /if (${Select[${Me.Class.ShortName},DRU,SHM,BST,ENC,MAG,NEC,SHD]}) {
        /call LoadIni Pet PetOn                 int         0
        /call LoadIni Pet PetSpell              string      "YourPetSpell"
        /if (${Select[${Me.Class.ShortName},BST,MAG,NEC]})  /call LoadIni Pet PetFocus   string  "NULL"
        /call LoadIni Pet PetShrinkOn           int         0
        /call LoadIni Pet PetShrinkSpell        string      "Tiny Companion"
        /call LoadIni Pet PetBuffsOn            int         0
        /call LoadIni Pet PetBuffsSize          int         8
        /declare PetBuffs[${PetBuffsSize}]      string      outer
        /call LoadIni Pet PetBuffs              string      NULL        PetBuffs
        /call LoadIni Pet PetCombatOn           int         1
        /call LoadIni Pet PetAssistAt           int         95          
        /declare PetToysDone                    int         outer       0
        /call LoadIni Pet PetToysSize           int         6
        /declare PetToys[${PetToysSize}]        string      outer
        /if (${Select[${Me.Class.ShortName},MAG]}) {
            /call LoadIni Pet PetToysOn         int         0
            /call LoadIni Pet PetToys           string      NULL        PetToys
            /call LoadIni Pet PetToysGave       string      NULL
        }
        /call LoadIni Pet PetBreakMezSpell    string      NULL
        /call LoadIni Pet PetRampPullWait       int         0  
        /call LoadIni Pet PetSuspend            int         0
        /call LoadIni Pet MoveWhenHit           int         0
        /call LoadIni Pet PetHoldOn             int         1
        /declare PetHold                        string     outer
        /if (${Me.AltAbility[Pet Discipline]}>=1) {
            /if (${Me.AltAbility[Pet Discipline]}<=5)             /varset PetHold hold
            /if (${Me.AltAbility[Pet Discipline]}>=6)             /varset PetHold ghold
        }
        /call LoadIni Pet PetForceHealOnMed     int         0
    }    
| ************************* Mez *****************************************|
    |Have to declare this, its refered in multiple places throughout the macro.
    /declare MezOn int outer 0
    /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
		/call LoadIni Mez MezOn                 int         0
        /call LoadIni Mez MezRadius             int         50
        /call LoadIni Mez MezMinLevel           int         "Min Mez Spell Level"
        /call LoadIni Mez MezMaxLevel           int         "Max Mez Spell Level"
        /call LoadIni Mez MezStopHPs            int         80
        /call LoadIni Mez MezSpell              string      "Your Mez Spell"
        | necros can't AE mez
        /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
            /call LoadIni Mez MezAESpell            string      "Your AE Mez Spell|0"
            /declare MezAECount                     int         outer ${MezAESpell.Arg[2,|]}
            /varset MezAESpell                      ${MezAESpell.Arg[1,|]}
        }
        /declare MezCount[13]                   int         outer 0
        /declare MezAEClosest                   int         outer 0
    }
        | This loads and declares the MezImmune var
        /call LoadIni "${ZoneName}" MezImmune string "List up to 10 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL False ${InfoFileName}

| ************************* Burn ****************************************|
    /call LoadIni Burn  BurnCOn                 int         0           Null          FALSE            "${ConditionsFileName}"
    /call LoadIni Burn  BurnSize                int         15
    /declare Burn[${BurnSize}]                  string      outer
    /declare BurnCond[${BurnSize}]              string      outer   TRUE
    /call LoadIni Burn  BurnText                string      "Decepticons Attack"
    /call LoadIni Burn  BurnAllNamed            int         0
    /call LoadIni Burn  Burn                    string      NULL        Burn          BurnCond        "${IniFileName}" "${ConditionsFileName}"
    /call LoadIni Burn  UseTribute              int         0
| ************************* Pull ****************************************|
    /call LoadIni Pull PullWith                 string      "Melee"
    /call LoadIni Pull PullMeleeStick           int         0
    /call LoadIni Pull MaxRadius                int         350
    /call LoadIni Pull MaxZRange                int         50
    /call LoadIni Pull CheckForMemblurredMobsInCamp                 int         0
    /call LoadIni Pull PullWait                 int         5
    /call LoadIni "${ZoneName}" MobsToPull string "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or ALL for all mobs" NULL False ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToPullSecondary string NULL NULL False ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToIgnore string "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL False ${InfoFileName}
    /call LoadIni "${ZoneName}" MobsToBurn string "List up to 10 mobs. Use full names i.e. Beget Cube,Helias,Raze or NULL" Null False ${InfoFileName}
    /call LoadIni "${ZoneName}" PullPath string "Place holder for path file. Not yet impletmented." NULL False ${InfoFileName}
    /call LoadIni Pull PullRoleToggle           int         0
    /call LoadIni Pull ChainPull                int         0
    /call LoadIni Pull ChainPullHP              int         90
    /call LoadIni Pull ChainPullPause           string      30|2
    /call LoadIni Pull PullLevel                string      0|0
    /call LoadIni Pull PullNamedsFirst          int         0
    /call LoadIni Pull ActNatural               int         1
    /call LoadIni Pull UseCalm                  int         0
    /call LoadIni Pull CalmWith                 string      Harmony
    | /call LoadIni Pull PullPath               string      NULL
| ************************* AFKTools ************************************|
    /call LoadIni AFKTools AFKHelp              string      "AFKGMAction=0 Off, 1 Pause Macro, 2 End Macro, 3 Unload MQ2, 4 Quit Game"
    /call LoadIni AFKTools AFKToolsOn           int         1
    /call LoadIni AFKTools AFKGMAction          int         1
    /call LoadIni AFKTools AFKPCRadius          int         500
    /call LoadIni AFKTools CampOnDeath          int         0
    /call LoadIni AFKTools ClickBacktoCamp      int         0
    /if (${Debug}) /echo \atDEBUG Load ini procesed \agLine#: ${Macro.CurLine}
| ************************* Tasks ****************************************|
| Do Not Edit These *****************************************************|
    /declare 1stBuffCheck           int         outer       0
    /declare AddSpam                timer       outer       0
    /declare AddsArray[50,3]        string      outer       NULL
    /declare AdvPullTimer           timer       outer       0
    /declare AdvpathPointNum        int         outer       0
    /declare AdvpathPointX          float       outer       0
    /declare AdvpathPointY          float       outer       0
    /declare AdvpathPointZ          float       outer       0
    /declare AggroOffTimer          timer       outer       0
    /declare AggroTargetID          string      outer
    /declare AggroTargetID2         string      outer       0
    /declare Attacking              int         outer       0
    /declare BBWindowOpen           timer       outer       0
    /declare BPBWindowOpen          timer       outer       0
    /declare BagNum                 int         outer       0
    /declare Banestrike             string      outer
    /declare BardStartTwist         int         outer       0
    /declare BurnActive             int         outer       0    
    /declare CampOnDeathTimer       timer       outer       0
    /declare CampXLoc               int         outer       ${Me.X}
    /declare CampYLoc               int         outer       ${Me.Y}
    /declare CampZLoc               int         outer       ${Me.Z}
    /declare CampZone               int         outer       ${Zone.ID}
    /declare CampfireClickTimer     timer       outer       0
    /declare CampfireTimer          timer       outer       0
    /declare CantHit                int         outer       0
    /declare CantSee                int         outer       0
    /declare CastResult             string      outer
    /declare ChainPullHold          int         outer       0
    /declare ChainPullTemp          string      outer 
    /declare ChainPullTimer         timer       outer       0
    /declare ChainPullTimer2        timer       outer       0
    /declare CleanBuffsTimer        timer       outer       0
    /declare CombatStart            int         outer       0
    /declare CursorID               int         outer       0
    /declare CursorIDCount          int         outer       0
    /declare CursorIDTimer          timer       outer       0
    /declare DMZ                    int         outer       ${Select[${Zone.ID},345,344,202,203,279,151,33506]}
    /declare DPSCounter             int         outer       0
    /declare DPSLastTime            int         outer       0
    /declare DPSPaused              int         outer       0
    /declare DPSPetTotal            int         outer       0
    /declare DPSSpam                int         outer       0
    /declare DPSTarget              int         outer       0
    /declare DPSTotal               int         outer       0
    /declare DPSTwisting            int         outer       0
    /declare DPSWriteOn             int         outer       0
    /declare DebuffCount            int         outer       0
    /declare DurationMod            float       outer       1
    /declare FailCounter            int         outer       0
    /declare FailMax                int         outer       3
    /declare GHCond[10]             string      outer       TRUE
    /declare GMailEvents            string      outer         
    /declare GSent                  int         outer       0
    /declare GoMActive              int         outer       0
    /declare GotHitToggle           int         outer       0
    /declare GroupHeal[10]          string      outer
    /declare HealAgain              int         outer       0
    /declare IAmDead                int         outer       0
    /declare IniNextTimer           timer       outer       0
    /declare IsTankRoaming          string      outer       0 
    /declare JoinedParty            timer       outer       0
    /declare JustZoned              timer       outer       0
    /declare LastMobPullID          int         outer       0
    /declare LastZone               int         outer       0
    /declare LookForward            int         outer       ${Me.Heading.DegreesCCW}
    /declare LooterAssigned         int         outer       0
    /declare MASitTime              timer       outer       0
    /declare MainAssist             string      outer
    /declare MainAssistClass        string      outer
    /declare MainAssistType         string      outer
    /declare MashArray[30]          string      outer
    /declare MashCond[30]           string      outer       TRUE
    /declare MedStat                string      outer
    /declare MedStat2               string      outer       Endurance
    /declare Medding                int         outer       0
    /declare MercAssisting          int         outer       0
    /declare MercInGroup            int         outer       0
    /declare MezAETimer             timer       outer       0
    /declare MezArray[50,3]         string      outer       NULL
    /declare MezBroke               int         outer       0
    /declare MezImmuneIDs           string      outer
    /declare MezMobAECount          int         outer       0
    /declare MezMobCount            int         outer       0
    /declare MezMobFlag             int         outer       0
    /declare MezMod                 int         outer       0
    /declare MobCount               int         outer       0
    /declare MobFlag                int         outer       1
    /declare MountOn                int         outer       1
    /declare MyAAExp                float       outer       ${Me.PctAAExp}
    /declare MyExp                  float       outer       ${Me.PctExp}
    /declare MyMerc                 string      outer       0
    /declare MyTargetID             int         outer       0
    /declare MyTargetName           string      outer       0
    /declare NamedCheck             int         outer       0
    /declare NeedCuring             int         outer       0
    /declare OrigRanged             string      outer       ${InvSlot[ranged].Item.Name}
    /declare PCsDetected            int         outer       0
    /declare ParseDPSTimer          int         outer       0
    /declare PetActiveState         int         outer       0     
    /declare PetAttack              timer       outer       0
    /declare PetAttackRange         int         outer       0
    /declare PetBuffCheck           timer       outer       0
    /declare PetFollowTimer         timer       outer       60s    
    /declare PetSuspendState        int         outer       0 
    /declare PetTanking             int         outer       0
    /declare PetTauntOn             int         outer       0
    /declare PetTotCount            int         outer       0
    /declare PullAlertTimer         timer       outer       0
    /declare PullAmmo               string      outer       NULL
    /declare PullItem               string      outer       NULL
    /declare PullMax                int         outer       0
    /declare PullMin                int         outer       0
    /declare PullMoveUse            string      outer       
    /declare PullPathArrayX[999]    float       outer        
    /declare PullPathArrayY[999]    float       outer
    /declare PullPathArrayZ[999]    float       outer
    /declare PullPathWpCount        int         outer       0
    /declare PullRange              int         outer       0
    /declare PullRangeActual        int         outer
    /declare PullTooFar             int         outer       0
    /declare PullWithAlt            string      outer       Melee
    /declare Pulled                 int         outer       0
    /declare Pulling                int         outer       0
    /declare ReMemCast              int         outer       0
    /declare ReMemCastLW            int         outer       0
    /declare ReMemMiscGem           string      outer       ${Me.Gem[${MiscGem}].Name}
    /declare ReMemMiscGemLW         string      outer       ${Me.Gem[${MiscGemLW}].Name}
    /declare ReMemWaitLong          string      outer       null
    /declare ReMemWaitShort         string      outer       null
    /declare ReadBuffsTimer         timer       outer       0
    /declare Redguides              int         outer       1
    /declare RememberCamp           int         outer       0
    /declare SHCond[15]             string      outer       TRUE
    /declare SHealPct               int         outer
    /declare SingleHealPoint        int         outer       0
    /declare SingleHeal[15]         string      outer
    /declare SpamTimer              timer       outer       0
    /declare TWbufflist             string      outer
    /declare TankTimer              timer       outer       0
    /declare TaskGiver              string      outer
    /declare TempMaxRadius          int         outer       0
    /declare ToClose                int         outer       0
    /declare TributeTimer           timer       outer       0
    /declare Twisting               int         outer       0
    /declare ValidTarget            int         outer       0
    /declare WaitTimer              timer       outer       0
    /declare WeaveArray[10]         string      outer
    /declare WeaveCond[10]          string      outer       TRUE
    /declare WriteBuffsMercTimer    timer       outer       0
    /declare WriteBuffsPetTimer     timer       outer       0
    /declare WriteBuffsTimer        timer       outer       0
    /declare XTSlot                 int         outer       0
    /declare XTSlot2                int         outer       0
    /if (${Debug}) /echo \atDEBUG Misc Declares Processed \agLine#: ${Macro.CurLine}
    | Set AA DurationMod for various timer from Spell Casting Reinforcement AA
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==1) /varset DurationMod 1.15
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==2) /varset DurationMod 1.3
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==3) /varset DurationMod 1.5
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==4) /varset DurationMod 1.7
    /if (${Me.AltAbility[Spell Casting Reinforcement].Rank}==5) /varset DurationMod 1.9
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==1) /varset DurationMod 1.15
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==2) /varset DurationMod 1.3
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==3) /varset DurationMod 1.5
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==4) /varset DurationMod 1.6
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==5) /varset DurationMod 1.7
    /if (${Me.AltAbility[Extended Ingenuity].Rank}==6) /varset DurationMod 1.8

    | Set AA DurationMod for mez timer from Spell Casting Reinforcement AA
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==1) /varset MezMod 6
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==2) /varset MezMod 12
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==3) /varset MezMod 18
    /if (${Me.AltAbility[Mesmerization Mastery].Rank}==4) /varset MezMod 24
    | Compensate for Eyes Wide open AA and Extended Target Window
    /declare n int local
    /declare XSlotTotal int outer 13
    /for n 1 to ${XSlotTotal}
        /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]}) {
            /if (${XTSlot} && !${XTSlot2}) /varset XTSlot2 ${n}
            /if (${XTSlot}==0) /varset XTSlot ${n}
        }
    /next n
    |  Added extra slot check and Error Message
    /if (${XTSlot}==0 || ${ChainPull} && !${XTSlot2}) {
        /echo You need more slots in your Extended Target Window set to Auto.
    /if (${ChainPull}) {
            /echo Please set at least 2 slots to Auto for Chain Pulling and restart KissAssist.
        } else {
            /echo Please set at least 1 slot to Auto and restart KissAssist.
        }
        /end
    }
    | Changed Logic for populating AggroTargetID. This change will include mobs in camp not on XTarget.
    /noparse /varset AggroTargetID ${If[${Me.XTarget[${XTSlot}].ID},${Me.XTarget[${XTSlot}].ID},${If[${AggroTargetID2},${AggroTargetID2},0]}]}
| ************************* Merc ****************************************|
    /call LoadIni Merc Help                     string      "To use: Turn off Auto Assist in Manage Mercenary Window"
    /call LoadIni Merc MercOn                   int         0
    /call LoadIni Merc MercAssistAt             int         92
    /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
    /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
    /if (${Debug}) {
		/echo \atDEBUG Timers Processed \agLine#: ${Macro.CurLine}
	}
| -------------------------------------------------------------------------------------
| Check if required plugins are loaded and settings
| -------------------------------------------------------------------------------------
	/echo [${Time}] START CheckAllPlugins
	/call CheckAllPlugins
	/echo [${Time}] END CheckAllPlugins
    |  Turn aggro mode off and turn on melee mode in MQ2Melee
	/echo UseMQ2Melee = ${UseMQ2Melee}
    /if (!${UseMQ2Melee}) {
		/if (${Bool[${Plugin[mq2melee]}]}) /plugin mq2melee unload noauto
	}
	/echo [${Time}] START UseMQ2Melee
    /if (${UseMQ2Melee}) {
		/if (${Bool[${Plugin[mq2melee]}]}) {
			/squelch /melee aggro=0
			/squelch /melee melee=1
			/squelch /melee stickbreak=1
			/squelch /melee petassist=0
			/squelch /melee on
			/squelch /melee stickmode=0
		}
    }
    /echo [${Time}] Set MQ2moveutils variables
	|mq2moveutils saves EVERYTHING on each save... we dont want to wait that long.
	|and besides a macro has NO buisness AT ALL changing the users plugin settings permanently.
	|we turn on autosave in the :OnExit event anyway.
	/stick set autosave off
    /if (${Debug}) {
		/stick set verbflags 33554431
	} else {
		/stick set verbflags 0
	}
    |There is no such setting in mq2moveutils, its only a command /stick set moveback 12
	/echo [${Time}] /stick Set breakonkb on
    /stick set breakonkb on
	/echo [${Time}] /stick Set breakonmouse off
    /stick set breakonmouse off
	/echo [${Time}] /stick Set breakdist ${CampRadiusExceed}
    /stick set breakdist ${CampRadiusExceed}
	/echo [${Time}] /stick Set breakonwarp on
    /stick set breakonwarp on
	/echo [${Time}] /stick Set usefleeing on
    /stick set usefleeing on
	/echo [${Time}] /stick Set delaystrafe on
    /stick set delaystrafe on
    /echo [${Time}] Set up MQ2rez if RezAcceptOn=1
    /if (${RezAcceptOn.Arg[1,|].Equal[1]}) {
        /squelch /rez accept on
        /squelch /rez loot off
        /if (${Int[${RezAcceptOn.Arg[2,|]}]}>0) /rez pct ${Int[${RezAcceptOn.Arg[2,|]}]}
    } else /squelch /rez accept off
    /if (${Select[${AFKToolsOn},1,2]}) {
        /posse radius ${AFKPCRadius}
        /posse friendnotify off
        /posse strangernotify on
        /if (!${Posse.Status})  {
            /posse on
            /posse load
        }
    }
    | Initialize variables for ninjadvloot.inc include file
	
	/echo [${Time}] START: setting up lootvars
    /call SetupAdvLootVars
	/echo ${Time} END: setting up lootvars
	/echo ${Time} START: Sorting heals
    /if (${HealsOn}) {
        /call SortArray Heals HealsCond 100|100 >
        /call FindSingleHeals
        /call FindGroupHeals
        /call CreateTimersHeals
    }
	/echo ${Time} END: Sorting heals
	/echo ${Time} START: AlertAddToList
    /call AlertAddToList 3 "${MobsToIgnore}"
    /call CreateTimersGoM
	/echo ${Time} END: AlertAddToList
	/echo ${Time} START: SortArray DPS
    /if (${DPSOn}) /call SortArray DPS DPSCond 1|1 <
    /if (${BuffsOn}) /call SortArray Buffs null 100|100 >
    /if (${AggroOn}) /call SortArray Aggro AggroCond 1|1 >
    /call SortArray Burn BurnCond 1|1 >
    /if (${AutoRezOn}) /call CreateTimersRez
    /if (${MezOn}) /call CreateTimersMez
    /if (!${MezImmune.Find[List up to 10 mobs]}) /call AlertAddToList 4 "${MezImmune}"
    /if (${PullLevel.Find[auto]}) {
       /varcalc PullMin ${Me.Level}-5
       /varcalc PullMax ${Me.Level}+2       
    } else /if (${PullLevel.Equal[0|0]} || ${PullLevel.Equal[0]} || ${PullLevel.Equal[null]} || !${PullLevel.Find[|]}) {
       /varset PullMin 1
       /varset PullMax 200
       /varset PullLevel off
    } else {
       /varset PullMin ${PullLevel.Left[${Math.Calc[${PullLevel.Find[|]}-1]}]}
       /varset PullMax ${PullLevel.Right[${Math.Calc[${PullLevel.Length}-${PullLevel.Find[|]}]}]} 
    }
    /if (${PullMin}>${PullMax} || ${PullMin}==0 || ${PullMax}==0) {
       /echo Invalid Pull Level Settings resetting to default.
       /varset PullMin 1
       /varset PullMax 200
       /varset PullLevel off
    }
	/echo ${Time} START: Checking your ini file for errors
    /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Zone].Length}) {
        /echo Checking your ini file for errors. 
        /call ScanIni
    }
	/if (${Macro.Params}) {
		/call PParse 1 ${NumParams}
	}
    /if (${GMailOn}) /call GmailIniParse
	/echo [${Time}] Assign Main Tank from command line parameter or targeted player, merc or pet
| -------------------------------------------------------------------------------------
| Assign Main Tank from command line parameter or targeted player, merc or pet
| -------------------------------------------------------------------------------------
    /if (${ParseDPSTimer}>=1) {
        /target id ${Me.ID}
        /delay 10 ${Target.ID}==${Me.ID}
        /if (${DPSOn}) /varset DPSOn 2
        /varset Role Tank
        /call Bind_AssignMainAssist
        /call CheckRoles
        /call CheckBuffs
        /call Bind_Parse ${ParseDPSTimer}
    }
	/if (!${MainAssist.Length}) {
		|Make pet if it isn't up already !!!!
		/if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && !${Me.Pet.ID}) {
			/echo My role is (${Role}), but I have no active pet.
			/echo Making my pet so I can assign it as Main Assist!
			/call DoPetStuff
		}
		/if (!${Target.ID} && ${Select[${Role},tank,pullertank,hunter]}) {
			/target id ${Me.ID}
			/delay 10 ${Target.ID}==${Me.ID}
		}
		/if ((!${Target.ID} || ${Target.ID}!=${Me.ID}) && ${Select[${Role},pettank,pullerpettank,hunterpettank]}) {
			/target id ${Me.ID}
			/delay 10 ${Target.ID}==${Me.ID}
		}
		/call Bind_AssignMainAssist
    } else /if (${MainAssist.Length}) {
        /if (${Debug}) {
			/echo ${MainAssist} \agLine#: ${Macro.CurLine}
		}
		/if (${Spawn[=${MainAssist}].ID}) {
			/target id ${Spawn[=${MainAssist}].ID}
			/if (${Debug}) {
				/echo targeting ${Spawn[=${MainAssist}].ID} \agLine#: ${Macro.CurLine}
			}
			/delay 10 ${Target.ID}==${Spawn[=${MainAssist}].ID}
			| Target PC instead of familiar or pet
			/if (${Spawn[=${MainAssist}].Type.Equal[Pet]} && !${MainAssist.Find[`s]}) {
				/tar pc ${MainAssist}
				/delay 10 ${Target.ID}==${Spawn[${MainAssist} pc].ID}
			}
		}
        /call Bind_AssignMainAssist
    }
    /if ((!${Target.ID} || ${Target.CleanName.NotEqual[${Me.CleanName}]}) && ${Select[${Role},hunter,pullertank]}) {
		/target id ${Me.ID}
		/delay 10 ${Target.ID}==${Me.ID}
    }
    | Targeted myself end macro
    /if (${Target.CleanName.Equal[${Me.CleanName}]} && (${Role.Equal[assist]} || ${Role.Equal[puller]})) {
        /echo ERROR: You cannot assist yourself! Please target Main Tank and restart macro.
        /beep
        /end
    }
    | Error control no tank selected end macro
    /if (!${Target.ID} || !${Select[${Target.Type},Mercenary,PC,Pet]} || ${Me.Type.Equal[corpse]}) {
        /echo ERROR: You have >> ${Target.CleanName} << targeted. Please target a Mercenary, PC or Pet for Main Tank and restart the macro.
        /beep
        /end
    }
    /call CheckRoles
    /echo ================================
    /echo Redguides presents
    /if (${MacroModder.NotEqual[NULL]}) {
    	/echo ${MacroName} v.${MacroVer} by Maskoi v${ModVersion} mod by ${MacroModder}
    	/popup ${MacroName} v.${MacroVer} by Maskoi v${ModVersion} mod by ${MacroModder}
    } else {
    	/echo ${MacroName} v.${MacroVer} by Maskoi
    	/popup ${MacroName} v.${MacroVer} by Maskoi
    }
    /echo ================================
    /doevents
    /if (${Select[${Role},tank]}) {
        /if (${MainAssist.Equal[${Me}]}) {
            /echo I am Tanking & Main Assist
        } else {
           /echo  I am Tank & KissAssisting >> ${MainAssist} <<
        }
    } else /if (${Select[${Role},puller]}) {
        /echo I am Puller. KissAssisting >> ${MainAssist} << at ${AssistAt}%
        /if (${ChainPull}) /echo  What? I have to chain pull now.
    } else /if (${Select[${Role},pullertank]}) {
        /echo I am Puller & Tank.
    | PetTank set role
    } else /if (${Select[${Role},pettank]}) {
        /echo My Pet >> ${Me.Pet.CleanName} << is Tanking & KissAssisting >> ${MainAssist} <<
    | PullerPetTank set role
    } else /if (${Select[${Role},pullerpettank]}) {
        /echo I am Pulling & my Pet >> ${Me.Pet.CleanName} << is Tanking.
        /echo We are all doomed.
        /delay 10
        /echo DOOMED!
    | HunterPetTank set role
    } else /if (${Select[${Role},hunterpettank]}) {
        /echo I am Hunting & my Pet >> ${Me.Pet.CleanName} << is Tanking.       
    } else /if (${Select[${Role},hunter]}) {
        /echo I am Hunting.
    } else {
        /echo KissAssisting >> ${MainAssist} << at ${AssistAt}%
        /echo ${MainAssist} is a ${MainAssistType} ${Spawn[=${MainAssist}].Class}
    }
    | If I am group leader set Main Assist Tag for Group Check for pet and make master MainAssist
    /if (${Select[${Me},${Group.Leader}]} && (${Spawn[group ${MainAssist}].ID} || (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[group ${Spawn[${MainAssist}].Master.CleanName}].ID}))) { 
        | If Main Assist is someone else than who its suppose to be unset Group tag
        /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
            /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
        }
        /if (!${Group.MainAssist.Name.Length}) {
            /if (${Spawn[${MainAssist}].Type.Equal[pet]}) {
                /call BroadCast ${IRCOn} ${EQBCOn} r "Assigning ${Spawn[${MainAssist}].Master.CleanName} as Main Assist in Group Window"
                /call AssignGroupRole set "${Spawn[${MainAssist}].Master.CleanName}" 2
            } else {
            /call BroadCast ${IRCOn} ${EQBCOn} r "Assigning ${MainAssist} as Main Assist in Group Window"
            /call AssignGroupRole set "${MainAssist}" 2
            }
        }
    } else /if (${Select[${Me},${Group.Leader}]}) {
        /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
            /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
        }
    }
	/echo clearing target 1
    /squelch /target clear
    /squelch /assist off
    /if (${Role.Find[pull]}) {
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} r "PULL: Path >> ${PullPath} <<  found with ${PullPathWpCount} waypoints."
            /call BroadCast ${IRCOn} ${EQBCOn} r "PULL: Using MQ2AdvPath to Pull"
        } else /if (${mq2navloaded}) {
			/if (${Navigation.MeshLoaded}) {
            	| Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
            	/varset PullMoveUse nav
            	/call BroadCast ${IRCOn} ${EQBCOn} r "PULL: The MQ2Nav mesh for ${Zone} is loaded"
            	/call BroadCast ${IRCOn} ${EQBCOn} r "PULL: Using MQ2Nav to Pull"
			}
        }    
    }    
    /if (${LoadSpellSet}) /call LoadSpellSet
    /call WinTitle
| -------------------------------------------------------------------------------------
| Main Loop
| -------------------------------------------------------------------------------------
        :MainLoop
            /doevents
            /if (${ChainPull}!=2) {
                /call CampfireBack
                /if (${AFKToolsOn}) /call AFKTools
                /call CheckForCombat 1 MainLoop
                /if (${AEOn}) /call AECheck
                /if (${MezOn}) /call DoMezStuff
                /call WriteDebuffs
                /if (${HealsOn}) /call CheckHealth
                /if (${CuresOn}) /call CheckCures
                /if (${Me.CombatState.NotEqual[COMBAT]}) {
			/call DoWeMove MainLoop
		}
                /if (${AutoRezOn}) /call RezCheck
                /if (${CampfireOn} && ${Me.CombatState.NotEqual[COMBAT]}) /call Campfire
                /call DoMiscStuff
                /call CanIDoStuff
                /if (${MercOn}) /call MercsDoWhat
                /call CastMana
                /if (${PetOn}) /call DoPetStuff
                /if (${PetOn}) /call CheckPetBuffs
                /if (${Me.CombatState.NotEqual[COMBAT]}) {
                    /call WriteBuffs
                    /call WriteBuffsMerc
                    /call WriteBuffsPet
                }
                /if (${BuffsOn}) /call CheckBuffs
                /if (${IAmABard}) /call DoBardStuff
                /if (${Me.CombatState.NotEqual[COMBAT]}) /if (${MedOn}) /call DoWeMed
                /if (${Me.CombatState.NotEqual[COMBAT]}) /if (${GroupWatchOn}) /call GroupWatch
            }
            /if (${ChainPull}==2) /call AFKTools
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) /call FindMobToPull 1
            /if (${DPSOn} || ${MeleeOn}) {
                /call CheckForCombat 0 MainLoop
            } else {
                /call CheckForCombat 2 MainLoop
            }
            /if (${LootOn}) /call LootStuff
            /if (${DebugHeal}) /delay 5 
            /delay 1
			/if (${bCallCustom}==1) {
				/call MyCustom
			}
        /goto :MainLoop

:OnExit
	/echo running OnExit 
	/stick set verbflags 33554431
	/stick set autosave on
	/end
/return
Sub MyCustom

/return
| -------------------------------------------------------------------------------------
| SUB: PParse Parse passed command line parameters
| -------------------------------------------------------------------------------------    
Sub PParse(int iniLoaded, int nump)
    /declare i int local 0
    /declare j int local 0
    /declare k int local 0
    /declare TempPathX float local 0
    /declare TempPathY float local 0
    /declare TempPathZ float local 0
    /declare ipa int local 0
    /declare ipb int local 0

    /for i 0 to ${nump}
        /if (${Defined[PParam${i}]}) {
            /if (${Debug}) {
		/echo \atDEBUG PParse Enter:  Defined[IniFileName] =  ${Defined[IniFileName]} ${Defined[PParam${i}]} #${i} PParam${i} = ${PParam${i}} PParam${i} Length = ${PParam${i}.Length} is PParam${i} equal ma? ${PParam${i}.Equal[ma]}  ${Int[${PParam${i}}]} \agLine#: ${Macro.CurLine}
            }
	    /varcalc ipa ${i}+1
            /varcalc ipb ${i}-1
            /if (${PParam${i}.Equal[ini]} && ${Defined[IniFileName]}) {
                /varset IniFileName ${PParam${ipa}}
                /echo Ini file has been set to >> ${PParam${ipa}} <<
                /varset PIniSet 1
            }
            /if (${Select[${PParam${i}},assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank]} && ${Defined[Role]}) /varset Role ${PParam${i}}
            /if (${PParam${i}.Equal[ma]} && ${Defined[MainAssist]}) {
				/if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
				/varset MainAssist ${PParam${ipa}}
			}
            /if (${Select[${PParam${i}},ini,parse,assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank]}==0 && ${Int[${PParam${i}}]}==0) {
				/if (!${PParam${i}.Find[.ini]} && !${PParam${i}.Find[kissassist]} && !${PParam${i}.Find[${EverQuest.Server}]} && ${Defined[MainAssist]}) {
					/echo im setting mainassist to ${PParam${i}}
					/varset MainAssist ${PParam${i}}
				}
			}
			/if (${PParam${i}.Equal[assistat]} && ${Defined[AssistAt]}) {
				/if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
				/varset AssistAt ${PParam${ipa}}
			}
            /if (${Defined[PParam${ipb}]}) {
				/if (${PParam${ipb}.NotEqual[parse]}) {
					/if (${Int[${PParam${i}}]} >= 1 && ${Int[${PParam${i}}]} <= 100 && ${Defined[AssistAt]}) {
						/varset AssistAt ${PParam${i}}
					}
				}
			}
			/if (${Defined[PullPathWpCount]}) {
				/if (${PParam${i}.Equal[path]} && ${Defined[PullPath]}) {
                    /call CheckPlugin MQ2AdvPath
					/varset mq2advpathloaded 1
                    /delay 20 ${AdvPath.Active}
        	        | Play path on pause to load info . Only way we can grab info from advpath
        	        /if (${AdvPath.PathList[${PParam${ipa}}]}) {
        				/play ${PParam${ipa}} pause
        				/varset PullPath ${PParam${ipa}}
        				/delay 10
        				| Set PullPathWpCount with total amount of waypoints in path
        				/varset PullPathWpCount ${AdvPath.Waypoints}    
        				| Load path points into array
        				/for k 1 to ${PullPathWpCount} 
        					/if (${Debug}) {
								/echo \atDEBUG PParse WP#: ${Int[${Math.Calc[${k}-1]}]}-${k} Distance Between: ${Math.Distance[${TempPathY},${TempPathX}:${AdvPath.Y[${k}]},${AdvPath.X[${k}]}]} \agLine#: ${Macro.CurLine}
                			}
							/varset PullPathArrayX[${k}] ${AdvPath.X[${k}]}
                			/varset PullPathArrayY[${k}] ${AdvPath.Y[${k}]}
                			/varset PullPathArrayZ[${k}] ${AdvPath.Z[${k}]}
                			/varset TempPathX ${PullPathArrayX[${k}]}
                			/varset TempPathY ${PullPathArrayY[${k}]}
                			/varset TempMaxRadius ${Math.Distance[${CampYLoc},${CampXLoc}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
               				/if (${TempMaxRadius}>${MaxRadius}) /varset MaxRadius ${Math.Distance[${CampYLoc},${CampXLoc}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                        	/if (${Debug}) {
								/echo \atDEBUG PParse: WP: ${k} WPX: ${PullPathArrayX[${k}]} WPY: ${PullPathArrayY[${k}]} \agLine#: ${Macro.CurLine}
                        	}
						/next k    
                        /varset TempMaxRadius ${MaxRadius}
                        /play off
                        | Tell Kiss were are using MQ2advpath for pulling
                        /varset PullMoveUse advpath
                    } else {
                    	/echo Path ${PParam${ipa}} not found.
                    	/varset PullMoveUse 
                    	/varset PullPathWpCount 0
                    }
				}
            }
            /if (${PParam${i}.Equal[parse]} && ${Defined[ParseDPSTimer]}) {
		/if (!${Defined[PParam${ipa}]}) /declare PParam${ipa} string outer
		/varset ParseDPSTimer ${PParam${ipa}}
	    }
	    /if (${PParam${i}.Equal[custom]}) {
			/varset bCallCustom 1
	    }
            /varset ipa 0
            /varset ipb 0
        }
    /next i
    /if (${Debug}) {
		|these are not set when this sub gets called first time so in practice we cant echo them...
		/if (${iniLoaded}) {
			/echo \atDEBUG PParse Leave Role: ${Role} MA:${MainAssist} AssistAt:${AssistAt} INI:${IniFileName} PullPath:${PullPath} Parse:${ParseDPSTimer} \agLine#: ${Macro.CurLine}
		} else {
			/echo \atDEBUG PParse Leave
		}
	}
/return
| -------------------------------------------------------------------------------------
| SUB: CheckForCombat Used to help with controlling combat
| -------------------------------------------------------------------------------------
    Sub CheckForCombat(int SkipCombat, string FromWhere)
        /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat Enter SkipCombat: ${SkipCombat} ChainPull: ${ChainPull} Role: ${Role} ${FromWhere} \agLine#: ${Macro.CurLine}
        /if (${SkipCombat}) /goto :SkipMelee
        :CombatTop
            /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0) ) /varset IAmDead 0
            /call MobRadar ${MeleeDistance} CheckForCombat
            /if (${Debug}) /delay 10
            /if ((${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Hovering} || (${IAmDead} && !${AggroTargetID}) || (!${MobCount} && !${AggroTargetID}) || (!${DPSOn} && !${MeleeOn})) /return
            /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat: Assist/Combat Begin ${If[!${SkipCombat},Normal,CheckForAdds]}  \agLine#: ${Macro.CurLine}
            /call Assist
            /call Combat 
            /if (${Debug} || ${DebugCombat}) /echo \atDEBUG  CheckForCombat: Assist/Combat End ${If[!${SkipCombat},Normal,CheckForAdds]}  \agLine#: ${Macro.CurLine}
            /if (${ChainPull}==2) /return
            :SkipMelee
            /if (${MezOn}) {
                /varset MezBroke 0
                /doevents MezBroke
                /if (!${MezBroke}) /call DoMezStuff
            }
            /if (${SkipCombat}==2) {
                /if (${AggroTargetID}) {
                    /if (${HealsOn}) /call CheckHealth
                    /if (${CuresOn}) /call CheckCures
                    /if (${AutoRezOn}) /call RezCheck
                    /call CastMana
                    /call WriteDebuffs
                    /goto :SkipMelee
                } else {
                    /return
                }
            } 
            /call CheckForAdds CheckForCombat
            /if (${Role.Equal[tank]} || ${Role.Equal[pullertank]}) {
                | If tank is assisting puller and in chase mode
                /if (${MainAssist.NotEqual[${Me}]} && ${ChaseAssist}) {
			/call DoWeMove "CheckForCombat 1"
		}
                /if (${ReturnToCamp} && ((!${MobCount} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>5) || (${MobCount}==1 && ${AggroTargetID} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>75))) {
			/call DoWeMove "CheckForCombat 2"
		}
                /if ((${MobCount} && ${AggroTargetID}) || ${TankTimer}) /goto :CombatTop
            }
        /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat MobCount: ${MobCount} AggroTargetID: ${AggroTargetID} ChainPull: ${ChainPull} \agLine#: ${Macro.CurLine}
        /if (((${AggroTargetID} || (${MezMobFlag} && ${MobCount})) && !${ChainPull}) || (${MobCount}>1 && ${ChainPull})) /goto :CombatTop
        /if (${MobCount}==1 && ${ChainPull} && ${MyTargetID} && ${Spawn[${MyTargetID}].PctHPs}<=${ChainPullHP}) /return
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 5) {
            /if (${MainAssist.NotEqual[${Me}]}) /delay ${Math.Calc[${Math.Rand[1]}+1]}s
            /if (${MobCount}<=0) /call DoWeMove "CheckForCombat 3"
        }
        /if (${Debug} || ${DebugCombat}) /echo \atDEBUG CheckForCombat Exit. \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Assist - Get Main Tank's target
| -------------------------------------------------------------------------------------
    Sub Assist
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (!${MeleeOn} && !${DPSOn} && !${MezOn}) /return
        /if (${DPSPaused}) /return
        /if (${Me.Hovering}) /return
        /if (${Pulled} && ${MyTargetID} && ${MainAssist.Equal[${Me}]}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare n int local
        /declare ClosestMobID int local 0
        /declare BlurredMobID int local 0
        /declare XTDistance float local 0
        /declare TempTargetID int local
        /doevents
        /call MobRadar ${MeleeDistance} Assist
            | Normal assist check		
		/if (${DebugCombat}) {
			/echo \atDEBUGCOMBAT Assist0: ${Me} ${MainAssist} ${Spawn[=${MainAssist}].Distance} ${MobCount} ${AggroTargetID} ${Target.ID} ${MyTargetID} \agLine#: ${Macro.CurLine}
			/if (${UseMQ2Melee}) {
				/echo \atDEBUGCOMBAT Melee=${Melee} Melee.Combat=${Melee.Combat} Melee.Target=${Melee.Target} Melee.Status=${Melee.Status} \agLine#: ${Macro.CurLine}
			}
		}
		/if (${MainAssist.NotEqual[${Me}]} && (${MobCount} || ${AggroTargetID})) {
                /if (${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Distance}<200) {
                    /if (${DebugCombat}) {
			/echo \atDEBUGCOMBAT Assist1: ${Me} ${MainAssist} ${Group.MainAssist.ID} ${Spawn[=${MainAssist}].Distance} ${MobCount} ${AggroTargetID} ${Me.XTarget[${XTSlot}].ID} ${Me.XTarget[${XTSlot2}].ID} \agLine#: ${Macro.CurLine}
                    }
		    /if (${Bool[${Group.MainAssist.ID}]}==TRUE) {
                            /if (${Target.ID}!=${Me.GroupAssistTarget.ID}) {
				/target id ${Me.GroupAssistTarget.ID}
                            	/delay 10 ${Me.GroupAssistTarget.ID}==${Target.ID}
			    }
                    } else /if (${Me.XTarget[1].TargetType.Equal[Specific PC]} && ${Me.XTarget[1].ID}) {
			/invoke ${Me.XTarget[1].DoAssist}
                        /delay 10 ${Me.AssistComplete}==TRUE
                    } else {
                        /assist ${MainAssist}
                        /delay 10 ${Me.AssistComplete}==TRUE
                    }
                    | Target mob when assisting puller and they are targeting Tank
                    /if (${Target.CleanName.Equal[${Me}]} && (${MobCount} || ${AggroTargetID})) {
			/echo clearing target 2
                        /squelch /target clear
			/echo Targeting a mob 1: ${Spawn[${AggroTargetID}]}
                        /squelch /target id ${AggroTargetID}
                        /delay 10 ${AggroTargetID}==${Target.ID}
                    }
                    /goto :validatetarget
                | If the tank is dead and aggro mob in camp target 1st mob on autohater in xtarget
                } else /if (!${Spawn[=${MainAssist}].ID} && ${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<=${CampRadius}) {
                    /echo Targeting a mob 2: ${Spawn[${AggroTargetID}]}
		    /squelch /target id ${AggroTargetID}
                    /delay 10 ${AggroTargetID}==${Target.ID}
                    /goto :validatetarget
                }   
            }
            /if (${MainAssist.Equal[${Me}]} || ${Select[${Role},tank,pullertank,pettank,pullerpettank]}>0) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist2: MainAssist.Equal[${Me}] is ${MainAssist.Equal[${Me}]} OR my role is ${Role} MobCount = ${MobCount} \agLine#: ${Macro.CurLine}
                /if (${Target.CleanName.Equal[${Me}]} && (${MobCount} || ${AggroTargetID})) {
			/echo clearing a target 3
			/squelch /target clear
		}
                | I am tank with a single mob wait for it then validate and attack.
                /if (${MobCount}==1 && (!${XTSlot2} || (${XTSlot2} && !${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID}) {
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist: ${MobCount}==1 && ${AggroTargetID} \agLine#: ${Macro.CurLine}
                    /if (${Target.ID}!=${AggroTargetID}) {
			/echo Targeting a mob 3: ${Spawn[${AggroTargetID}]}
		    	/squelch /target id ${AggroTargetID}
                    	/delay 10 ${Target.ID}==${AggroTargetID}
                    	/if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist: Single target: ${AggroTargetID} ${Spawn[${AggroTargetID}].CleanName} \agLine#: ${Macro.CurLine}
                    }
		    /goto :validatetarget
                }
                | More than one mob
                /if ((${MobCount}>=2 || (${XTSlot2} && ${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID}) {
                    | Check if named incoming an target if true else assign closest target.
                    /for n 1 to ${XSlotTotal}
                        /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${n}].ID}) {
                            /if (${Me.XTarget[${n}].Named}) {
                                /squelch /target id ${Me.XTarget[${n}].ID}
                                /delay 10 ${Target.ID}==${Me.XTarget[${n}].ID}
                                /goto :validatetarget
                            }
                            | Tank mez immune mobs first.
                            /if (${Alert[4].Size}) {
                                /for j 0 to ${Alert[4].Size}
                                    /if (${Alert[4].List[${j}].Name.Equal[${Me.XTarget[${n}].CleanName}]} && ${Alert[4].List[${j}].Name.Length}) {
                                        /call BroadCast ${IRCOn} ${EQBCOn} y "Grabbing MEZ Immune -> ${Me.XTarget[${n}].CleanName} <- ID:${Me.XTarget[${n}].ID} "
                                        /squelch /target id ${Me.XTarget[${n}].ID}
                                        /delay 10 ${Target.ID}==${Me.XTarget[${n}].ID}
                                        /goto :validatetarget
                                    }
                                /next j
                            }
                            /if (!${ClosestMobID}) /varset ClosestMobID ${Me.XTarget[${n}].ID}
                            /if (${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]}>${Math.Distance[${Me.XTarget[${n}].Y},${Me.XTarget[${n}].X}:${CampYLoc},${CampXLoc}]}) /varset ClosestMobID ${Me.XTarget[${n}].ID}
                        }
                    /next n
                    | Don't need to target mob on incoming and out of meleedistance'
                    /if (${Target.ID}!=${ClosestMobID} && ${MobCount}) {
                        /echo Targeting a mob 4: ${Spawn[${ClosestMobID}]}
			/squelch /target id ${ClosestMobID}
                        /delay 10 ${Target.ID}==${ClosestMobID}
                    }
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT ClasestMobID: ${ClosestMobID} Distance: ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} XTarget[${XTSlot2}] ID: ${Me.XTarget[${XTSlot2}].ID} Distance: ${Math.Distance[${Me.XTarget[${XTSlot2}].Y},${Me.XTarget[${XTSlot2}].X}:${CampYLoc},${CampXLoc}]} AgroTargetID: ${AggroTargetID} \agLine#: ${Macro.CurLine}
                    /goto :validatetarget
                }
                | Check for memblurred mobs in camp when nothing left on xtarget. Check only for 5 secs after last mob.
                /if (${CheckForMemblurredMobsInCamp}) {
					/if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist3: ${AggroTargetID} ${MobCount} ${MezMobFlag} \agLine#: ${Macro.CurLine}
	                /if (!${AggroTargetID} && ${MobCount} && ${MezMobFlag}==1) {
	                    /varset BlurredMobID ${NearestSpawn[1,npc targetable los radius ${MeleeDistance} zradius 50 noalert 3].ID}
	                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist4: ${BlurredMobID} ${Math.Distance[${Spawn[${BlurredMobID}].Y},${Spawn[${BlurredMobID}].X}:${CampYLoc},${CampXLoc}]} ${MeleeDistance} \agLine#: ${Macro.CurLine}
	                    /if (${BlurredMobID} && ${Math.Distance[${Spawn[${BlurredMobID}].Y},${Spawn[${BlurredMobID}].X}:${CampYLoc},${CampXLoc}]}<${MeleeDistance}) {
	                        /echo Targeting a blurred mob: ${Spawn[${BlurredMobID}]}
				/target ID ${BlurredMobID}
	                        /varset MezMobFlag 0
	                        /delay 10 ${Target.ID}==${BlurredMobID}
	                        /delay 30 ${Target.Mezzed.ID}
	                            /if (${Target.Mezzed.ID}) {
	                            /call BroadCast ${IRCOn} ${EQBCOn} y "Found Mezzed Mob: ${Spawn[${BlurredMobID}].CleanName} <- ID:${BlurredMobID}"
	                            /echo MEZ >> Found a Mezzed mob in Camp. <<
	                            /varset AggroTargetID2 ${BlurredMobID}
	                            /varset MyTargetID ${Target.ID}
	                            /varset MyTargetName ${Target.CleanName}
	                        }
	                        /return
	                    }
	                }
				}
                /varset MezMobFlag 0
            }
        :validatetarget
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist: validatetarget ID:${Target.ID} \agLine#: ${Macro.CurLine}
        /if (!${Target.ID}) {
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist: Validate Target - No target return \agLine#: ${Macro.CurLine}
            /return
        }
        | 3 sec delay to be able to target toons for buffs
        /if (${Target.Type.Equal[pc]} || ${Target.Type.Equal[mercenary]} || ${Target.Type.Equal[npc]} && !${AggroTargetID}) /delay 30
        /varset TempTargetID ${Target.ID}
        /call ValidateTarget
        | If target is not valid return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist Target:${Target.CleanName} ValidTarget:${ValidTarget} Marco Return:${Macro.Return} \agLine#: ${Macro.CurLine}
        /if (${ValidTarget}==0) {
            /squelch /alert add 2 id ${Spawn[${Target.CleanName}].ID}
            /varset MyTargetID 0
            /varset MyTargetName
            /return
        }
        /if (${ValidTarget}) {
            /if (${Target.ID}!=${TempTargetID}) {
		/echo Targeting a mob 6: ${Spawn[${TempTargetID}]}
               /squelch /target clear
               /delay 10 !${Target.ID}
               /target id ${TempTargetID}
               /delay 10 ${Target.ID}==${TempTargetID}
            }
           /varset MyTargetID ${Target.ID}
           /varset MyTargetName ${Target.CleanName}
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist MyTargetName:${MyTargetName} ID:${MyTargetID} \agLine#: ${Macro.CurLine}
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Assist Leave \agLine#: ${Macro.CurLine}
    /return   
| -------------------------------------------------------------------------------------
| SUB: Validate Target Combined Spawn and Target
| -------------------------------------------------------------------------------------
    Sub ValidateTarget(int SpawnID)
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Enter Target Name:${Target.CleanName} ID:${Target.ID} Spawn Name: ${Spawn[${SpawnID}].CleanName} ID:${SpawnID} \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare k int local
        /declare n int local
        /declare XTValid int local 0
        /declare PullValid int local 0
        /declare MobID int local 0
        /declare MobName string local
        /declare MobType string local        
        /varset ValidTarget 0
        /if (${SpawnID}) {
           /varset MobID ${Spawn[${SpawnID}].ID}
           /varset MobName ${Spawn[${SpawnID}].CleanName}
           /varset MobType ${Spawn[${SpawnID}].Type}
        } else {
           /varset MobID ${Target.ID}
           /varset MobName ${Target.CleanName}
           /varset MobType ${Target.Type}
        }
        /if (!${MobID}) /return NoTarget
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 1 \agLine#: ${Macro.CurLine}
        /if (${Select[${MobType},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,TRIGGER,TRAP,TIMER,MOUNT,Mercenary]}) /return BadTargetType
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 2 \agLine#: ${Macro.CurLine}
        | If mob found on ignore and not on xtarget skip
        /if (${MobsToIgnore.Find[${MobName}]} && ${Select[${MobID},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]}==0) /return MobOnIgnoreList
        | Check if target is somewhere on my extended target.        
        /if (${Select[${Role},tank]} && ${MobCount}<=${XSlotTotal} && ${Spawn[${MainAssist} ${MainAssistType} group].ID}) {
            /for n 1 to ${XSlotTotal}
                /if (${MobID}==${Me.XTarget[${n}].ID}) {
                    /varset XTValid 1
                    /goto :XTValidSkip
                }
            /next n
            :XTValidSkip
            /if (!${XTValid}) /return NotOnXTarget
        }
        /if (${Spawn[${MobID}].Distance}>${MeleeDistance} && !${Pulling} && ${Select[${Role},tank,pullertank,pettank,pullerpettank]} && !${AggroOn} && !${MainAssist.NotEqual[${Me}]} && !${Select[${Role},Tank]}) /return OutofCampRadius
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 3 \agLine#: ${Macro.CurLine}
        | Only valid when pulling
        /if (${Pulling} && !${Pulled} ) {
            /if ((!${PullPathWpCount} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) /return OutofRadius
            /if (${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${MobID}].LineOfSight} && !${PullPathWpCount}) {
		/if (${mq2navloaded}) {
			/if (!${Navigation.MeshLoaded}) {
				/return NoLOS
			}
		} else {
			/return NoLOS
		}
	    }         
            /if (${SpawnCount[loc ${Spawn[${MobID}].Y} ${Spawn[${MobID}].X} radius 12 pc]}>=1 && ${Pulling} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${Me.Y},${Me.X}]}>=16) /return PCNear
            /if (${Spawn[${MobID}].PctHPs}<=99) {
		/echo NEED TO TARGET TO CHECK HPs
		/target id ${MobID}
		/delay 2s ${Target.ID}==${MobID} && ${Target.BuffsPopulated}==TRUE
		/if (${Spawn[${MobID}].PctHPs}<=99) {
			/return PullNotFullHealth
		}
	    }
            /if (${Spawn[${MobID}].Level}<${PullMin} || ${Spawn[${MobID}].Level}>${PullMax}) /return BadLevel 
            /if (${Window[TargetOfTargetWindow].Open} && ${Target.ID}==${MobID}) {
            | - If mob I'm pulling is aggroed already by non damaging spell by someone else.
               /delay 10
               /if (${Me.TargetOfTarget.Type.Equal[PC]} && ${Me.TargetOfTarget.Name.NotEqual[${Me}]} && ${Group.Member[${Me.TargetOfTarget.Name}].Index}<1) /return PullToTTNotPuller
               /if (${Me.TargetOfTarget.Type.Equal[PET]} && ${Me.TargetOfTarget.Name.NotEqual[${Me.Pet.CleanName}]}) /return PullToTTNotMyPet
            }
            /if (${DebugPull} && !${MobsToPull.Find[null]}) /echo \atDEBUGPULL ValidateTarget ${MobsToPull} \agLine#: ${Macro.CurLine}
            /if (${MobsToPull.Find[ALL for all]} || ${MobsToPull.Equal[ALL]}) /goto :SkipPullValidate
            /for j 1 to 25
                /if (${DebugPull}) /echo \atDEBUGPULL ValidateTarget ${j} ${MobsToPull.Arg[${j},,]} ${MobName.Find[${MobsToPull.Arg[${j},,]}]} \agLine#: ${Macro.CurLine}
                /if (${MobName.Find[${MobsToPull.Arg[${j},,]}]}) {
                    /varset PullValid 1
                    /goto :SkipPullValidate
                }
            /next j
            /if (!${PullValid}) {
	    	/if (${MobsToPullSecondary.NotEqual[NULL]}) {
			/echo ok so we dont have anything to pull, but the user specified some
			|mobs to pull if everything else is down...
			/for j 1 to 25
                		/if (${DebugPull}) /echo \atDEBUGPULL ValidateTarget ${j} ${MobsToPullSecondary.Arg[${j},,]} ${MobName.Find[${MobsToPullSecondary.Arg[${j},,]}]} \agLine#: ${Macro.CurLine}
                		/if (${MobName.Find[${MobsToPullSecondary.Arg[${j},,]}]}) {
                		    /varset PullValid 1
					/echo pulling secondary mob: ${MobName.Find[${MobsToPullSecondary.Arg[${j},,]}]}
                		    /goto :SkipPullValidate
                		}
            		/next j
		} else {
			/echo ${MobsToPullSecondary} not found
		}
	    }
	    /if (!${PullValid}) /return PullMobNotonList
            :SkipPullValidate
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Validate 4 \agLine#: ${Macro.CurLine}
        /if (${MobName.Find[eye of]} && ${SpawnCount[pc ${MobName.Right[${Math.Calc[${MobName.Length}-7]}]}]}) /return Spell-Eye-PC        
        /if (${MobType.Equal[Pet]} && ${Spawn[${MobID}].Master.Type.Equal[PC]}) /return PET-PC
        /if (!${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) /return PC
        | This prevents characters on the Zek server from attacking PC targets in their group
        /if (${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) {
            /for i 0 to 5
                /if (${MobID}==${Group.Member[${i}].ID}) /return GroupMember
            /next i
            /if (${MobID}==${Spawn[=${MainAssist}].ID}) /return MA
        }
        /varset ValidTarget 1
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT ValidateTarget Leave \agLine#: ${Macro.CurLine}
    /return ${ValidTarget}

Sub RangerStuff
	/if (${Target.ID}==${MyTargetID} && !${Bool[${Target.Mezzed.ID}]}) {
		/if (!${Me.AutoFire}) {
			/echo turning on autofire
			/if (${Target.Distance3D} < 30) {
				/echo need to move back a little
				/stick 40 moveback
				/delay 2s
				/stick off
			}
			/autofire on
		}
	}
/return

| -------------------------------------------------------------------------------------
| SUB: Combat
| -------------------------------------------------------------------------------------
    Sub Combat
        /doevents
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius} && ${Pulling}) /return
        /if (!${MyTargetID}) /return
        /if (!${Target.ID}) /return
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        /if (!${Target.LineOfSight}) /return
        /if (${DPSPaused} ) /return
        /if (${Me.XTarget}==0) /return
        /if (${Me.Song[Rallying Call].ID} && !${Select[${Role},tank,pullertank]}) /return
        | Check if mob mezzed
        /if (${Group.MainAssist.ID} && ${Group.MainAssist.ID}!=${Me.ID} && ${Target.Mezzed.ID}) {
            /if (${Target.Mezzed.ID}) /echo Mob is mezzed ->> ${Target.CleanName} <<- I am not going to wake it since I am on assist.
            /delay 10
            /return
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat Enter \agLine#: ${Macro.CurLine}
        /if (${HealsOn}) /call CheckHealth
        /if (${ChaseAssist}) /call DoWeMove Combat
        /declare CombatRadius int local ${MeleeDistance}
        /declare SpamTankWait int local 1
        /declare ZDist float local 0
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) /call DoMezStuff
        }
        | Check Target Hps and type NPC or NPC Pet
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat ${Spawn[${MyTargetID}].Name} PctHPs = ${Spawn[${MyTargetID}].PctHPs} AssistAt=${AssistAt} Distance = ${Spawn[${MyTargetID}].Distance} CombatRadius = ${CombatRadius} \agLine#: ${Macro.CurLine}
        | PullerPetTank and PetTank send in pet if mob in range
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Spawn[${MyTargetID}].Distance}<${PetAttackRange}) /call CombatPet
        /if (${AggroOn} && ${MainAssist.NotEqual[${Me}]} && ${Select[${Role},Tank]} && ${Spawn[${MyTargetID}].Distance}>${CombatRadius}) /call AggroCheck
        /if (${Spawn[${MyTargetID}].PctHPs}<=${AssistAt} && (${Spawn[${MyTargetID}].Distance}<${CombatRadius} || ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius})) {
            /if (!${CombatStart}) {
                /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat Setting CombatStart to 1  \agLine#: ${Macro.CurLine}
                /if (${Cursor.ID}) /call CheckCursor
                /varset MercAssisting 0
                /varset CombatStart 1
                /echo  ATTACKING -> ${Spawn[${MyTargetID}].CleanName} <-
                /if (${IAmABard}) /call DoBardStuff
                /if (${Select[${Role},Tank,PullerTank,Hunter]}) /call BroadCast ${IRCOn} ${EQBCOn} y "TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
                /if (${Select[${Role},petTank,pullerpettank,hunterpettank]}) /call BroadCast ${IRCOn} ${EQBCOn} y "${Me.Pet.CleanName} is TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
                | Moloing as as puller turn off puller tag in group so tank merc attacks and doesn't wait for me to get 2 feet near them.
                /if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<${CampRadius}) /call AssignGroupRole unset "${Me.CleanName}" 3
            }
            /if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID})) {
		/face nolook
	    }
            /if (${Select[${Role},pettank,pullerpettank]} && !${Attacking}) { 
                /pet attack
                /pet swarm
                /varset Attacking 1
            }    
            /if (${MeleeOn} && !${Attacking}) {
                /varset Attacking 1
                /if (${Me.Sitting}) {
			/echo going to stand 1
			/stand
		}
                /if (!${AutoFireOn}) {
                    /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat Attack On \agLine#: ${Macro.CurLine}
                    | Speed up tanks attacking inc mobs MQ2Melee /killthis can cause a delay
                    /if (${Select[${Role},tank,pullertank,hunter]}) {
                        /if (${Me.Ability[Taunt]} && ${Me.AbilityReady[Taunt]})  /doability Taunt
                        /if (!${Me.Combat}) /attack on
                        /if (${Me.FeetWet}) {
                            /stick uw ${StickHow} 8 id ${MyTargetID}
                        } else {
                            /stick ${StickHow} 8 id ${MyTargetID}
                        }
                    }
                    | Use zerker kick in the teeth line before melee
                    /if (${Defined[BeforeCombat]}) {
				/if (!${BeforeCombat.Find[disc]} && ${Me.CombatAbilityReady[${Spell[${BeforeCombat}].RankName}]}) {
                        		/call CastWhat "${BeforeCombat}" ${MyTargetID} Combat
                        		/delay 2
                        		/if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo ** ${BeforeCombat} on >> ${Spawn[${MyTargetID}].CleanName}
				}
                    }
                    /if (!${UseMQ2Melee} && ${MeleeOn}) {
                        /if (${Spawn[${MyTargetID}].Distance}>13) {
				/echo moveto 1
				/moveto id ${MyTargetID}
			}
                        /if (${Me.FeetWet}) {
                            /stick 8 uw ${StickHow} id ${MyTargetID}
                        } else {
                            /stick 8 ${StickHow} id ${MyTargetID}
                        }
                        /attack on
                    } else /killthis
                    /if (${StickHow.NotEqual[0]}) {
                        /if (${Me.FeetWet}) {
                            /stick uw ${StickHow} 8 id ${MyTargetID}
                        } else {
                            /stick ${StickHow} 8 id ${MyTargetID}
                        }
                    }
                    | Move closer if Z distance more than 4 due to levitation
                    /call ZAxisCheck ${ZDist} 4.1
                }
            }
            /varset  MyExp ${Me.PctExp}
            /varset  MyAAExp ${Me.PctAAExp}
            | Turn on check for mez mob in camp that has been mem blurred if i am a tank type
            /if (${Select[${Role},tank,pullertank,pettank,pullerpettank]}) /varset MezMobFlag 1
            :Attack
		/if (${CombatStart} && ${AutoFireOn}) {
                    /if (${Target.ID}==${MyTargetID} && !${Bool[${Target.Mezzed.ID}]}) /call RangerStuff
                }
				/if (${Select[${Me.Class.ShortName},ROG]}) {
					/call AssassinAttack
				}
                /doevents
                |/if (${DPSMeter}) /doevents YouHit
                /if (${MercOn} && !${MercAssisting} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
                /if (!${UseMQ2Melee} && ${Spawn[${MyTargetID}].Distance}>13 && ${MeleeOn}) {
			/echo moveto 2
			/moveto id ${MyTargetID}
		}
                /if (${MezOn}) {
                    /varset MezBroke 0
                    /doevents MezBroke
                    /if (!${MezBroke}) /call DoMezStuff
                }
                /if (${AEOn}) /call AECheck
                /if (${AggroOn}) /call AggroCheck
                /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && ${PetOn} && ${PetCombatOn}) /call CombatPet
                /if (${HealsOn}) /call CheckHealth
                /if (${CuresOn}) /call CheckCures
                /if (${AutoRezOn}) /call RezCheck
                /if (!${NamedCheck} && ${BurnAllNamed}) /call NamedWatch
                /if (${DebuffAllOn} && (!${Role.Equal[puller]} || !${ChainPull})) {
                   | Debuff stuff
                   /call DoDebuffStuff ${MyTargetID}
                   |When returning the mob you were started on could be dead, so don't keep trying to kill a corpse.
                   /if (${Me.XTarget}==0 || ${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                       /call CombatReset
                       /return
                   }
                }
                /if (${DPSOn} && (!${Role.Equal[puller]} || !${ChainPull})) /call CombatCast
                /call CastMana
                /call WriteDebuffs
                /if (${IAmABard}) /call DoBardStuff
                /if (${DPSOn} || ${MeleeOn} || ${PetOn}) {
			/if (${Me.Class.ShortName.Equal[CLR]}) {
				/if (!${HealsOn}) {
					/echo calling CombatTargetCheck from Combat
					/call CombatTargetCheck
				}
			} else {
				|/echo calling CombatTargetCheck from Combat
				/call CombatTargetCheck
			}
		}
                /if (${Attacking} && ${MeleeOn} && ${Target.PctHPs}<=${Math.Calc[${AssistAt}-5]} && ${Target.Distance}<${CombatRadius} && !${AutoFireOn}) {
                    /if (!${Me.Combat}) {
                        /if (${Me.Sitting}) {
				/echo going to stand 2
				/stand
			}
                        /if (!${UseMQ2Melee}) {
                            /if (${Me.FeetWet}) {
                                /stick 8 uw ${StickHow} id ${MyTargetID}
                            } else {
                                /stick 8 ${StickHow} id ${MyTargetID}
                            }
                            /attack on
                        } else {
                            /killthis
                        }
                    } 
                    /if (${StickHow.NotEqual[0]} && !${Stick.Active} && ${Target.Distance}>10) {
                        /if (${Me.FeetWet}) {
                            /stick 8 uw ${StickHow} id ${MyTargetID}
                        } else {
                            /stick 8 ${StickHow} id ${MyTargetID}
                        }
                    }
                } else /if (${Attacking} && ${MainAssist.Equal[${Me}]} && !${Me.Combat} && ${MeleeOn}) {
                    /if (${DebugCombat}) { 
                        /beep
                        /echo \atDEBUGCOMBAT im in the :Attack loop but attack is not on Attacking=${Attacking} MeleeOn=${MeleeOn} Target.PctHPs=${Target.PctHPs} Math.Calc[AssistAt-5]=${Math.Calc[${AssistAt}-5]} Target.Distance=${Target.Distance} CombatRadius=${CombatRadius} AutoFireOn=${AutoFireOn} \agLine#: ${Macro.CurLine}
                    }
                    /attack on
                }
                /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${Me.XTarget}==0) {
                    /call CombatReset
                    /return
                }
                /if (${Role.Equal[puller]} && ${ChainPull}) {
                   /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=75) {
                        /if (!${ChainPullHold} && ${MobCount}<2 && !${Me.XTarget[${XTSlot2}].ID} && ${If[${Target.Named},0,1]}==1) {
                            /if (${Target.ID} && ${Target.PctHPs} < ${ChainPullHP}) {
                                /call FindMobToPull 0
                                /if (${Macro.Return}>0 && ${Spawn[${ChainPullTemp}].Distance}<${Math.Calc[${PullRange}+400]} && ${Me.TargetOfTarget.Name.NotEqual[${Me.CleanName}]} && ${Me.PctAggro}<50) {
                                    /if (${UseMQ2Melee}) /squelch /melee melee=0
                                    /delay 10
                                    /if (${Stick.Active}) /squelch /stick off 
                                    /squelch /attack off
                                    /delay 10
                                    /if (${UseMQ2Melee}) /squelch /melee melee=1
                                    /varset ChainPull 2
                                    /varset MyTargetID 0
                                    /varset Attacking 0
                                    /return
                                }
                            }
                        }
                    } else /if (${SpamTankWait}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} r "Holding Pulls. Tank to far from camp."
                        /varset SpamTankWait 0 
                    }
                }   
                /if (${Role.Equal[puller]} && ${ChainPull} && ${DebuffAllOn}) /call DebuffCast ${MyTargetID} 1 
                /if (${Role.Equal[puller]} && ${ChainPull} && ${DPSOn}) /call CombatCast     
                /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]} || ${Spawn[${MyTargetID}].ID}) /goto :Attack
                /if (${Bool[${Plugin[MQ2Melee]}]}) {
						/if (${Melee.Status.NotEqual[FEIGNING]}) /goto :Attack
				}
        } else /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && (${Spawn[${MyTargetID}].Distance}<${CombatRadius} || ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius})) {
            /if (${PetOn} && ${PetCombatOn}) /call CombatPet
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Combat Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CombatTargetCheck
| -------------------------------------------------------------------------------------
    Sub CombatTargetCheck
        | If mob is dead return
        /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) /return 
        | Check target matches MA if group mainassist assigned and MA is in group
        /if (${Spawn[=${MainAssist}].ID} && ${Group.MainAssist.ID} && ${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID}) {
            /if (${Target.ID}!=${Me.GroupAssistTarget.ID} && ${Group.MainAssist.ID}!=${Me.ID}) {
                /if (${MyTargetID}!=${Me.GroupAssistTarget.ID} && ${Spawn[id ${Me.GroupAssistTarget.ID} npc].ID}) {
                    /echo My target does not match MA's. Switching to new target.
                    /varset MyTargetID ${Me.GroupAssistTarget.ID}
                    /varset MyTargetName ${Spawn[id ${Me.GroupAssistTarget.ID}].CleanName}
                }
            }
        }
        /if (${Target.ID}!=${MyTargetID} && ${Spawn[${MyTargetID}].ID}) {
	    /echo Targeting a mob 7: ${Spawn[${MyTargetID}]}
            /squelch /target id ${MyTargetID}
            /delay 10 ${Target.ID}==${MyTargetID}
        }
	/call SmartMerc
    /return
Sub DoBandolier
	/declare tempbandid  int      local
	/declare bandi           int      local 0
	/for bandi 1 to ${Bandolier.Size}
		/if (${BandolierCond[${bandi}].NotEqual[NULL]}) {
			/if (${If[${BandolierCond[${bandi}]},1,0]}) {
				|/echo The BandolierCond${bandi} (${BandolierCond[${bandi}]}==TRUE) for ${Bandolier[${bandi}]} returned TRUE so we move on!
				/varset tempbandid ${Me.Inventory[13].ID}
				/echo player want us to activate bandolier: ${Bandolier[${bandi}]}
	    			/bandolier activate ${Bandolier[${bandi}]}
	    			/delay 2s ${Me.Inventory[13].ID}!=${tempbandid}
				/return
	    		}
	    	}
	/next bandi
/return
| -------------------------------------------------------------------------------------
| SUB: Combat Cast
| -------------------------------------------------------------------------------------
    Sub CombatCast
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast Enter \agLine#: ${Macro.CurLine}
        /declare i           int      local 0
        /declare DPSStart    int      local ${Math.Calc[${DebuffCount}+1]}
        |/declare DPSText     string   local
        /declare DPSAt       int      local ${AssistAt}
        /declare DPSTargetID int      local ${MyTargetID}
        /declare DPSItem     string   local
        /declare DPSPart1    string   local 
        /declare DPSPart2    string   local 
        /declare DPSPart3    string   local 
        /declare DPSPart4    string   local 
        /declare DPSPart5    string   local
        /declare WeaveCheck  int      local 0
        /call WriteDebuffs
        /for i ${DPSStart} to ${DPS.Size}
			|/echo I'm checking DPS: ${i}
			/if (${BandolierOn}) {
				/call DoBandolier
			}
			/if (${OhShitOn}) {
				/call OhShitStuff
			}
            /doevents
	    |/echo The target we should nuke is ${Spawn[${MyTargetID}]}
	    |these classes are usually set as healers and we dont want them to switch between group and mobs constantly, they do that anyway if needed in combat cast for the dps section
	    /if (${Select[${Me.Class.ShortName},CLR,DRU,SHM]}) {
		/if (!${HealsOn}) {
            		/call CombatTargetCheck
		}
	    } else {
            	/call CombatTargetCheck
	    }
            /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                /if (${DebugCombat}) /echo CombatCast: Return from CombatCast cause my target is a corpse or dead or DPSPaused is ${DPSPaused}. \agLine#: ${Macro.CurLine}
                /return
            }
            /if (${DPSPaused}) {
                /if (${DebugCombat}) /echo CombatCast: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
                /return
            }
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast ${Spell[${DPS[${i}].Arg[1,|]}].RankName} ${DPS[${i}].Arg[1,|]} !${Me.SpellReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AltAbilityReady[${DPS[${i}].Arg[1,|]}]} && !${Me.CombatAbilityReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AbilityReady[${DPS[${i}].Arg[1,|]}]} \agLine#: ${Macro.CurLine}
            /if (!${Cast.Ready[${DPS[${i}].Arg[1,|]}]} && !${Me.SpellReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AltAbilityReady[${DPS[${i}].Arg[1,|]}]} && !${Me.CombatAbilityReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AbilityReady[${DPS[${i}].Arg[1,|]}]})  /goto :skipcast
            |--- only call code for GroupEscape kick off.
            /if (${GroupEscapeOn}) {
		/if (${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) {
			/call GroupEscape
		}
	    }
            /if (${MezOn}) {
                /varset MezBroke 0
                /doevents MezBroke
                /if (!${MezBroke}) /call DoMezStuff
            }
            /if (${HealsOn}) /call CheckHealth
            /if (${CuresOn}) /call CheckCures
            /if (${Cursor.ID}) /call CheckCursor
            /if (${Int[${DPS[${i}].Arg[2,|]}]} > 0 && ${DPS[${i}].Arg[3,|].NotEqual[null]}) {
                /varset DPSPart1 ${DPS[${i}].Arg[1,|]}
                /varset DPSPart2 ${DPS[${i}].Arg[2,|]}
                /if (${Select[${DPS[${i}].Arg[3,|]},if,ifme,notif,notifme]}>0) {
                   /if (${DPS[${i}].Arg[5,|].NotEqual[null]}) /varset DPSPart3 ${DPS[${i}].Arg[5,|]}
                   /varset DPSPart4 ${DPS[${i}].Arg[3,|]}
                   /varset DPSPart5 ${DPS[${i}].Arg[4,|]}
                } else {
                   /varset DPSPart3 ${DPS[${i}].Arg[3,|]}
                   /varset DPSPart4 ${DPS[${i}].Arg[4,|]}
                   /varset DPSPart5 ${DPS[${i}].Arg[5,|]}
                }
            } else {
                /varset DPSPart1 ${DPS[${i}].Arg[1,|]}
                /varset DPSPart2 ${DPS[${i}].Arg[2,|]}
                /varset DPSPart3
                /varset DPSPart4
                /varset DPSPart5
            }
            /if (${ConditionsOn}) {
				/if (${DPSCOn}) {
					| This is like checking If twice... so why?
					|/echo Why the embedded If?
					/if (${If[${DPSCond[${i}]},0,1]}) {
						|/if (${i}==1) {
						|	/echo The DPSCond${i} (${DPSCond[${i}]}==FALSE) for ${DPS[${i}]} returned FALSE so we skip it.
						|}
						/goto :skipcast
					} else {
						|/echo The DPSCond${i} (${DPSCond[${i}]}==TRUE) for ${DPS[${i}]} returned TRUE so we move on!
					}
				}
			}
            /if (${Select[${DPSPart3},Me,MA]}==0 && (${Me.CombatAbility[${DPSPart1}]} || ${Me.Ability[${DPSPart1}]})) {
		/echo [${Time}] CASTING 1 ${DPSPart1}
		/call CastWhat "${DPSPart1}" ${DPSTargetID} DPS
		/goto :MeleeCast
            }
            /if (${Target.Mezzed.ID} && ${MainAssist.NotEqual[${Me}]} && ${Spell[${DPSPart1}].Category.NotEqual[Utility Detrimental]}) {
                /if (${DebugCombat}) {
			/echo Skipping spell in CombatCast because target is mezzed and I'm not mainassist and it will wake up the mob. \agLine#: ${Macro.CurLine}
                }
		/goto :skipcast
            }
	    /if (${Me.XTarget}==0 && ${Spawn[${MyTargetID}].PctHPs}==100) {
		|/echo screw this, we have noone on xtarget, so that means we should not be casting shit, its a non aggro mob...
		/return
	    }
	    |well we got this far but is the mob within sight?
	    /if (${MoveCloserIfNoLOS}) {
		/if (${Bool[${Plugin[MQ2Nav]}]}) {
			/if (${Role.Equal[Assist]} && !${Target.LineOfSight} && ${Target.Distance3D} < 50 && ${Navigation.MeshLoaded}) {
				|/beep
				/echo I am assisting but I cant see the mob lets move closer
	            		/nav id ${Target.ID}
				/delay 5s ${Navigation.Active}
			}
	    	}
	    }
            /if (!${DPS[${i}].Length}) {
                /if (${DebugCombat}) CombatCast: /echo im skipping in CombatCast cause there is no spell: DPS${i}  \agLine#: ${Macro.CurLine}
                /goto :skipcast    
            }
            /if (${Spell[${DPSPart1}].Subcategory.Equal[Mana Drain]} && ${MyTargetID} && !${Spawn[${MyTargetID}].Class.CanCast}) {
                    /if (${DebugCombat}) {
			/echo CombatCast: I'm skipping ${Spell[${DPSPart1}]} on ${Spawn[${MyTargetID}]} in CombatCast cause we shouldnt try to mana drain non caster mobs \agLine#: ${Macro.CurLine}
                    }
		    /goto :skipcast            
            }
            /if (${MercOn} && !${MercAssisting} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
            /if (${AEOn}) /call AECheck
            /if (${AggroOn}) /call AggroCheck
	    /if (${PetOn}) {
            	/if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && ${PetCombatOn}) /call CombatPet
	    }
            /if (${DebugCombat}) {
		/echo \atDEBUGCOMBAT CombatCast ${DPS[${i}]} ${DPSPart1} ${DPSPart2} ${DPSPart3} ${DPSPart4} ${DPSPart5} \agLine#: ${Macro.CurLine}
            }
	    | - Check for 2nd value in dps for mob health
            /if (${DPSPart2.Length} && ${Int[${DPSPart2}]}>0) {
                /if (${DebugCombat}) {
			/echo \atDEBUGCOMBAT CombatCast ${DPSPart1} \agLine#: ${Macro.CurLine}
		}
                /varset DPSAt ${DPSPart2}
                /if (${DebugCombat}) {
			/echo \atDEBUGCOMBAT CombatCast ${DPSAt} \agLine#: ${Macro.CurLine}
		}
                /if (${DPSPart3.Equal[MA]}) /varset DPSTargetID ${Spawn[=${MainAssist}].ID}
                /if (${DPSPart3.Equal[Me]} || ${DPSPart3.Equal[Feign]}) /varset DPSTargetID ${Me.ID}
                | Check if self combat buff is active
                /if (${DPSPart3.Equal[Me]}) {
                    /if (${DPSPart4.Length} && ${DPSPart4.NotEqual[null]}) {
                        /if (${Select[${DPSPart4},if,ifme]}>0 && !${Me.Buff[${DPSPart5}].ID} && !${Me.Song[${DPSPart5}].ID}) {
				/echo Skipping cast cause of if clause
				/goto :skipcast
			}
                        /if (${Select[${DPSPart4},notif,notifme]}>0 && (${Me.Buff[${DPSPart5}].ID} || ${Me.Song[${DPSPart5}].ID})) {
				/echo Skipping cast cause of notif clause
				/goto :skipcast
			}
                    } else /if (${Me.Buff[${DPSPart1}].ID} || ${Me.Song[${DPSPart1}].ID}) {
			/echo Skipping cast cause of Me clause
                        /goto :skipcast
                    }
                }
            }
            /if (${Me.Class.Name.Equal[Cleric]} && ${DPSPart1.Find[Hammer]} && ${Me.Pet.ID}) {
		/echo Skipping cast cause of Hammer
		/goto :skipcast
	    }
            /if (${Me.Class.Name.Equal[Wizard]} && ${Me.Pet.ID} && (${DPSPart1.Find[sword]} || ${DPSPart1.Find[blade]})) {
		/echo Skipping cast cause of Wiz sword or blade
		/goto :skipcast
	    }
            /if (${Spawn[${DPSTargetID}].PctHPs} < ${DPSSkip}) {
		/echo Skipping cast cause of DPSSkip ${Spawn[${DPSTargetID}].PctHPs} < ${DPSSkip}
		/goto :skipcast
	    }
            /if (${DPSPart1.Equal[NULL]}) {
		/echo im skipping cause DPSPart1 is NULL
		/goto :skipcast
	    }
            /if (${ABTimer${i}}) {
		/echo im skipping cause ABTimer${i} ${ABTimer${i}}
		/goto :skipcast
	    }
            /if (${DPSTimer${i}}) {
		/echo im skipping cause DPSTimer${i} ${DPSTimer${i}}
		/goto :skipcast
	    }
            /if (${FDTimer${i}}) {
		/echo im skipping cause FDTimer${i} ${FDTimer${i}}
		/goto :skipcast
	    }
            /if (!${Select[${EverQuest.Server},zek]} && ${Spawn[${DPSTargetID}].Type.NotEqual[NPC]} && ${Spawn[${DPSTargetID}].Master.Type.NotEqual[NPC]}) {
		/echo im skipping cause of weird reason
		/goto :skipcast
	    }
            /if (${Spawn[${DPSTargetID}].PctHPs} > ${DPSAt} && ${DPSOn}==1) {
		/echo im skipping cause of DPSAt ${Spawn[${DPSTargetID}]} hp is > ${DPSAt}
		/goto :skipcast
	    }
            /if (${DebugCombat}) {
		/echo \atDEBUGCOMBAT CombatCast Spell: ${DPSPart1} Target: ${DPSTargetID}=${Target.ID} Timer: ${DPSTimer${i}} DPSOn: ${DPSOn} \agLine#: ${Macro.CurLine}
	    }
            /if (${Select[${DPSPart3},Me,MA]} && ${Me.Combat} && ${MainAssist.NotEqual[${Me}]}) {
                /attack off
                /delay 10 !${Me.Combat}
            }
            /if (${DPSPart4.Length} && ${DPSPart4.NotEqual[null]}) {
                /if (${Select[${DPSPart4},if,notif]}>0) {
                    /if (${DPSTargetID}!=${Target.ID}) {
			/echo Targeting a mob 8: ${Spawn[${DPSTargetID}]}
                        /target id ${DPSTargetID}
                        /delay 2s ${Target.ID}==${DPSTargetID} && ${Target.BuffsPopulated}==TRUE
                    }
                    /if (${DPSPart4.Equal[if]} && !${Target.Buff[${DPSPart5}].ID}) {
			/echo im skipping cause of if DPSPart5
			/goto :skipcast
		    }
                    /if (${DPSPart4.Equal[notif]} && ${Target.Buff[${DPSPart5}].ID}) {
			/echo im skipping cause of notif DPSPart5
			/goto :skipcast
		    }
                } else /if (${Select[${DPSPart4},ifme,notifme]}>0) {
                    /if (${DPSPart4.Equal[ifme]} && !${Me.Buff[${DPSPart5}].ID} && !${Me.Song[${DPSPart5}].ID}) {
			/echo im skipping cause of ifme DPSPart5
			/goto :skipcast
		    }
                    /if (${DPSPart4.Equal[notifme]} && (${Me.Buff[${DPSPart5}].ID} || ${Me.Song[${DPSPart5}].ID})) {
			/echo im skipping cause of notifme DPSPart5
			/goto :skipcast
		    }
                } else {
                    /echo What The! I wasn't aware there was a ${DPSPart4} paramater. You may want to check your settings.
                }
            }
            | Only cast spells with weave tag during global cooldown
            /if (${WeaveArray.Size}>=1 && ${Me.SpellInCooldown}) {
                /call WeaveStuff ${DPSTargetID}
                /varset WeaveCheck 1
		/echo Skipping after Weave for ${DPSPart1}
                /goto :skipcast
            } else {
		/echo CASTING -> ${DPSPart1} <-
                /call CastWhat "${DPSPart1}" ${DPSTargetID} DPS
            }    
            /if (${DebugCombat}) {
		/echo DEBUGCOMBAT CombatCast MacroReturn: ${Macro.Return} \agLine#: ${Macro.CurLine}
            }
	    :MeleeCast
            /if (${Macro.Return.Equal[CAST_RESIST]}) {
                /echo [${Time}] ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} << - RESISTED
                /if (${DPSPart3.Length} && ${DPSPart3.Equal[once]}) {
                    /varset DPSTimer${i} 5m
                    /goto :skipcast
                }
            }
            /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
                /echo [${Time}] ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} << - DID NOT TAKE HOLD
                /varset DPSTimer${i} 5m
                /goto :skipcast
            }
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo [${Time}] ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} <<
                | Set timer for spells labeled once 5m
                /if (${DPSPart3.Length} && ${DPSPart3.Equal[once]}) {
                    /varset DPSTimer${i} 5m
                    /goto :skipcast
                | Timers for items    
                } else /if (${FindItemCount[=${DPSPart1}]}) {
                    /varcalc DPSTimer${i} ${FindItem[=${DPSPart1}].Spell.Duration.TotalSeconds}*10
                    /goto :skipcast
                | FD to lose aggro
                } else /if (${Select[${Me.Class.ShortName},BST,MNK,NEC,SHD]} && ${DPSPart3.Equal[Feign]}) {
                    /delay 30 ${Me.State.Equal[FEIGN]}
                    /varset FDTimer${i} 60s
                    /delay 10s ${Me.State.NotEqual[FEIGN]}
                    /if (${Me.State.Equal[FEIGN]} && !${Me.Sitting}) {
			/echo standing after feign
			/stand
		    }
                | Timers for spells
                } else /if (${Me.Book[${DPSPart1}]}) {
                    | - Attack Buff Timers are seperate. DPS timers are cleared after every fight.
                    /if (${Select[${DPSTargetID},${Me.ID},${Spawn[=${MainAssist}].ID}]}) {
                        /varcalc ABTimer${i} (${Spell[${DPSPart1}].Duration.TotalSeconds}*${DurationMod})*10
                        /if (${DebugCombat}) /echo DEBUGCOMBAT CombatCast Spell: ${DPSPart1} Timer: ABTimer${i} ${ABTimer${i}} Line#: ${Macro.CurLine}
                        /goto :skipcast
                    | - Custom timer for counterbias
                    } else /if (${Me.Class.Name.Equal[Shaman]} && ${DPSPart1.Find[counterbias]}) {
                        /varset DPSTimer${i} 1.5m
                        /goto :skipcast
                    | Custom timer for Chanter suffocation
                    } else /if (${Me.Class.Name.Equal[enchanter]} && ${DPSPart1.Find[suffocation]}) {
                        /varset DPSTimer${i} 1m
                        /goto :skipcast
                    | Custom timer for Beastlord Feralgia Timer
                    } else /if (${Me.Class.Name.Equal[Beastlord]} && ${DPSPart1.Find[feralgia]}) {
                        /varset DPSTimer${i} 1.5m
                        /goto :skipcast
                    | Regular spells
                    } else /if (${Spell[${DPSPart1}].Duration.TotalSeconds}>0) {
                        /varcalc DPSTimer${i} ${Spell[${DPSPart1}].Duration.TotalSeconds}*10
                        /goto :skipcast
                    | Spells with no timers assign DPS interval
                    } else {
                        /varset DPSTimer${i} ${DPSInterval}s
                        /goto :skipcast
                    }
                | AA and disc timers
                } else /if (${Spell[${DPSPart1}].Duration}>0 && (${Me.AltAbility[${DPSPart1}]} || ${Me.CombatAbility[${DPSPart1}]})) {
                    /varcalc DPSTimer${i} ${Spell[${DPSPart1}].Duration.TotalSeconds}*10
                    /goto :skipcast
                | AA and disc with no timers assign DPS interval
                } else {
                    /varset DPSTimer${i} ${DPSInterval}s
                    /goto :skipcast
                }
            }
            :skipcast
            /if (${DebugCombat}) {
				/echo \atDEBUGCOMBAT CombatCast ${DPSPart1} ${Macro.Return} DPSTimer${i} ${DPSTimer${i}} \agLine#: ${Macro.CurLine}
            }
	    /if (${Select[${DPSPart3},Me,MA]}) {
		/echo calling CombatTargetCheck from CombatCast 2
		/call CombatTargetCheck
	    }
            | Reset values if 2nd value in dps for mob health exists
            /if (${DPSPart2.Length} && ${DPSPart2.NotEqual[null]}) {
                /varset DPSAt ${AssistAt}
                /varset DPSTargetID ${MyTargetID}
            }
            /if (${WeaveArray.Size}>=1 && ${Me.SpellInCooldown} && !${WeaveCheck}) {
                /call WeaveStuff ${DPSTargetID}
            }
            /if (${MashArray.Size}>=1) /call MashButtons
            /varset WeaveCheck 0
        /next i
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatCast: Leave \agLine#: ${Macro.CurLine}
    /return 

| -------------------------------------------------------------------------------------
| SUB: OhShitStuff this will stop casting and do the most important stuff
| -------------------------------------------------------------------------------------    
	Sub OhShitStuff
		/if (${Me.Hovering}) /return
		/declare i int local
		/declare thehp int local
		/declare thespell string local
		/declare thetargetid string local
		/declare cond string local
		/declare MainAssistID    int     local
		/varset MainAssistID ${Spawn[=${MainAssist}].ID}

		/for i 1 to ${OhShit.Size}
			/if (${If[${OhShitCond[${i}]},1,0]}) {
				/echo Spawn[=${MainAssist}].ID = ${Spawn[=${MainAssist}].ID}
				/echo MainAssistID = ${MainAssistID}
				/echo OhShitTargetID = ${OhShitTargetID}
				/echo my HP = ${Me.PctHPs}
				/echo target HP = ${Target.PctHPs}
				|/beep
				/varset thespell ${OhShit[${i}].Arg[1,|]}
				/varset thetargetid ${OhShit[${i}].Arg[2,|]}
				/echo ohshit triggered for ${OhShit[${i}].Replace[$,#]} = ${OhShit[${i}]}
				/echo condition is: ${OhShitCond[${i}].Replace[$,#]} = ${OhShitCond[${i}]}
				/interrupt
				/call CastWhat "${thespell}" ${thetargetid} "OhShitStuff" 1
				/break
			}
		/next i
	/return

| -------------------------------------------------------------------------------------
| SUB: WeaveStuff
| -------------------------------------------------------------------------------------    
    Sub WeaveStuff(int TarID)
        /declare i int local
        /declare DPSat1 int Local 0
        /declare DPSWeaveSpell string local 
        /for i 1 to ${WeaveArray.Size}
            /varset DPSat1 ${Int[${WeaveArray[${i}].Arg[2,|]}]}
            /varset DPSWeaveSpell ${WeaveArray[${i}].Arg[1,|]}
            /if (${Debug}) /echo \at Cast DPSWeaveSpell:(${DPSWeaveSpell}) at (${DPSat1}%) \agLine#: ${Macro.CurLine}
            /if (${DPSat1}==0) /return
	    /if (${ConditionsOn} && ${DPSCOn}) {
		/if (${If[${WeaveCond[${i}]},1,0]}) {
			/echo WeaveCondition met for ${DPSWeaveSpell} Cond: ${WeaveCond[${i}].Replace[$,#]} so moving on
		} else {
			|/echo weavecondition NOT met for ${DPSWeaveSpell} Cond: ${WeaveCond[${i}].Replace[$,#]} so skipping
			/continue
		}
	    }
	    /if (${Me.AltAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.ItemReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.CombatAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} ||  ${Me.AbilityReady[${WeaveArray[${i}].Arg[1,|]}]}) {
		/if (${Spawn[${TarID}].PctHPs} <= ${DPSat1}) {
			/call CastWhat "${DPSWeaveSpell}" ${TarID}
			/if (${Macro.Return.Equal[CAST_SUCCESS]})  /echo -- Weaved: ${DPSWeaveSpell}
			/return 1
		}
	    } 
        /next i
    /return 0
| -------------------------------------------------------------------------------------
| SUB: Mash Buttons
| -------------------------------------------------------------------------------------    
    Sub MashButtons(TarID)
	/if (${BandolierOn}) {
		/call DoBandolier
	}
	/if (${OhShitOn}) {
		/call OhShitStuff
	}
        /declare i int local
        /declare MashThis string local
        /for i 1 to ${MashArray.Size}
            /varset MashThis ${MashArray[${i}].Arg[1,|]}
            /if (${MashThis.Length}==0 || ${MashThis.Equal[null]}) /return 
            /if (!${ConditionsOn} || !${DPSCOn} || ${If[${MashCond[${i}]},1,0]}) {
                /if (${FindItem[=${MashThis}].ID} && ${Me.ItemReady[${MashThis}]}) {
                    /useitem "${MashThis}"
                    /echo #1 Mashing >> ${MashThis} <<
                } else /if (${Me.AltAbility[${MashThis}]} && ${Me.AltAbilityReady[${MashThis}]} && ${Me.AltAbility[${MashThis}].Type}!=5 && ${MashThis.NotEqual[twincast]})  { 
                    /alt act ${Me.AltAbility[${MashThis}].ID}
                    /echo #2 Mashing >> ${MashThis} <<
                } else /if (${Me.CombatAbility[${MashThis}]}) {
			/if (!${Me.CombatAbilityTimer[${MashThis}]}) {
				/if (${Me.CombatAbilityReady[${MashThis}]}) {
					/if (${Spell[${MashThis}].EnduranceCost} < ${Me.Endurance}) {
						/if (${Spell[${MashThis}].TargetType.Equal[Single]}) {
							/if (${Target.Distance3D} < ${Spell[${MashThis}].Range}) {
                    						/disc ${Me.CombatAbility[${Me.CombatAbility[${MashThis}]}].ID}
                    						/echo #3 Mashing >> ${MashThis} <<
							} else {
								/echo I would mash >> ${MashThis} << but target is out of range (${Target.Distance3D}) so I can't.
								/stick ${Math.Calc[${Spell[${MashThis}].Range} - 10].Int} moveback
								/delay 2s
								/stick off
							}
						} else {
							/disc ${Me.CombatAbility[${Me.CombatAbility[${MashThis}]}].ID}
                    					/echo #4 Mashing Self >> ${MashThis} <<
						}
					}
				}
			}
                } else /if (${Me.Ability[${MashThis}]} && ${Me.AbilityReady[${MashThis}]}) {
                    /doability "${MashThis}"
                    /echo #5 Mashing >> ${MashThis} <<
                }
                /delay 2
            }
        /next i
    /return 0
| -------------------------------------------------------------------------------------
| SUB: CombatPet
| -------------------------------------------------------------------------------------
    Sub CombatPet
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatPet: Enter \agLine#: ${Macro.CurLine}
        /if (${PetAttack} || ${DPSPaused}) /return
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Me.Pet.ID} && !${Me.Pet.Combat}) /pet attack 
        /if (${Me.Pet.ID} && (${PetAttack} || ${Me.Pet.Combat})) /return
        /call CombatTargetCheck
        /if (!${Target.Mezzed.ID} && !${Me.Pet.Combat}) {
            /if (${Select[${Role},pettank,pullerpettank]}) {
                /if ((${Me.Pet.Stance.NotEqual[FOLLOW]}) && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) || (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius})) /pet follow            
            }
            /pet attack
            /pet swarm
            /delay 10
            | Set timer to check if pet is attacking every 3s 
            /varset PetAttack 30
        } else {
            /if (${Target.Mezzed.ID} && ${Select[${Role},pettank,pullerpettank]} && ${PetBreakMezSpell.NotEqual[null]}) /call BreakMez
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatPet: Leave \agLine#: ${Macro.CurLine}
            /return  
| -------------------------------------------------------------------------------------
| SUB: BreakMez - Writtten by Trehuggindruid for KissAssist
| -------------------------------------------------------------------------------------
    Sub BreakMez   
        /if (${PetBreakMezSpell.Equal[null]}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT BreakMez: Enter \agLine#: ${Macro.CurLine}
        /declare PetBreakMezTargetID int local ${MyTargetID}
        /echo ATTEMPTING TO BREAK MEZ ON: (${Target.CleanName}) ID:(${PetBreakMezTargetID})
        :TryMezBreak
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT Break Mez with: - ${PetBreakMezSpell} \agLine#: ${Macro.CurLine}
        /call CastWhat "${PetBreakMezSpell}" ${PetBreakMezTargetID} BreakMez        
        |--- DO NOT CHANGE THIS CONDITION!!!!!!
        /if (${Target.Mezzed.ID}) {
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT Mez NOT broken, trying again! \agLine#: ${Macro.CurLine}
            /goto :TryMezBreak
        } else {
            /varset PetAttack 0
            /echo + Mez broken !
            /if (${Me.Pet.ID} && !${Me.Pet.Combat}) /pet attack
        }
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT BreakMez: Leave \agLine#: ${Macro.CurLine}
    /return 
| -------------------------------------------------------------------------------------
| SUB: CombatReset
| -------------------------------------------------------------------------------------
    Sub CombatReset
	/varset MeleeHit 0
	/call SmartMerc
        /if (${DPSMeter}) /doevents YouHit
        /declare DPSCalcPct int local 0
        /declare DPSCalc string local
        /declare DPSTCalc string local
        /declare DPSMyDam string local
        /declare DPSPCalc string local
        /declare DPSPTCalc string local
        /declare DPSMyPetDam string local
        /declare DPSMeAndPetDam string local
        /declare DPSMPCalc string local
        /declare DPSMPTCalc string local
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatReset: Enter \agLine#: ${Macro.CurLine}
        /if (${MyTargetID} && ${CombatStart} && ${DPSMeter}) {
            /echo SLAIN >> ${MyTargetName} << 
            /echo EXP: ${If[${Me.PctExp}<${MyExp},${Math.Calc[100-${MyExp}+${Me.PctExp}]},${Math.Calc[${Me.PctExp}-${MyExp}]}]}% AAEXP: ${If[${Me.PctAAExp}<${MyAAExp},${Math.Calc[100-${MyAAExp}+${Me.PctAAExp}]},${Math.Calc[${Me.PctAAExp}-${MyAAExp}]}]}%
            /popup SLAIN >> ${MyTargetName} << EXP: ${If[${Me.PctExp}<${MyExp},${Math.Calc[100-${MyExp}+${Me.PctExp}]},${Math.Calc[${Me.PctExp}-${MyExp}]}]}% AAEXP: ${If[${Me.PctAAExp}<${MyAAExp},${Math.Calc[100-${MyAAExp}+${Me.PctAAExp}]},${Math.Calc[${Me.PctAAExp}-${MyAAExp}]}]}%
            /if (!${DPSLastTime}) {
                /echo DPS Meter: Was a timing error skipping DPS Meter
            } else {
                | My damage calculation
				/if (${Bool[${Plugin[MQ2DamageParser]}]}==TRUE) {
					/varset DPSTotal ${Damage.Individual[${MyTargetID}]}
					/if (${Pet.ID}) {
						/varset DPSPetTotal ${Damage.Individual[${MyTargetID},${Pet.ID}]}
					}
					/if (${Damage.Total[${MyTargetID}]} && ${DPSTotal}) {
						/varset DPSCalcPct ${Math.Calc[${DPSTotal} / ${Damage.Total[${MyTargetID}]} * 100]}
						/bct ${MainAssist} I did ${DPSCalcPct} percent of the damage.
					}
				}
                /varset DPSCalc ${Math.Calc[${DPSTotal}/${DPSLastTime}]}
                /call CommaMeBro ${DPSCalc}
                /if (${Macro.Return.Length}) /varset DPSMyDam ${Macro.Return}
                /call CommaMeBro ${DPSTotal}
                /if (${Macro.Return.Length}) /varset DPSTCalc ${Macro.Return}
                /call CommaMeBro ${Damage.Total[${MyTargetID}]}
                /if (${Macro.Return.Length}) /varset DPSMPCalc ${Macro.Return}
                /echo \aw DPS Meter (${MyTargetID}) - \ay You did: \at ${DPSTCalc} out of ${DPSMPCalc} Total Damage (${DPSCalcPct}%) - \ay Fight Time: \aw ${DPSLastTime}s - \ay DPS: \ag ${DPSMyDam}
                | My pet damage calculation
                /if (${DPSPetTotal}) {
                    /varset DPSPCalc ${Math.Calc[${DPSPetTotal}/${DPSLastTime}]}
                    /call CommaMeBro ${DPSPCalc}
                    /if (${Macro.Return.Length}) /varset DPSMyPetDam ${Macro.Return}
                    /call CommaMeBro ${DPSPetTotal}
                    /if (${Macro.Return.Length}) /varset DPSPTCalc ${Macro.Return}
                    /echo \aw DPS Meter - \ay Pet Total Damage: \at ${DPSPTCalc} \ay - Pet DPS: \ag ${DPSMyPetDam}
                    | Me + pet damage calculation
                    /varset DPSMPCalc ${Math.Calc[(${DPSTotal}+${DPSPetTotal})/${DPSLastTime}]}
                    /call CommaMeBro ${DPSMPCalc}
                    /if (${Macro.Return.Length}) /varset DPSMeAndPetDam ${Macro.Return}
                    /call CommaMeBro ${Math.Calc[${DPSTotal}+${DPSPetTotal}]}
                    /if (${Macro.Return.Length}) /varset DPSMPTCalc ${Macro.Return}
                    /echo \aw DPS Meter - \ay You + Pet Total Damage: \at ${DPSMPTCalc} \ay - DPS: \ag ${DPSMeAndPetDam}
                }
                /popup Total Damage: ${DPSTCalc} - Fight Time: ${DPSLastTime}s - DPS: ${DPSMyDam}
                /if (${Defined[ParseDPS]} || ${DPSWriteOn}) {
                    /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-${Me.Class}-${Me.Level}" "Total Damage: ${DPSTCalc} - Fight Time: ${DPSLastTime}s - DPS: ${DPSMyDam}"
                    /if (${DPSPetTotal}) {
                        /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-MyPet" "My Pet Total Damage: ${DPSPTCalc} - Pet DPS: ${DPSMyPetDam}"
                        /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-Combined" "Me + Pet Total Damage: ${DPSMPTCalc} - Combined DPS: ${DPSMeAndPetDam}"
                    }
                }
            }
        }
        /declare i int local
        /declare j int local
        /call MobRadar ${MeleeDistance} CombatReset
        /for j 1 to 50
            /if (${AddsArray[${j},1].Equal[${MyTargetID}]}) /call RemoveFromArray AddsArray ${j}
            /if (${MobCount}==0) /call RemoveFromArray AddsArray ${j}
            /if (${MezOn} && ${j}<=13) {
                /if (${MezArray[${j},1].Equal[${MyTargetID}]}) /call RemoveFromArray MezArray ${j}
                |/if (${MezCount[${j}]}==0) /call RemoveFromArray MezArray ${j}
            }
        /next j
        /if (${MezOn}) {
            /if (${MezImmuneIDs.Find[|${MyTargetID}]}) /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MyTargetID},]}
            /varset j 1
            /while (${Bool[${MezImmuneIDs.Arg[${j},|].Length}]}) {
                /if (!${Bool[${Spawn[${MezImmuneIDs.Arg[${j},|]}].ID}]} || ${Spawn[${MezImmuneIDs.Arg[${j},|]}].Type.Equal[corpse]} ) {
                    /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MezImmuneIDs.Arg[${j},|]},]}
                } else {
                    /varcalc j ${j}+1
                }
            }
        }
        /varset AggroTargetID2 0
        /varset MyTargetID 0
        /varset MyTargetName
        /varset ValidTarget 0
        /varset MercAssisting 0
        /varset CombatStart 0
        /varset Pulled 0
        /varset NamedCheck 0
        /call PullReset
        /squelch /attack off
        /squelch /target clear
        /varset Attacking 0
        /if (${DPSOn}) {
            /for i 1 to ${DPS.Size}
                /if (${Int[${DPS[${i}].Arg[2,|]}]}<101) { 
                /varset DPSTimer${i} 0
                /varset FDTimer${i}  0
            }
            /next i
        }
        /if (${Me.Pet.ID}) {
            /varset PetAttack 0
            /pet back off
            /if (${PetHoldOn}) /pet ${PetHold} on
        }
        /if (${Defined[DPSTimeStart${MyTargetID}]}) /deletevar DPSTimeStart${MyTargetID}
        /varset DPSLastTime 0
        /varset DPSTotal 0
        /varset DPSTarget 0
        /varset DPSPetTotal 0
        /varset DPSCounter 0
        /varset BurnActive 0
        /if (!${TwistOn}) {
		/if (${MeleeTwistOn}) /varset DPSTwisting 0
	}
        /if (${LootOn}) {
            /delay 10
            /call LootStuff
            /if (${IAmABard}) {
               /squelch /twist off
                /stopsong
                /delay 20 !${Twist}
            }
        }
        /if (${IAmABard}) /call DoBardStuff
        /call ClearOutAlerts 2
        /varset TankTimer 30s
        /squelch /target clear
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT CombatReset: Leave \agLine#: ${Macro.CurLine}
        /varset PetFollowTimer 60s
        /doevents flush
        /if (${Stick.Active} && !${ChaseAssist}) /stick off
        /if (${Select[${Me.Class.ShortName},ROG]}) /call Roguestuff
    /return
| -------------------------------------------------------------------------------------
| SUB: Check for Adds
| -------------------------------------------------------------------------------------
    Sub CheckForAdds(CalledFrom)
		/if (${Me.XTarget}==0) {
			|NOT your job, don't aggro stuff in camp, ever.
			|If this is needed add a new role for it,
			|call it, Addchecker or something.
			|It is my oppinion that the pulls should
			|be handled in the pull sub only,
			|and if there is a VALID mob in camp, it will be pulled from it.
			/return
		}
        /if (${Debug}) /echo \atDEBUG  CheckForAdds: Enter from ${CalledFrom} \agLine#: ${Macro.CurLine}
        /call MobRadar ${MeleeDistance} CheckForAdds
        /if (${Debug}) /echo \atDEBUG MobCount:${MobCount} \agLine#: ${Macro.CurLine}
        | If no mobs, in a DMZone or pulling Leave
        /if (${MobCount}<=1)  /return  
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Pulling}) /return
        /if (!${DPSOn} && !${MeleeOn}) /return
        /if ((${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius})) /return
        /if (${IAmDead}) /return        
        /if (${ChainPull}==2 || ${DPSPaused}) /return
        | If I have a valid living target in camp radius Leave
        /if (!${Target.ID} && ${MyTargetID} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance}<${CampRadius}) {
            /echo Targeting a mob 9: ${Spawn[${MyTargetID}]}
	    /target id ${MyTargetID}
            /return
        }
        | Spam Adds in camp
        /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<=${CampRadius} && !${MyTargetID} && !${AddSpam}) {
            /popup Add(s) in camp detected          
            /if ((${MainAssist.Equal[${Me}]} || ${Select[${Role},tank,pullertank,pettank,pullerpettank]})) /call BroadCast ${IRCOn} ${EQBCOn} r "Add(s) in camp detected"      
            /if (${Select[${Role},pullertank,pullerpettank]}) /varset Pulled 0
            /varset AddSpam 5s
        }
        | Prevent puller from stalling if adds in camp and still returning from pulling mob.
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Pulled} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=15) /return
        /if (!${Target.ID} && ${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]}) {
		/echo Targeting a mob 10: ${Spawn[${AggroTargetID}]}
		/squelch /target ID ${Spawn[${AggroTargetID}].ID}
	}
        /if (${Target.Type.NotEqual[npc]}) {
            /squelch /target clear
            /return
        }
        /if (${Debug}) /echo \atDEBUG CheckForAdds: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: AggroCheck
| -------------------------------------------------------------------------------------
Sub AggroCheck
    /if (!${Me.HaveExpansion[Rain of Fear]}) /return
    /if (${Target.Type.Equal[corpse]}) /return
    /if (${Defined[ParseDPS]}) /return
    /if (${DebugCombat}) /echo \atDEBUGCOMBAT AggroCheck Enter  \agLine#: ${Macro.CurLine}
    /declare i int local
    /declare AggroSpell string local
    /declare AggroGLT string local
    /declare AggroPCT int local    
    /declare AggroTarget string local
    /declare AggroTID int local
    /for i 1 to ${Aggro.Size}
        /varset AggroSpell ${Aggro[${i}].Arg[1,|]}
        /varset AggroPCT ${Aggro[${i}].Arg[2,|]}
        /varset AggroGLT ${Aggro[${i}].Arg[3,|]}
        /varset AggroTarget ${Aggro[${i}].Arg[4,|]}
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AggroCheck ${Me.PctAggro} ${AggroGLT} ${AggroPCT} ${AggroSpell} \agLine#: ${Macro.CurLine}
        /if (${ConditionsOn} && ${DPSCOn} && ${If[${AggroCond[${i}]},0,1]}) /goto :NextAggro
        /if ((${AggroGLT.Equal[<]} && ${Me.PctAggro}<${AggroPCT}) || (${AggroGLT.Equal[>]} && ${Me.PctAggro}>${AggroPCT}) && (${Cast.Ready[${AggroSpell}]} || ${Me.AbilityReady[${AggroSpell}]} || (${Me.CombatAbilityReady[${AggroSpell}]} && !${Me.ActiveDisc.ID}))) {
            /echo Trying to control Aggro: ${Me.PctAggro} ${AggroGLT} ${AggroPCT} ${AggroSpell} 
            /if (${Select[${AggroTarget},null,Mob]} || ${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}>${MeleeDistance}) /varset AggroTID ${MyTargetID}
            /if (${AggroTarget.Equal[Me]}) /varset AggroTID ${Me.ID}
            /if (${AggroTarget.Equal[MA]}) /varset AggroTID ${Spawn[=${MainAssist}].ID}
            /if (${AggroTarget.Equal[Pet]}) /varset AggroTID ${Me.Pet.ID}
            /if (${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}<${MeleeDistance}) /goto :NextAggro
            /call CastWhat "${AggroSpell}" ${AggroTID} Aggro
            /call WaitCast
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo Casting >> ${AggroSpell} << to control AGGRO on ${Spawn[${AggroTID}].CleanName}.
                /if (${AggroGLT.Equal[>]}) {
                    /if (!${AggroOffTimer}) {
                       /if (${Me.Feigning} || ${Me.Invis}) /varset AggroOffTimer 20
                    }
                }
                /return
            }  
        }
        :NextAggro
    /next i
    /if (${DebugCombat}) /echo \atDEBUGCOMBAT AggroCheck Leave \agLine#: ${Macro.CurLine}
/return

Sub WaitCast(string sentFrom)
	/varset GemStuckTimer 20s
:rewaitcast
	/if (${Me.BardSongPlaying}) {
		/delay 1
		/if (${Window[CastingWindow].Open}==FALSE) {
			|/echo returning from waitcast because im a bard and im not technically casting right now, just playing songs.
			/delay 1
			/return
		}
	}
	/if (${Me.Hovering}) /return
	/if (${sentFrom.Equal[SingleHeal]} && ${CastingInterruptOn}) {
		/call KACheckHP
	} else /if (${Select[${sentFrom},dps,gom,burn]} > 0 && ${CastingInterruptOn}) {
		/call KACheckDPS
	} else /if (${Select[${sentFrom},buffs,buffs-nomem]} > 0 && ${CastingInterruptOn}) {
		/call KACheckBUFFS
	}
	/if (${Cast.Status.NotEqual[I]} || ${Me.Casting.ID}) {
		|you haven't recovered yet...
		/delay 1
		/if (${GemStuckTimer}==0) {
			/beep
			/echo OUR GEMS ARE STUCK!
			/delay 1s
			/if (${GemStuckAbility.NotEqual[NULL]}) {
				/if (${Me.AltAbilityReady[${GemStuckAbility}]}) {
					/alt act ${Me.AltAbility[${GemStuckAbility}].ID}
					/delay 5s ${Me.SpellInCooldown}==FALSE
				} else {
					/echo wating for ${GemStuckAbility} to be ready so we can unstick the gems
					/varset GemStuckTimer 2s
				}
			} else {
				/echo Your GemStuckAbility is set to NULL in the General section, so I cant unstick you.
				/varset GemStuckTimer 2s
			}
		}
		/goto :rewaitcast
	}
	/echo ${Cast.Result}
/return
| -------------------------------------------------------------------------------------
| SUB: CastWhat
| -------------------------------------------------------------------------------------
    Sub CastWhat(string castWhat,int castTargetID, string sentFrom, int bDontCheckShit)
	
	/if (${OhShitOn}) {
		/if (!${bDontCheckShit}) {
			|/echo checking shit in CastWhat called from ${sentFrom} 
			/call OhShitStuff
		} else {
			/echo not checking shit we got called from it, dont want recursive calls...
		}
	}
        /if (${Debug}) /echo \atDEBUG CastWhat: Enter castWhat - \ay${castWhat} CastonName: ${Spawn[id ${castTargetID}].CleanName} castTargetID - ${castTargetID} \awFrom: ${sentFrom} \agLine#: ${Macro.CurLine}
        /declare WasTwisting bool local ${Twist}
        /varset CastResult CAST_NO_RESULT
        |***********************************| SKILLS |***************************************|
        | Check for Skills
        /if (${Me.Ability[${castWhat}]} && ${Me.AbilityReady[${castWhat}]}) {
                /doability "${castWhat}"
                /call WaitCast ${sentFrom}
                /if (!${Me.AbilityReady[${castWhat}]}) /varset CastResult CAST_SUCCESS
                /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
                /return ${CastResult}
        }
        |***********************************| COMBAT ABILITIES| ***************************************|
        | - Check & cast if Combat ability/disc
        /if (${Me.CombatAbility[${castWhat}]} && !${Me.CombatAbilityTimer[${castWhat}]} && ${Me.CombatAbilityReady[${castWhat}]} && ${Spell[${castWhat}].EnduranceCost}<${Me.Endurance}) {
          /if (${Debug}) {
		/echo \atDEBUG CastWhat: ${castWhat} \ayCombat ability/disc/discipline: CombatAbility:${Me.CombatAbility[${castWhat}]} CombatAbilityTimer:!${Me.CombatAbilityTimer[${castWhat}]} CombatAbilityReady:${Me.CombatAbilityReady[${castWhat}]} \agLine#: ${Macro.CurLine}
          }
	  /if (${WasTwisting}) {
                /squelch /twist off
                /delay 20 !${Twist}
            }
          /if (${Debug}) /echo \atDEBUG CastWhat: \ayCombat ability/disc/discipline: ${castWhat} spell duration: ${Spell[${castWhat}].Duration.TotalSeconds} - discid: ${Me.ActiveDisc.ID} \agLine#: ${Macro.CurLine}
          /if (!${Spell[${castWhat}].Duration} || (${Spell[${castWhat}].Duration} && ${Spell[${castWhat}].TargetType.Equal[Self]} && !${Me.ActiveDisc.ID}) || ${Spell[${castWhat}].TargetType.NotEqual[Self]}) {
                | /if (${Spell[${castWhat}].EnduranceCost}>${Me.Endurance}) /return CAST_OUTOFENDURANCE
                /if (${Target.ID}!=${castTargetID} && ${Spawn[id ${castTargetID}].ID}) {
                    /echo Targeting a mob 11: ${Spawn[${castTargetID}]}
		    /target id ${castTargetID}
                    /delay 10 ${Target.ID}==${castTargetID}
                }
                /disc ${Me.CombatAbility[${Me.CombatAbility[${castWhat}]}].ID}
                /call WaitCast ${sentFrom}
                /varset CastResult CAST_SUCCESS
            }
            /if (${WasTwisting} && !${Twist}) {
                /delay 30
                /squelch /twist
            }            
            /if (${Debug}) /echo \atDEBUG CastWhat: \ayLeave from DISC ${CastResult} \agLine#: ${Macro.CurLine}
            /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
            /return ${CastResult}
        }
        |***********************************| ITEMS |***************************************|
        | - Check & cast if item
        /if (${FindItem[=${castWhat}].ID} && ${Me.ItemReady[${castWhat}]}) {
            /if (${Debug}) /echo \atDEBUG CastWhat: \ayItemFound ${FindItem[=${castWhat}].ID} Ready: ${Me.ItemReady[${castWhat}]} \agLine#: ${Macro.CurLine}
            | Prevent casting of Prestige items on silver and F2P accounts
            /if (${Me.Subscription.NotEqual[gold]} && ${FindItem[=${castWhat}].Prestige}) /return 0
            | Fix for progression server - exchange item to inventory slot 30
            | Check if the server name is a progression server name
            /if (${Select[${EverQuest.Server},fippy,vulak,ragefire,lockjaw]}) {
                /if (${FindItem[=${castWhat}].ItemSlot}>22) {
                    /exchange "${castWhat}" 30
                    /autoinventory
                }
            }
            /if (${IAmABard}) {
                /if (${WasTwisting} || (!${Me.SpellReady[1]} && !${Me.SpellReady[2]} && !${Me.SpellReady[3]} && !${Me.SpellReady[4]})) {
                    /twist off
                    /delay 10
                    /stopsong
                    /delay 40 (!${Twist} && !${Me.Casting.ID} && (${Me.SpellReady[1]} && ${Me.SpellReady[2]} && ${Me.SpellReady[3]} && ${Me.SpellReady[4]}))                  
                }
                /casting "${castWhat}|item" -targetid|${castTargetID}
                /varset CastResult ${Cast.Result}
                /delay 300 !${Cast.Status.Equal[C]}
                /if (${WasTwisting} && !${Twist}) {
                    /twist
                }
                /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
                /return ${CastResult}
            }
            /if (${Target.ID}!=${castTargetID} && ${Spawn[id ${castTargetID}].ID}) {
                /echo Targeting a mob 12: ${Spawn[${castTargetID}]}
		/target id ${castTargetID}
                /delay 10 ${Target.ID}==${castTargetID}
            }
            /casting "${castWhat}" item
            /if (${Debug}) /echo \atDEBUG CastWhat \aycast item result: ${Cast.Result} \agLine#: ${Macro.CurLine}
            /varset CastResult ${Cast.Result}
            /delay 5s ${Cast.Status.Equal[I]}
            /if (${Debug}) /echo \atDEBUG CastWhat \ayLeave item cast ${CastResult} \agLine#: ${Macro.CurLine}
            /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
            /return ${CastResult}
        }
        |***********************************| ALTERNATE ABILITIES |***************************************|
        | - Check & cast if AA | do not cast if it is a focus aa (${Me.AltAbility[${castWhat}].Type}!=5) for a spell of same name !!!!!!!                
        /if (${Me.AltAbility[${castWhat}]} && ${Me.AltAbilityReady[${castWhat}]} && ${Me.AltAbility[${castWhat}].Type}!=5 && ${castWhat.NotEqual[twincast]})  { 
            /if (${Select[${castWhat},Banestrike,15073]} && !${Banestrike.Find[|${Target.Race}|]} && ${Spawn[${MyTargetID}].Distance3D}>70 && ${CombatStart}) /return
            /if (${Debug}) /echo \atDEBUG CastWhat: \ayStart of AbilityCheck and exceptions. \agLine#: ${Macro.CurLine}
            /if (${Target.ID}!=${castTargetID} && ${Spawn[id ${castTargetID}].ID}) {
		/echo Targeting a mob 13: ${Spawn[${castTargetID}]}
                /target id ${castTargetID}
                /delay 10 ${Target.ID}==${castTargetID}
            }
            /alt act ${Me.AltAbility[${castWhat}].ID}
            /call WaitCast ${sentFrom}
            /if (${Me.AltAbilityReady[${castWhat}]}) {
                /varset CastResult CAST_RECOVER
            } else {
                /varset CastResult CAST_SUCCESS
            }
            /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
            /return ${CastResult}
        }
        | Always use AA if it exists for Voice of Thule}
        /if (${castWhat.Equal[Voice of Thule]} && ${Me.AltAbility[Voice of Thule]}) /return
        |***********************************| SPELLS |***************************************|
        | - Check & cast if spell
        /if (${Me.Book[${castWhat}]} && (${IAmABard} || !${IAmABard} && ${Spell[${castWhat}].Mana}<=${Me.CurrentMana})) {
            /if (${Debug}) /echo \atDEBUG CastWhat: \aySpellCheck HaveSpell:${Me.Book[${castWhat}]} HaveMana:${Spell[${castWhat}].Mana}<=${Me.CurrentMana} \agLine#: ${Macro.CurLine}
            | Avoid confusion between spells and items of the same name. e.g. mage Wand of Phantasmal Modulation
            /if (${FindItem[=${castWhat}].ID}) /return
            | Mem spell if not memmed
            /if (!${Me.Gem[${castWhat}]}) {
                | Prevent tanks and heals trying to mem spells during combat.
                /if (${Attacking} && ${MainAssist.Equal[${Me}]} || ${HealsOn} && ${AggroTargetID} && ${sentFrom.NotEqual[Heal]}) /return
                /if (${Cursor.ID}) /call CheckCursor
                /if (${MiscGemRemem} && ${MiscGemLW} && ${Spell[${castWhat}].RecastTime.TotalSeconds}>30 && ${ReMemWaitLong.Equal[null]}) {
                   /varset ReMemWaitLong ${castWhat}
		   /echo calling MemSpell in CastWhat 1 for ${castWhat}
                   /call MemSpell "${castWhat}" ${MiscGemLW} 0
                   /return ${CastResult}
                }
                |/memorize "${castWhat}" gem${MiscGem}
                /varset ReMemWaitShort ${castWhat}
		/echo calling MemSpell in CastWhat 2 for ${castWhat}
                /call MemSpell "${castWhat}" ${MiscGem} 0
		/echo [${Time}] Pre Memspell for ${castWhat}
                /delay 350 ${Me.SpellReady[${castWhat}]} && ${Me.GemTimer[${castWhat}]}==0
		/echo [${Time}] Post Memspell for ${castWhat} 
            }
            /if (${Target.ID}!=${castTargetID} && ${Spell[${Me.Book[${Me.Book[${castWhat}]}].ID}].TargetType.NotEqual[Self]} && ${Spawn[id ${castTargetID}].ID}) {
                /echo Targeting a mob 14: ${Spawn[${castTargetID}]}
		/target id ${castTargetID}
                /delay 10 ${Target.ID}==${castTargetID}
            }
            /if (!${Target.CanSplashLand} && ${Spell[${Me.Book[${Me.Book[${castWhat}]}].ID}].TargetType.Equal[Free Target]}) {
               /echo Splash Spell will not cast at targets location. Skipping ${castWhat}
               /return
            }
            | Wait for global cooldown active
            | /if (!${IAmABard} && ${sentFrom.NotEqual[Heal]} ) /delay 15 ${Cast.Status.Equal[I]}
            /if (${Me.GemTimer[${castWhat}]}==0 && !${IAmABard}) {
				/if (${sentFrom.Equal[Pull]}) {
		            |/echo not gonna cast twice even if resist, cause this IS a pull cast...
					/casting "${castWhat}" gem${MiscGem} 3s -maxtries|1
					/call WaitCast ${sentFrom}
					/if (${Me.XTarget}) {
						|/echo get out! we got it.
						/varset CastResult CAST_SUCCESS
						/return ${CastResult}
					}
				} else {
					/casting "${castWhat}" gem${MiscGem} 3s -maxtries|2
					/call WaitCast ${sentFrom}
				}
                /if (${Debug}) /echo \atDEBUG CastWhat \aycast Spell result: ${Cast.Result} \agLine#: ${Macro.CurLine}
				/if (${CastingInterruptOn}) {
					/if (${Cast.Result.Equal[CAST_CANCELLED]} || ${CastResult.Equal[CAST_CANCELLED]}) {
						/if (${Select[${sentFrom},dps,gom,singleheal]} > 0) /echo Your Spell: ${castWhat} was aborted due to interrupt conditions in castwhat.
					}
				}
                | READ THIS. For some reason Cast.Result is still equal to CAST_SUCCESS after /interrupt, maybe macro to fast for plugin to update.
                | So checking for CastResult NotEqual CAST_CANCELLED fixes the issue, and fixes the casting on corpse messages even though the spell was canceled. 
                /if (${CastResult.NotEqual[CAST_CANCELLED]}) /varset CastResult ${Cast.Result}
                /doevents
                |Remem spell originally in Miscgem slot except if combat or just rezd
                /if (${MiscGemRemem}) {
                    |We need to check if the spell just cast was swaped out and other spell needs to bo rememed.
                    |Need a way to carry a flag so remem will be done out of combat after the spell has been cast.
                    /if (${CastResult.Equal[CAST_SUCCESS]}) {
                        |Is it the MiscGem?
                        /if (${castWhat.Equal[${ReMemWaitShort}]}) {
                            /varset ReMemCast 1
                        |Is it the MiscGemLW
                        } else /if (${castWhat.Equal[${ReMemWaitLong}]}) {
                            /varset ReMemCastLW 1
                        }
                    }
                    /if (${MiscGemRemem}==1 || ${MiscGemRemem}==2) {
                        /if (!${Me.Gem[${ReMemMiscGem}]} && ${ReMemCast} && !${CombatStart} && !${Me.Buff[Resurrection Sickness].ID} && !${sentFrom.Find[-nomem]}) {
                            /if (${Cursor.ID}) /call CheckCursor
                            |/memorize "${ReMemMiscGem}" gem${MiscGem}
			    /echo calling MemSpell in CastWhat 3 for ${ReMemMiscGem}
                            /call MemSpell "${ReMemMiscGem}" ${MiscGem} 0
                            /varset ReMemCast 0
                            /varset ReMemWaitShort null
                        }
                    }
                    |Remem spell originally in Long Wait Gem slot
                    /if ((${MiscGemRemem}==1 || ${MiscGemRemem}==3) && ${MiscGemLW} && ${ReMemWaitLong.NotEqual[null]}) {
                        /if (${ReMemCastLW} && !${Me.Buff[Resurrection Sickness].ID}) {
                            /if (${Cursor.ID}) /call CheckCursor
                            /echo calling MemSpell in CastWhat 4 for ${ReMemMiscGemLW}
			    /call MemSpell "${ReMemMiscGemLW}" ${MiscGemLW} ${Int[${Me.Gem[${ReMemMiscGemLW}]}]}
                            /varset ReMemCastLW 0
                            /varset ReMemWaitLong null
                        }
                    }
                }
            }
            /if (${IAmABard} && ${Me.GemTimer[${castWhat}]}==0) {
                /delay 2
                /if (${Me.GemTimer[${castWhat}]}!=0) /return
                /squelch /twist once ${Me.Gem[${castWhat}]}
                /delay 30
                /varset CastResult CAST_SUCCESS
            }
        }
        /if (${WasTwisting} && !${Twist}) /squelch /twist
        /if (${Debug}) /echo \atDEBUG CastWhat Leave \ay${CastResult} \agLine#: ${Macro.CurLine}
        /if (${CastResult.Equal[CAST_SUCCESS]}) /doevents
    /return ${CastResult}
| -------------------------------------------------------------------------------------
| SUB: KACheckHP
| -------------------------------------------------------------------------------------
    Sub KACheckHP
       /if (!${Int[${Me.Casting.ID}]}) /return
       /if (${Target.Type.Equal[npc]}) {
           /Interrupt
           /varset CastResult CAST_CANCELLED
           /if (${Debug}) /echo CheckHP1: ${Target.Type}
       }
       /if ( ${Target.PctHPs}>${SHealPct}) {
           /Interrupt
           /varset CastResult CAST_CANCELLED
           /if (${Debug}) /echo CheckHP2: ${Target.PctHPs} ${SHealPct}
       }
    /return
| -------------------------------------------------------------------------------------
| SUB: KACheckDPS
| -------------------------------------------------------------------------------------
    Sub KACheckDPS
	/if (!${Int[${Me.Casting.ID}]}) /return
	/if (${Target.Type.Equal[pc]}) /return
	/if (${Target.PctHPs}<1 || ${Target.Type.Equal[corpse]} || !${Int[${Target.ID}]}) {
		/Interrupt
		/varset CastResult CAST_CANCELLED
		/if (${Debug}) /echo CheckDPS1: ${Target.PctHPs} ${Target.Type} ${Int[${Target.ID}]}
	}
	/if (${HealsOn}) {
		/if (${Spawn[${MainAssist}].PctHPs}<50 && ${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]}) {
			/Interrupt
			/varset CastResult CAST_CANCELLED
			/if (${Debug}) {
				/echo CheckDPS2: ${HealsOn}  ${Spawn[${MainAssist}].PctHPs} ${Spawn[${MainAssist} ${MainAssistType}].ID}  ${Spawn[${MainAssist} ${MainAssistType}].Type}
			}
		}
	}
    /return       
| -------------------------------------------------------------------------------------
| SUB: KACheckBUFFS
| -------------------------------------------------------------------------------------
	Sub KACheckBUFFS
		/if (!${Int[${Me.Casting.ID}]}) /return
		/if (${Me.Casting.Range}==0 && ${Me.Casting.AERange}==0) /return
		/if ((${Int[${Target.ID}]} && ${Int[${Target.PctHPs}]}<1) || ${Target.Type.Equal[corpse]} || (!${Int[${Target.ID}]} && ${Select[${Me.Casting.TargetType},self,pet,pet1,pet2]}==0)) {
			/Interrupt
			/varset CastResult CAST_CANCELLED
			/if (${Debug}) /echo CheckBUFFS2: ${Int[${Target.PctHPs}]} ${Target.Type}  ${Int[${Target.ID}]} ${Me.Casting} ${Me.Casting.TargetType}
		}
		/if ((${Me.Casting.Range}>0 && ${Target.Distance}>${Me.Casting.Range}) || (${Me.Casting.AERange}>0 && ${Target.Distance}>${Me.Casting.AERange})) {
			/Interrupt
			/varset CastResult CAST_CANCELLED
			/if (${Debug}) {
				/echo CheckBUFFS3: ${Int[${Me.Casting.ID}]}  ${Target.Distance} ${Me.Casting.Range} ${Me.Casting.AERange} ${Me.Casting}
			}
		}
	/return       
| -------------------------------------------------------------------------------------
| SUB: CheckCasting
| -------------------------------------------------------------------------------------
    Sub CheckCasting(int CCTime)
    /if (${IAmABard}) /return
    /declare CCTimer timer local ${CCTime}
        /if (!${CCTimer}) /varset CCTimer 30s
        :NotReady
            /if (${CCTimer}==0) /return
            /delay 1
        /if (${Me.Casting.ID} || ${Cast.Status.Equal[C]})  /goto :NotReady
     /return    
| -------------------------------------------------------------------------------------
| SUB: Do We Move
| -------------------------------------------------------------------------------------
    Sub DoWeMove(string SentFrom)
	/if (!${ReturnToCamp} && !${ChaseAssist}) {
		|/echo returning from DoWeMove ${SentFrom} because ReturnToCamp and ChaseAssist was 0
		/return
	}
        /declare StuckCount int local 0 
        /declare X1 int local
        /declare Y1 int local
        /declare scatterDistance int local
        /declare CampYRandom int local
        /declare CampXRandom int local
        | Stop sticking if mobs are on xtarget
        /if (${SpawnCount[npc xtarhater]} && !${Role.Find[pull]} && ${MainAssist.NotEqual[${Me}]}) {
	    	|/echo 1. Returning from DoWeMove ${SentFrom} ${SpawnCount[npc xtarhater]} ${Role.Find[pull]} ${MainAssist.NotEqual[${Me}]}
            /if (${Stick.Active}) {
                 /if (${DebugMove}) /echo \atDEBUG Not gonna be an idiot and move during fight cause I dont have to.
                /stick off
                /moveto off
		/if (${Bool[${Plugin[mq2advpath]}]}==TRUE) {
               		/play off
 		}
		/if (${Bool[${Plugin[mq2navigation]}]}==TRUE || ${Bool[${Plugin[mq2nav]}]}==TRUE) {
                   /if (${Navigation.Active}) {
			/echo 1 stopping nav 
			/nav stop
		    }
                }
            }
            /return
        }
        /doevents
        /call EndMacroIf
        /declare ZDist float local 0
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 30s
        /if (${Target.ID} && ${Target.Type.Equal[npc]}) {
            /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        }
        /declare circleDirection string local
        /if (${Debug}) /echo \atDEBUG DoWeMove: Enter \agLine#: ${Macro.CurLine}
        | - Shuts off ReturnToCamp if a toon moves a big distance defined by CampRadiusExceed ie CoH !${Pulled} || ${Pulling}
        /if (${ReturnToCamp}) {
            /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) My distance from camp is: (${Math.Distance[${CampYLoc},${CampXLoc}]}). \agLine#: ${Macro.CurLine}
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadiusExceed} && !${Role.Find[hunter]} && ${ReturnToCamp}==1) {
                /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) CampRadiusExceed turning off ReturnToCamp. \agLine#: ${Macro.CurLine}
                /varset ReturnToCamp 0
                /echo Leashing exceeded distance of ${CampRadiusExceed} turning off ReturnToCamp
                /return
            }
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 5) {
                /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) Distance to camp > 5 and no adds in camp. ${Math.Distance[${CampYLoc},${CampXLoc}]} ${CampRadius} ${Medding} \agLine#: ${Macro.CurLine}
                | Prevent puller roles from returning to camphere spot and just pull from where they are if in camp radius.
                /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=${CampRadius} && !${Medding}) {
			/if (${DebugMove}) /echo 2 returning from DoWeMove ${SentFrom} because ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}
			/return
		}
                /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 5) {
                    |---------------------------------------------- MQ2Nav ---------------------------------------------------------------------|
                    /if (${mq2navloaded}) {
			/if (${Navigation.MeshLoaded} && ${PullMoveUse.Equal[nav]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius}) {
                        /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ReturnToCamp) Distance to camp > 5, MQ2Navigation return to camp. \agLine#: ${Macro.CurLine}
                        /if (${Navigation.Active}) {
				/echo stopping nav right before :NotInCamp
				/nav stop
			}
			:NotInCamp
                            /doevents
                            /if (${IAmDead} || ${Me.Hovering}) {
                                /if (${Navigation.Active}) {
					|/echo 2 stopping nav and returning from DoWeMove
					/nav stop
				}
                                /return
                            }
			    /if (!${Navigation.Active}) {
				/echo going back to camp...
                            	/nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
			    } else {
				/echo well... it looks like Navigation.Active is ${Navigation.Active} so we shouldnt start another
			    }
                            /if (${Me.Mount.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]} <= 75 ) {
                                /echo MQ2Nav does not work well with mounts. Dismounting.
                                /dismount
                            }
                            :NavActive
                                /varset X1 ${Int[${Me.X}]}
                                /varset Y1 ${Int[${Me.Y}]}   
                                | PullerPetTank - send in pet to attack on my way back to camp if not too far from camp.
                                /if (${Select[${Role},pullerpettank]} && ${Pulled}) {
                                    /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                                        /call CombatPet
                                    } else {
                                        /pet back off
                                    }
                                }     
                                /delay 10
                                | Check for getting stuck on geometry
                                /if (${Int[${Me.X}]}==${X1} && ${Int[${Me.Y}]}==${Y1}) {
                                    /varcalc StuckCount (${StuckCount})+1
                                    /if (${StuckCount}>=3) {
                                        /if (${Navigation.Active}) {
						/echo 3 stopping nav 
						/nav stop
					}
                                        /call Stuck
                                        /varset StuckCount 0
                                    }
                                }                                
                                /if (${DebugMove}) /echo \atDEBUG DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} >= ${CampRadius} Timer: ${DWMTimer} \agLine#: ${Macro.CurLine}
                                /if (${Navigation.Active} && ${DWMTimer}>=1) /goto :NavActive
                                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 5) /goto :NotInCamp
			}
                    |---------------------------------------------- MQ2AdvPath ---------------------------------------------------------------------|
                    } else /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]} && ${mq2advpathloaded}) {
                        /play ${PullPath} reverse nodoor smart
                        /if (${DebugMove}) /echo \atDEBUG DoWeMove: /play ${PullPath} reverse nodoor smart \agLine#: ${Macro.CurLine}
                        :RunningThePathBack
                            /doevents
                            /if (${IAmDead} || ${Me.Hovering}) {
				|/echo returning from DoWeMove ${SentFrom} because im dead
                                /play off
                                /return
                            }
                            /delay 10 
                            /varset DWMWPCurrent ${AdvPath.NextWaypoint}
                            /if (${DebugMove}) /echo \atDEBUG DoWeMove: ReturnToCamp WP#: ${DWMWPCurrent} \agLine#: ${Macro.CurLine}
                        /if (${DWMWPCurrent}>=2 && ${DWMTimer}>=1) /goto :RunningThePathBack
                    } 
                } 
                /if (${DebugMove}) /echo \atDEBUG DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15, MQ2MoveUtils return to camp. \agLine#: ${Macro.CurLine}
                /doevents
                |/look 0 dont mess with peoples look...
                |this /moveto call actually /stand the char up... we dont want that.
		|/moveto mdist 10     
                /if (${Scatter} && ${Zone.Outdoor}) {
                    | Randomize camp x,y by +- so toons don't always retun to exact same spot and help to look less botted.
                    /varset scatterDistance ${Math.Rand[${Scatter}]}
                    /if (${Math.Rand[2]}) {
                        /varcalc CampYRandom ${CampYLoc}-${scatterDistance}
                    } else {
                        /varcalc CampYRandom ${CampYLoc}+${scatterDistance}
                    }  
                    /if (${Math.Rand[2]}) {
                        /varcalc CampXRandom ${CampXLoc}-${scatterDistance}
                    } else {
                        /varcalc CampXRandom ${CampXLoc}+${scatterDistance}
                    }
                } else {
                   /varset CampYRandom ${CampYLoc}
                   /varset CampXRandom ${CampXLoc}
                }                
                /if (${DebugMove}) /echo \atDEBUG DoWeMove: Camp Location Info: Scatter: ${Scatter} YRandom: ${CampYRandom} XRandom: ${CampXRandom} \agLine#: ${Macro.CurLine}
                :StillMoving
                    /if (${IAmDead} || ${Me.Hovering}) {
			/echo moveto 4
                        /moveto off
			|/echo 2. returning from DoWeMove ${SentFrom} because I'm dead
                        /return
                    }
                    |/if (!${Me.Mount.ID} && ${Me.Sitting}) {
			|/echo going to stand 3
			|/stand
		    |}
                    /if (!${Me.Moving} || !${MoveTo.Moving}) {
			/if (${Math.Distance[${CampYRandom},${CampXRandom}]} > 6) {
				/echo trying to get within 5 feet of the camp (${Math.Distance[${CampYRandom},${CampXRandom}]} ft)
				/if (${mq2navloaded}) {
					/if (${Navigation.MeshLoaded} && ${Navigation.Active}==FALSE) {
						/nav locyxz ${CampYRandom} ${CampXRandom} ${CampZLoc}
					} else {
						/moveto mdist 5
						/moveto loc ${CampYRandom} ${CampXRandom}
					}
				} else {
					/moveto mdist 5
					/moveto loc ${CampYRandom} ${CampXRandom}
				}
			}
		    }
                    /if (${Select[${Role},pullerpettank]} && ${Pulled}) {
                        /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                            /call CombatPet
                        } else {
                            /pet back off
                        }
                    }     
                    /delay 10
					/if (${mq2navloaded} && ${DWMTimer}>=1) {
						/if (${Navigation.MeshLoaded} && ${Navigation.Active}) {
							 /goto :StillMoving
						}
					} 
                    /if ((${MoveTo.Moving} || ${Me.Moving}) && ${DWMTimer}>=1) /goto :StillMoving
                /if (${MoveTo.Moving} && ${Math.Distance[${CampYRandom},${CampXRandom}]} > 15) /goto :StillMoving
                /delay 20 !${Me.Moving}
                | Move down if Z distance more than 3 due to levitation
                /if (${Target.ID} && ${Select[${Target.Type},npc,corpse]})  /call ZAxisCheck ${ZDist} 3.1
                /if (${Select[${Role},hunter,hunterpettank]}) /varset ReturnToCamp 0
            }
        }
        /if (${ChaseAssist}) {
            /if (${Debug}) /echo \atDEBUG ChaseAssist \agLine#: ${Macro.CurLine}
            /if (${DebugMove}) /echo \atDEBUG DoWeMove:(ChaseAssist) My distance from (${MainAssist}) is: (${Spawn[=${MainAssist}].Distance}). \agLine#: ${Macro.CurLine}
            /if (${JustZoned}==0 && (${Spawn[=${MainAssist}].Distance} > ${CampRadiusExceed}) || (${Math.Calc[${Spawn[=${MainAssist}].Z}-${Me.Z}]}>100 && ${Math.Calc[${Spawn[=${MainAssist}].Z}-${Me.Z}]}<100)) {
		/if (!${Navigation.MeshLoaded}) {
                	/if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist exceed camp check \agLine#: ${Macro.CurLine}
                	/varset ChaseAssist 0
                	/echo ChaseAssist distance exceeded: Turning off ChaseAssist
                	/call BroadCast ${IRCOn} ${EQBCOn} r "Hey! I got left behind please run me to MA"
		} else {
			/if (!${Navigation.Active}) {
				|well, we have a mesh, lets just run to main assist, there is no reason not to...
				/call BroadCast ${IRCOn} ${EQBCOn} r "Hey! I got left behind, using /nav id to get to MA!"
				/nav id ${Spawn[=${MainAssist}].ID}
			}
			/delay 20s ${Navigation.Active}
		}
            }
            /if (${Spawn[=${MainAssist}].Distance} > ${ChaseDistance} && ${Spawn[=${MainAssist}].Distance} < ${CampRadiusExceed}) {
                /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist MA distance check \agLine#: ${Macro.CurLine}
                /if (${Spawn[=${MainAssist}].Type.Equal[Pet]}) {
                    /target id ${Spawn[=${MainAssist}].Master.ID}
                    /delay 10 ${Target.ID}==${Spawn[=${MainAssist}].Master>ID}
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} uw id ${Target.ID} loose
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else /if ( ${Spawn[=${MainAssist}].Type.Equal[mercenary]}) {
                    /target id ${Spawn[=${MainAssist}].Owner.ID}
                    /delay 20 ${Target.ID}==${Spawn[=${MainAssist}].Owner.ID}
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} uw id ${Target.ID} loose
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else {
                   /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} uw id ${Spawn[=${MainAssist}].ID} loose
                    } else {
                       /stick ${ChaseDistance} id ${Spawn[=${MainAssist}].ID} loose
                    }
                }
                :AreWeThere
                    /delay 1
                 /if (${Me.Moving}) /goto :AreWeThere
            }
        }
        /if (${Debug}) /echo \atDEBUG DoWeMove: Leave \agLine#: ${Macro.CurLine}
    /return
|-------------------------------------------------------------------------------------
| SUB: Stuck
| -------------------------------------------------------------------------------------
    Sub Stuck
    /declare strafedir string local
           | - We're stuck, back off a second, move left or right (randomly) for 1 second
           /if (${IAmDead}) /return
            /keypress back hold
            /delay 10
            /keypress back
            /if (${Math.Rand[2]}) {
                /varset strafedir STRAFE_LEFT
            } else {
                /varset strafedir STRAFE_RIGHT
            }
            /keypress ${strafedir} hold
            /delay 10
            /keypress ${strafedir}
    /return
| -------------------------------------------------------------------------------------
| SUB: DoWeMed
| -------------------------------------------------------------------------------------
    Sub DoWeMed
        /if (!${MedOn}) /return
        /if (!${MedCombat} && ${AggroTargetID}) /return
        /if (${MedCombat} && !${Medding} && ${AggroTargetID}!=0 && ${AggroTargetID}==${MyTargetID}) /return
        /if (${Debug}) {
		/echo \atDEBUG DoWeMed Enter \agLine#: ${Macro.CurLine}
        }
	/declare Med2On int local 0
        /declare MedForceOn int local 0
        /declare MedStat1 string local ${MedStat}
        /declare j int local 0
        /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
        /if (!${Me.Moving}) {
            /if (${Select[${Me.Class.ShortName},BRD,BST,PAL,RNG,SHD]} && ${Me.Pct${MedStat2}} < ${MedStart} && ${Me.Pct${MedStat}}>${MedStart})  {
                /varset MedStat1 ${MedStat}
                /varset MedStat ${MedStat2}
                /varset Med2On 1
            }
            /if (${Group.MainAssist.ID} && ${Group.MainAssist.Sitting}) {
                /if (!${MASitTime}) {
                    /varset MASitTime 300            
                } else /if (${MASitTime}<260) {
                   /varset MedForceOn 1
                }
            } else {
                /varset MASitTime 0
            }
            /if (${Me.Pct${MedStat}} < ${MedStart} || (${ChainPullHold}==2 && ${Me.Pct${MedStat}} < 100) || (${MedForceOn} && ${Me.Pct${MedStat}}<90 && !${Role.Find[puller]} && !${MedCombat})) {
                /squelch /tar clear
                /varset Medding 1
                /if (${Attacking}) /call CombatReset
                /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) /call BroadCast ${IRCOn} ${EQBCOn} t "PULLER-> My ${MedStat} is ${MedStart}% time to med. ${MedStat} ${Me.Pct${MedStat}} ${ChainPullHold}"
                | bards twisting while others fighting negate fast med 
                /if (${IAmABard} && ${AggroTargetID}) {
                    /if (${Twist}) {
			/squelch /twist off
			/stopcast
                    	/delay 10 ${Me.BardSongPlaying}==FALSE
		    }
                    /squelch /twist ${TwistMed}
                }
                /if (${Medding}) /echo Medding until ${MedStat} 100%
                /if (${Me.Pct${MedStat}}<${MedStart}) /call BroadCast ${IRCOn} ${EQBCOn} t "My ${MedStat} is ${MedStart}% time to med."
            :wait_for_resume
                    /doevents
                    /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                        /call DoWeMove "DoWeMed 1"
                    }
                    /if (!${Me.Mount.ID} && ${Me.Standing}) {
			/echo going to sit in DoWeMed
			/sit
		    }                  
                    /if (${Debug}) {
			/echo \atDEBUG ${MedStat} ${MedStat1} ${MedStat2} \agLine#: ${Macro.CurLine}
		    }
                    /delay 10
                    /call CheckCasting 50
                    /delay 10
                    /if (!${MedCombat}) {
                        /call WaitSubs
                        /call CheckForCombat 1 DoWeMed
                        /if (${AggroTargetID}) {
                            /if (${Med2On}) /varset MedStat ${MedStat1}
                            /varset Medding 0
                            /return
                        }
                    }
                /if (${Me.Pct${MedStat}} < 100) /goto :wait_for_resume
                :done_medding
                /if (${Med2On}) /varset MedStat ${MedStat1}
                /varset Medding 0
                /if (${Me.Sitting}) {
			/echo going to stand in DoWeMed
			/stand
		}
                /if (${IAmABard}) {
			/if (${TwistMed}) {
				/echo stopping singing in DoWeMed
				/stopsong
			}
		}
            }
            /if (${Select[${Role},pullerpettank,puller,hunter,hunterpettank]} && ${Me.PctHPs}<=50) {
                /echo Medding to 100% health
                /if (!${Me.Mount.ID} && !${Me.Sitting}) {
			/echo going to sit 2
			/sit
		}
                :WaitFor100
                    /doevents
                    /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                        /if (!${Me.Mount.ID} && ${Me.Sitting}) {
				/echo going to stand 5
				/stand
			}
                        /call DoWeMove "DoWeMed 2"
                    }
                    /delay 10
                    /call CheckCasting 50
                    /delay 5
                    /if (!${MedCombat}) {
                        /call WaitSubs
                        /call CheckForCombat 1 DoWeMed
                        /if (${AggroTargetID}) {
                            /varset Medding 0
                            /return
                        }
                    }
                /if  (${Me.PctHPs}<100) /goto :WaitFor100
                /if (!${Me.Mount.ID} && ${Me.Sitting}) {
			/echo going to stand 6
			/stand
		}
            }
            /if (${Select[${Role},pullerpettank,hunterpettank]} && !${Me.Invis} && (${Me.Pet.PctHPs}<=50 || ${PetForceHealOnMed})) {
                | Check pet is at full health before pulling.  
                /echo Waiting on pet to full health before next pull        
                    /if (${Me.Pet.ID} && ${Me.Pet.PctHPs} < 100) {                
                        :WaitingOnPetHealth
                    /for j ${SingleHeal.Size} downto 1
                        /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /goto :NextPetHeal
                        /if (${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) {
                            /if (${Debug}) {
				/echo \amDEBUG DoPetMedStuff (${SingleHeal[${j}].Arg[3,|].Find[PET]} && ${Me.Pet.PctHPs}<=${HealPct} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) \agLine#: ${Macro.CurLine}
                            }
			    /call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Med
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /call BroadCast ${IRCOn} ${EQBCOn} o "${Heals[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} <<"
                                /varcalc PetHealTimer${j} (${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration.TotalSeconds}*${DurationMod})*10
                            }
                            /varset j 1
                        }
                        :NextPetHeal
                    /next j
                    /if (${Me.Pet.ID} && ${Me.Pet.PctHPs}<100 && !${AggroTargetID}) {
                        /delay 1s
                        /goto :WaitingOnPetHealth
                    }
                }  
            }             
        }
        /if (${Debug}) /echo \atDEBUG DoWeMed Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckBuffs
| -------------------------------------------------------------------------------------
    Sub CheckBuffs
        /if (!${BuffsOn}) /return
        /if (${IAmDead}) /return
        /if (${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) {
		/return
	}
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs CheckBuffs: Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare k int local
        /declare l int local
        /declare FullText string local 0
        /declare 1stPart string local 0
        /declare 2ndPart string local 0
        /declare 3rdPart string local 0
        /declare 4thPart string local 0
        /declare 5thPart string local 0
        /declare SpellRange int local
        /declare MATargetID int local
        /declare BookSpellTT string local 0
        /declare BuffSub string local
        /declare bDoMGB int local 0

        /if (${PowerSource.NotEqual[NULL]} && ${Bool[${Me.Inventory[powersource].Name.Length}]} && !${Me.Inventory[powersource].Power} ) {
           /call CheckCursor
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /if (${Cursor.Name.Equal[${PowerSource}]}) /destroy
           /delay 5s ${Cursor.Equal[Null]}
        }
	    /if (${MountOn} && !${Me.Mount.ID} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]}) && ${Me.CombatState.NotEqual[COMBAT]}) {
			|/echo time to mount up! Zone.Outdoor is ${Zone.Outdoor}
			/call CastMount
		}
        | Call Buffs Array
        /for i 1 to ${Buffs.Size}
	    /varset bDoMGB 0
	    /doevents
            /if (${ChaseAssist} && !${CombatStart}) /call DoWeMove "CheckBuffs"
            /if (${HealsOn}) /call CheckHealth
            /if (${AutoRezOn}) /call RezCheck
            | If Buffs=NULL skip to next buff
            /if (${Buffs[${i}].Equal[null]} || ${Buffs[${i}].Arg[3,|].Equal[0]} || ${Buffs[${i}].Arg[2,|].Equal[0]}) /goto :SkipBuff
            | Check for combat and skip redundant subs called in combat routines.
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Buff${i}: ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to the buff
            /if (${Buffs[${i}].Arg[2,|].Length}) {
                /varset FullText ${Buffs[${i}]}
                /varset 1stPart ${Buffs[${i}].Arg[1,|]}
                /varset 2ndPart ${Buffs[${i}].Arg[2,|]}
                /varset 3rdPart ${Buffs[${i}].Arg[3,|]}
                /varset 4thPart ${Buffs[${i}].Arg[4,|]}
                /varset 5thPart ${Buffs[${i}].Arg[5,|]}
                /if (${2ndPart.Equal[Dual]} && ${4thPart.Equal[MA]}) {
			/varset 2ndPart DualMA
		}
                /if (${2ndPart.Equal[Dualmgb]}) {
			/varset bDoMGB 1
			/varset 2ndPart Dual
		} else /if (${2ndPart.Equal[mgb]}) {
			/varset bDoMGB 1
		}
            } else {
                /varset 1stPart ${Buffs[${i}]}
                /varset 2ndPart 
                /varset 3rdPart 
                /varset 4thPart 
            }
            /if (${Me.Subscription.NotEqual[gold]} && ${Select[${2ndPart},Dual,DualMA]}==0) {
                /if (${1stPart.Find[ Rk.]}) {
                    /varset BuffSub ${1stPart.Left[${Math.Calc[${1stPart.Find[ Rk.]}-1]}]} 
                } else {
                    /varset BuffSub ${1stPart}
                }
            } else {
                /varset BuffSub ${1stPart} 
            }
            /if (${DebugBuffs}) {
		/echo \atDEBUGBUFFS CheckBuffs 1st:${1stPart} 2nd: ${2ndPart} 3rd: ${3rdPart} 4th: ${4thPart} \agLine#: ${Macro.CurLine}
            }
	    /if (${Me.Book[${1stPart}]}) /varset  BookSpellTT ${Spell[${Me.Book[${Me.Book[${1stPart}]}].ID}].TargetType}
            /if ((${BookSpellTT.Find[0]} && ${Spell[${1stPart}].TargetType.Find[Group v]}) || ${BookSpellTT.Find[Group v]})  /varset SpellRange ${Spell[${1stPart}].AERange}
            /if (${Spell[${1stPart}].TargetType.Find[Group v]})  /varset SpellRange ${Spell[${1stPart}].AERange}
            /if (!${SpellRange}) /varset SpellRange 100
            /if (${DebugBuffs}) {
		/echo \atDEBUGBUFFS CheckBuffs ${i} 1st: ${1stPart} 2nd: ${2ndPart} FullText: ${Buffs[${i}]} Type: ${Spell[${1stPart}].TargetType} ReadBuffsTimer: ${ReadBuffsTimer} IniNextTimer: ${IniNextTimer} \agLine#: ${Macro.CurLine}
            }
	    | Added Conditions Check
            /if (${ConditionsOn} && ${BuffsCOn} && ${If[${BuffsCond[${i}]},0,1]}) /goto :SkipCheckIni
            | Check for Mana/End AA Regen on others
            /if (${Group} && ${Select[${2ndPart},Endgroup,Managroup]}>0) {
                /if (${2ndPart.Equal[Endgroup]}) /call RegenOther "${1stPart}" Endurance ${3rdPart} 0    
                /if (${2ndPart.Equal[Managroup]}) /call RegenOther "${1stPart}" Mana ${3rdPart} 0
                /if (${Macro.Return.Equal[TRUE]}) /goto :SkipBuff
            } else /if (${2ndPart.Equal[mana]}) {
                /call CastWhat "${Buffs[${i}]}" ${Me.ID} Buffs
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) /goto :SkipBuff
            }
            | Combat check to skip all buffs but mana regen
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Skip if Combat:${CombatStart}  Aggro:${AggroTargetID} IDied: ${IAmDead} ReadBTimer: ${ReadBuffsTimer} 
            /if (${Me.CombatState.Equal[COMBAT]}) /goto :SkipBuff
            /if (${AggroTargetID}) /goto :SkipBuff
            /if (${CombatStart}) /goto :SkipBuff
            /if (${IAmDead}) /goto :SkipBuff
            /if (${ReadBuffsTimer}) /goto :SkipBuff
            | Remove buff from |Remove tag
            /if (${2ndPart.Equal[Remove]} && ${Me.Buff[${1stPart}].ID}) {
                /removebuff ${1stPart} 
                /goto :SkipBuff
            }            
            | If buff cost more mana than I have skip it
            /if ((${Spell[${1stPart}].Mana} || ${Spell[${Buffs[${i}]}].Mana})>${Me.PctMana}) /goto :SkipBuff
            | Check if aura is up
            /if (${2ndPart.Equal[Aura]}) {
                /call CheckAura "${1stPart}"
                /if (${Macro.Return.Equal[TRUE]}) /goto :SkipBuff
            } else /if (${2ndPart.Equal[Once]}) {
		| Check for |Once tag and turn buff off is cast is successful
                /call BuffOnce "${1stPart}" 
                /if (${Macro.Return.Equal[TRUE]}) {
                    /varset FullText ${FullText}|0
                    /echo Buffing Once with ${Buffs[${i}]}.
                    /goto :SkipBuff
                }
            } else /if (${2ndPart.Equal[End]}) {
            | Check and Cast endurance discs/AAs - 2nd wind, respite, etc
                /if (${Me.PctEndurance}<=${3rdPart} && ((${Me.CombatAbilityReady[${1stPart}]} && !${Me.ActiveDisc.ID}) || ${Me.AltAbilityReady[${1stPart}]})) /call CheckEndurance "${1stPart}" ${3rdPart} ${4thPart}
                /if (${Macro.Return.Equal[TRUE]}) /goto :SkipBuff
            } else /if (${2ndPart.Equal[Summon]}) {
            | Summon items ini example Buffs1=The Guardian's Pouch|Summon|Guardian Blade|200
                /if (${FindItemCount[=${3rdPart}]}<${4thPart}) /call SummonStuff "${1stPart}" "${3rdPart}" ${4thPart}
                /if (${Macro.Return.Equal[TRUE]}) /goto :SkipBuff
            }
            /if (${Select[${2ndPart},Aura,End,Mount,Mana,Summon]}) /goto :SkipBuff
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to buff part of spell
            /if (${Select[${2ndPart},Dual,DualMA]}) /varset Buffs[${i}] ${3rdPart}
            /if (${Select[${2ndPart},Me,MA,!MA,Caster,Melee]}) /varset Buffs[${i}] ${BuffSub}
            | Cast buffs on MA && ${Spell[${Buffs[${i}]}].TargetType.Find[self]}
            /if ((${2ndPart.Equal[MA]} || ${2ndPart.Equal[DualMA]}) && ${Spawn[=${MainAssist}].Distance}<=${SpellRange} && ${Spawn[=${MainAssist}].ID} && ${Buff${i}GM7}==0) {
                /if (${DebugBuffs}) {
			/echo \atDEBUGBUFFS Cast buffs with MA tag ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
                }
		| Check buffs in file to see if MA has buff or its blocked
                /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Blockedbuffs"].Find[${Buffs[${i}]}]}) /goto :SkipBuff
                /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Buffs"].Find[${Buffs[${i}]}]}) /goto :SkipBuff
                /varset Buffs[${i}] ${1stPart}
               | If its a group spell cast on mercs - owner
               /if (${Spawn[=${MainAssist}].Type.Equal[mercenary]} && ${Spell[${Buffs[${i}]}].TargetType.Find[group v]}) { 
                    /varset MATargetID ${Spawn[=${MainAssist}].Owner.ID}
                } else /if (${Select[${Role},hunterpettank,pettank,pullerpettank]} ) {
                    /varset MATargetID ${Me.Pet.ID}
                } else {
                    /varset MATargetID ${Spawn[=${MainAssist}].ID}
                }
                /if (${Cursor.ID}) /call CheckCursor
                /if (${DebugBuffs}) {
			/echo \atDEBUGBUFFS CheckBuffs: MA Buff /call CastWhat "${Buffs[${i}]}" ${MATargetID} Buffs \agLine#: ${Macro.CurLine}
                }
		/call CastWhat "${Buffs[${i}]}" ${MATargetID} Buffs-nomem
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs: MA Buff MacroReturn: ${Macro.Return} \agLine#: ${Macro.CurLine}
                /delay 60 !${Me.Casting.ID}
                /if (${Macro.Return.Equal[CAST_SUCCESS]} || (!${Spawn[${MainAssistType} ${MainAssist} group].ID} && ${Macro.Return.Equal[CAST_TAKEHOLD]} )) {
                    /echo Buffing MA >> ${Spawn[=${MainAssist}].CleanName} << with ${Buffs[${i}]}.
                    | For dual tag need to assign spell duration of the 3rd part 
                    /if (${Select[${2ndPart},Dual,DualMA]}) /varset Buffs[${i}] ${3rdPart}
                    /varcalc Buff${i}GM7 (${Spell[${Buffs[${i}]}].Duration.TotalSeconds}*${DurationMod})*10
                    /if (${DebugBuffs}) /echo DEBUGBUFFS CheckBuffs MA Buff Timer ${Buff${i}GM7} Line#: ${Macro.CurLine}
                    /varset WriteBuffsTimer 0
                    /call WriteBuffs
                    /goto :SkipCheckIni
                }
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components. Turning off ${Buffs[${i}]}.
                    /varset Buffs[${i}] NULL
                    /varset FullText NULL
                    /goto :SkipBuff
                }
            } 
            | Skip to next spell if Tag MA
            /if (${Select[${2ndPart},MA,DualMA]}) /goto :SkipBuff
            | Check if buff is up and if it stacks with existing buffs
            /if (${DebugBuffs}) {
		/echo \atDEBUGBUFFS CheckBuffs BuffSlot: !${Int[${Me.Buff[${Buffs[${i}]}].ID}]} SongSlot: ${Int[${Me.Song[${Buffs[${i}]}].ID}]} Stacks: ${Spell[${Buffs[${i}]}].Stacks[0]} 2nd Part: ${Select[${2ndPart},Aura,Mount,Mana,End,Summon]}<1 Tar Type: ${Spell[${Buffs[${i}]}].TargetType} \agLine#: ${Macro.CurLine}
            }
	    /if ((!${Int[${Me.Buff[${BuffSub}].ID}]} && !${Int[${Me.Song[${BuffSub}].ID}]}) && ${Spell[${Buffs[${i}]}].Stacks[0]}) {
                | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to actual spell
                /if (${2ndPart.Equal[Dual]}) {
			|/echo ${Buffs[${i}]} is dual im setting it to ${1stPart}
			|/mqp on
			/varset Buffs[${i}] ${1stPart}
		}
                /if (${DebugBuffs}) {
			/echo \atDEBUGBUFFS CheckBuffs -- 2nd asssigned: ${Buffs[${i}]} TargetType: ${Spell[${Buffs[${i}]}].TargetType} \agLine#: ${Macro.CurLine}
                }
		| If Target.Type=Group then buff self with group buff
                /if ((${BookSpellTT.Find[0]} && ${Spell[${Buffs[${i}]}].TargetType.Find[group v]}) || ${BookSpellTT.Find[group v]} ) {
                    /if (${Cursor.ID}) /call CheckCursor
			/if (${bDoMGB}) {
				:activatemgb
				/if (${Me.AltAbilityReady[Mass Group Buff]}) {
					/alt act 35
					/goto :activatemgb
				}
			}
                    /call CastWhat "${Buffs[${i}]}" ${Me.ID} Buffs-nomem
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Buffing >> ${Buffs[${i}]} <<
                        /doevents flush Worn_off
                        /varset WriteBuffsTimer 0
                        /call WriteBuffs
                        /goto :SkipCheckIni
                    }
                }
                | If Target.Type=Single then buff each party member with single buff
                /if (${DebugBuffs}) {
			/echo \atDEBUGBUFFS CheckBuffs Find 0: ${BookSpellTT.Find[0]} Spell TT: ${Spell[${Buffs[${i}]}].TargetType.Find[single]} BookTT: ${BookSpellTT.Find[single]} Medding: ${Medding} MedCombat: ${MedCombat} \agLine#: ${Macro.CurLine}
                }
		/if ((${BookSpellTT.Find[0]} && ${Spell[${Buffs[${i}]}].TargetType.Find[single]}) || ${BookSpellTT.Find[single]}) {
                /if (${Buff${i}GM0}) /varset Buff${i}GM0 0
                /if (${2ndPart.Equal[Dual]}) /varset Buffs[${i}] ${1stPart}
                    /if (${Group} && ${Me.CurrentMana}>(${Spell[${Buffs[${i}]}].Mana}*${Group})) {
                        /if (${DebugBuffs}) {
				/echo \atDEBUGBUFFS CheckBuffs Single Type Group Buff \agLine#: ${Macro.CurLine}
			}
                       /for j 0 to ${Group}
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs !${Group.Member[${j}].ID} || ${Spawn[${Group.Member[${j}]}].Distance}>=${SpellRange} || ${2ndPart.Equal[Me]} && ${j}>=1 || ${2ndPart.Equal[MA]} && ${Group.Member[${j}].ID}!=${Spawn[${MainAssistType} ${MainAssist}].ID} || ${Buff${i}GM${j}} \agLine#: ${Macro.CurLine}
                            | Check if party member is alive in zone and within spell range and spell timer does not exist
                            /if (!${Group.Member[${j}].ID} || ${Spawn[${Group.Member[${j}]}].Distance}>=${SpellRange} || ${Buff${i}GM${j}}) /goto :nextmember
                            /if (${2ndPart.Equal[Me]} && ${j}>=1) /goto :nextmember
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs 3 ${2ndPart.Equal[caster]}  ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]} ${2ndPart.Equal[Melee]} ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]} \agLine#: ${Macro.CurLine}
                            /if ((${2ndPart.Equal[caster]} && ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${2ndPart.Equal[Melee]} && ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /goto :nextmember
                            /if (${Me.CurrentMana}<${Spell[${Buffs[${i}]}].Mana}) /goto :nextmember
                            /if (${2ndPart.Equal[!MA]} && ${Group.Member[${j}].ID}==${Spawn[${MainAssistType} ${MainAssist}].ID}) /goto :nextmember
                            /if (${Cursor.ID}) /call CheckCursor
                            /if (${AggroTargetID}) /return
                            /delay 7s ${Cast.Ready[${Buffs[${i}]}]}
                            /call CastWhat "${Buffs[${i}]}" ${Group.Member[${j}].ID} Buffs-nomem
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /echo Buffing ${Buffs[${i}]} on ${Group.Member[${j}].CleanName}
                                | assisgn buff 3rd part of dual tag for actual duration
                                /if (${2ndPart.Equal[Dual]}) /varset Buffs[${i}] ${3rdPart}
                                /varcalc Buff${i}GM${j} (${Spell[${Buffs[${i}]}].Duration.TotalSeconds}*${DurationMod})*10
                                /doevents flush Worn_off
                                /varset WriteBuffsTimer 0
                                /call WriteBuffs
                                /if (${Group}==${j}) /goto :SkipCheckIni
                            }
                            :nextmember
                        /next j
                    } else /if (${Select[${2ndPart},MA,Melee,Caster]}==0) {
                        /if (${Cursor.ID}) /call CheckCursor
                        /call CastWhat "${Buffs[${i}]}" ${Me.ID} Buffs-nomem
                    }
                }
                | If Target.Type=self then buff self
                /if (!${FindItem[=${Buffs[${i}]}].ID} && ${BookSpellTT.Find[0]} && ${Spell[${Buffs[${i}]}].TargetType.Find[self]} || ${BookSpellTT.Find[self]}) {
                    /if (${DebugBuffs}) {
						/echo \atDEBUGBUFFS CheckBuffs Self Buff \agLine#: ${Macro.CurLine}
					}
                    /call CastWhat "${Buffs[${i}]}" ${Me.ID} Buffs-nomem 
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${Buffs[${i}]}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /goto :SkipBuff
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Casting ${Buffs[${i}]} on me.
                        /delay 20
                    }
                }
                | Check if buff needs pet as target ie Mage's Symbiosis line of mana buffs
                /if (${Me.Pet.ID} && (${BookSpellTT.Find[0]} && ${Spell[${Buffs[${i}]}].TargetType.Find[pet]}  || ${Select[${Spell[${Spell[${Buffs[${i}]}].ID}].Name.Arg[2,]},Symbiosis,Siphon,Simulacrum]})) {
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Self Buff that targets pet ie mage mana buff line \agLine#: ${Macro.CurLine}
                    /call CastWhat "${Buffs[${i}]}" ${Me.Pet} Buffs
                }
            }
            | If buff is an item click it
            /if (${FindItem[=${Buffs[${i}]}].Spell.Stacks[0]} && !${Int[${Me.Buff[${FindItem[=${Buffs[${i}]}].Spell}].ID}]} && ${FindItem[=${Buffs[${i}]}].Timer}==0 && ${Select[${2ndPart},Aura,Mount,Mana]}<1)  {
				|this fixes clickys that cant be cast when mounted...
				/if (${FindItem[=${Buffs[${i}]}].Spell.IllusionOkWhenMounted}) {			
					/if (${DebugBuffs}) {
						/echo \atDEBUGBUFFS CheckBuffs Items \agLine#: ${Macro.CurLine}
					}
					| Call of the wild ear fix
					/if (${Buffs[${i}].Equal[Call of the Wild]}) {
						/casting 133851 item 
						/delay 15
					} else {
						/call CastWhat "${Buffs[${i}]}" ${Me.ID} Buffs
					}
					/if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Clicking > ${Buffs[${i}]} <
				}
            }
            | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip ini check because none of these are cast on others
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${Buffs[${i}]}]}>=1 Self:${Spell[${Buffs[${i}]}].TargetType.Find[self]} \agLine#: ${Macro.CurLine}
         :SkipBuff
            /if (${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} || (${FindItemCount[=${Buffs[${i}]}]}>=1 && ${Select[${Spell[${Buffs[${i}]}].TargetType},self]}) || (${FindItemCount[${1stPart}]}>=1 && ${Select[${Spell[${3rdPart}].TargetType},self]}) || (${BookSpellTT.Find[0]} && ${Spell[${Buffs[${i}]}].TargetType.Find[self]}) || ${BookSpellTT.Find[self]} || ${BookSpellTT.Find[pet]}) /goto :SkipCheckIni
            /if (${Redguides} && !${IniNextTimer} && !${CombatStart}) /call CheckIniBuffs "${Buffs[${i}]}" ${i} ${SpellRange} "${1stPart}" "${2ndPart}" "${3rdPart}" "${4thPart}" "${BookSpellTT}"
         :SkipCheckIni
          | Reset spell vars
            /if (${2ndPart.Length}) {
                /varset Buffs[${i}] ${FullText}
                /varset FullText 0
            }
            /varset BookSpellTT 0
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs reset var ${i} ${Buffs[${i}]} \agLine#: ${Macro.CurLine}
        /next i
        /if (${PowerSource.NotEqual[NULL]} && !${Bool[${Me.Inventory[powersource].Name.Length}]} && ${FindItemCount[=${PowerSource}]}) {
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /autoinventory
        }
        /if (!${ReadBuffsTimer} && !${AggroTargetID}) /varset ReadBuffsTimer ${CheckBuffsTimer}s
        /if (${Macro.RunTime}>120 && !${IniNextTimer}) /varset IniNextTimer 30s
        |/if (${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscGem}]}) /memorize "${ReMemMiscGem}" gem${MiscGem}
        /if (${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscGem}]} && ${MiscGemRemem}) {
		/echo calling MemSpell in CheckBuffs for ${ReMemMiscGem}
		/call MemSpell "${ReMemMiscGem}" ${MiscGem}
	}
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: BuffOnce 
| -------------------------------------------------------------------------------------
    Sub BuffOnce(Oncepell)
        /if (${Me.Invis}) /return
        /declare OnceResult string local FALSE
        /call CastWhat "${Oncepell}" ${Me.ID} CheckEndurance
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset OnceResult TRUE
        }
    /return ${OnceResult}
| -------------------------------------------------------------------------------------
| SUB: CheckAura | Check if aura is up
| -------------------------------------------------------------------------------------
    Sub CheckAura(AuraSpell)
        /if (${Me.Invis}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Spell: ${AuraSpell} Enter \agLine#: ${Macro.CurLine}
        /declare AuraName string local
        /declare TempAura string local
        /declare AuraResult string local FALSE
            | Strip the Rk II/III out of the spell to check against aura window
            /if (${AuraSpell.Find[ Rk. III]}) {
                /varset AuraName ${AuraSpell.Left[-8]}
            } else /if (${AuraSpell.Find[ Rk. II]}) {
                /varset AuraName ${AuraSpell.Left[-7]}
            } else /if (${AuraSpell.Find[ Rk.II]}) {
                /varset AuraName ${AuraSpell.Left[-6]}
            } else {
                /varset AuraName ${AuraSpell}
            }
            | Correct typo from SOE in monks 55 level aura
            /if (${AuraSpell.Find[Disciple's Aura]}) /varset AuraName Disciples Aura
            | Cleric exception for Reverent Aura 
            /if (${Me.Class.Name.Equal[cleric]} && ${AuraSpell.Find[Reverent]}) /varset AuraName Reverent Aura
            | Enchanter exception for Mana Recursion Auras
            /if ( ${AuraSpell.Find[Mana Reverberation]} || ${AuraSpell.Find[Mana Repercussion]} || ${AuraSpell.Find[Mana Reiteration]}) /varset AuraName Mana Recursion Aura
            | Enchanter exception for Mana Reverberation Aura lv 100
            /if (${AuraSpell.Find[Mana Reiterate]}) /varset AuraName Mana Reiterate Aura
            /if (${AuraSpell.Find[Mana Reverberation]}) /varset AuraName Mana Rev.
            /if (${AuraSpell.Find[Mana Resurgence]}) /varset AuraName Mana Resurgence Aura
            /if (${AuraSpell.Find[Mana Repercussion Aura]}) /varset AuraName Mana Rep. Aura
            /if (${AuraSpell.Find[Runic Radiance Aura]}) /varset AuraName Runic Rad. Aura
            | Mage exceptions because aura is on pet not in aura window and other fucked up shit
            /if (${AuraSpell.Find[Arcane Distillect]}) /varset TempAura Arcane Distillect
            /if (${AuraSpell.Find[Earthen Strength]}) /varset TempAura Earthen Strength Effect
            /if (${AuraSpell.Find[Rathe's Strength]}) /varset TempAura Rathe's Strength Effect
            | Check if aura is up 4 parts - Mage | Everyone else | 2 auras cleric | 2 auras enchamter
            /if (${Select[${Me.Class.ShortName},CLR,ENC,MAG]}==0 && !${Me.Aura[1].Name.Find[${AuraName}]}) {
                /goto :FoundAura
            } else /if (${Me.Class.ShortName.Equal[MAG]} && ${Me.Pet.ID} &&  ${Me.Pet.Distance}<175 && !${TempAura.Find[effect]} && !${Me.Aura[1].Name.Find[${TempAura}]}) {
                /goto :FoundAura
            } else /if (${Me.Class.ShortName.Equal[CLR]} && ((!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.AltAbility[Spirit Mastery]}) || (!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[2].Name.Find[${AuraName}]} && ${Me.AltAbility[Spirit Mastery]}))) {
                /goto :FoundAura
            } else /if (${Me.Class.ShortName.Equal[ENC]} && ((!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.AltAbility[Auroria Mastery]}) || (!${Me.Aura[1].Name.Find[${AuraName}]} && !${Me.Aura[2].Name.Find[${AuraName}]} && ${Me.AltAbility[Auroria Mastery]}))) {
                /goto :FoundAura
            } else /return ${AuraResult}
            :FoundAura
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Aura \agLine#: ${Macro.CurLine}
                | - Mutant Bards do this
                /if (${Me.Class.ShortName.Equal[BRD]}) {
                    /if (!${Me.Gem[${AuraSpell}]} && ${Me.Book[${AuraSpell}]}) {
                        /if (${Cursor.ID}) /call CheckCursor
                        |/memorize "${AuraSpell}" gem${MiscGem}
                        /echo calling MemSpell in CheckAura for ${AuraSpell}
			/call MemSpell "${AuraSpell}" ${MiscGem}
                        /delay 15s ${Me.Gem[${MiscGem}].Name.Equal[${AuraSpell}]}
			/echo ok ${AuraSpell} is memed in CheckAura
                    }
                    /if (${Me.Book[${AuraSpell}]}) {
			/echo Going to cast ${AuraSpell} in CheckAura Gem: ${Me.Gem[${AuraSpell}]}
			/stopcast
			/stoptwist
			/delay 5s ${Me.BardSongPlaying}==FALSE
                        |/call CastWhat "${AuraSpell}" ${Me.ID} CheckAura
			/casting "${AuraSpell}"
			/call WaitCast
                        |/squelch /twist once ${Me.Gem[${AuraSpell}]}
                        |/delay 5s
			/echo casted ${AuraSpell} in CheckAura
                        /varset AuraResult TRUE
                        /return ${AuraResult}
                    }
                }
                | - Normal casting
                /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]} && ${Me.CurrentEndurance}>500) {
                    /disc ${AuraSpell}
                    /delay 50
                    /varset AuraResult TRUE
                    /return ${AuraResult}
                } else {
                   /call CastWhat "${AuraSpell}" ${Me.ID} CheckAura
                }
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting Aura >> ${AuraSpell} <<
                    /varset AuraResult TRUE
                }
    /return    ${AuraResult}
| -------------------------------------------------------------------------------------
| SUB: CheckEndurance
| -------------------------------------------------------------------------------------
    Sub CheckEndurance(ESpell,EPct,EHealth)
        /if (${Me.Invis}) /return
        /declare EndResult string local FALSE
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Enter Spell: ${ESpell} EndPct: ${EPct} HealthPct: ${EHealth} \agLine#: ${Macro.CurLine}
        /if (${EHealth.Equal[null]} || !${EHealth.Length}) /varset EHealth 0
        /if (${DebugBuffs}) /echo DEBUGBUFFS CheckAura Endurance Regen Line#: ${Macro.CurLine}
        /if (${Me.Sitting}) {
		/echo going to stand 7
		/stand
	}
        /if (${Cursor.ID}) /call CheckCursor
        /call CastWhat "${ESpell}" ${Me.ID} CheckEndurance
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset EndResult TRUE
            /echo Casting >> ${ESpell} << for endurance
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckAura Leave \agLine#: ${Macro.CurLine}    
    /return ${EndResult}
| -------------------------------------------------------------------------------------
| SUB: SummonStuff
| -------------------------------------------------------------------------------------    
    Sub SummonStuff(SSpell,SumItem,int SumNum)
        /if (${Me.Invis}) /return
        /if (${FindItemCount[=${SumItem}]}>=${SumNum}) /return
        /declare SumResult string local FALSE
        /declare SummonAttempts int local 0
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS SummonStuff Enter SSpell: ${SSpell} SumItem: ${SumItem} SumNum: ${SumNum} \agLine#: ${Macro.CurLine}
        /if (${FindItemCount[=${SumItem}]}<${SumNum}) {
            :summonagain
                /if (${Twist}) /multiline ; /squelch /twist off ; /varset Twisting 0
                /if (${Me.FreeInventory}==0) {
                    /echo No room in inventory skipping summoning >> ${SumItem} <<.
                    /goto :summondone
                }
                | Summon axes for zerkers had to be hard coded because spell is same name as tm item summoned.
                /if (${Select[${Me.Class.ShortName},BER]} && ${SSpell.Find[axe]}) {
                    /docommand /disc ${SSpell}
                    /delay 80 ${Cursor.ID}
                    /varcalc SummonAttempts ${SummonAttempts}+1
                    /goto :inventory
                }
                | Summon stuff
                /if (!${Select[${Me.Class.ShortName},BER]} && !${SSpell.Find[axe]}) {
                    | Check if isummoning from an item
                    /if (${FindItemCount[=${SSpell}]} > 0) {
                        | Check if item is ready to cast
                        /if (${FindItem[=${SSpell}].Timer}!=0) {
                            /if (${DebugBuffs}) /echo \atDEBUGBUFFS ${SSpell} not ready yet skipping \agLine#: ${Macro.CurLine}
                            /varset SumResult FALSE
                            /return ${SumResult}
                        }
                    }
                    /if (${Cursor.ID}) /call CheckCursor
                    /call CastWhat "${SSpell}" ${Me.ID} SummonStuff-nomem
                }
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs summon item cast result ${Macro.Return} \agLine#: ${Macro.CurLine}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    :inventory
                    /delay 15s ${Cursor.ID}
                    /if (${Cursor.ID}) {
                        /echo Summoned  >> ${SumItem} <<
                        /varcalc SummonAttempts ${SummonAttempts}+1
                        /call CheckCursor
                    }
                    /if (${FindItemCount[=${SumItem}]}==0 && ${SummonAttempts}>0) {
                        /echo Summoning >> ${SumItem} << Failed - Check reagents, timer, etc
                        /echo -- Turning off ${SSpell} - ${SSpell}|Summon|${SumItem}|0
                        /varset SummonAttempts 0
                        /varset SumResult TRUE
                        /goto :summondone
                    }
                }
            /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                /echo You are missing components. Turning Off ${  }.
                /varset SumResult FALSE
                /return ${SumResult}
            }
            /if (${FindItemCount[=${SumItem}]}<${SumNum} && ${SummonAttempts}>=5) /goto :summonagain
            :summondone
            /echo I now have ${FindItemCount[=${SumItem}]}/${SumNum} of >> ${SumItem} <<
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS SummonStuff Leave \agLine#: ${Macro.CurLine}    
    /return ${SumResult}
| -------------------------------------------------------------------------------------
| SUB: CheckIniBuffs
| -------------------------------------------------------------------------------------
    Sub CheckIniBuffs(BuffName, BuffsNum, int BuffRange, 1stPart, 2ndPart, 3rdPart, 4thPart)
        /if (${DebugBuffs}) {
		/echo \atDEBUGBUFFS CheckIniBuffs Enter ${BuffName} ${BuffsNum} ${BuffRange} ${1stPart} ${2ndPart} ${3rdPart} ${4thPart} \agLine#: ${Macro.CurLine}
        }
	/declare k int local
        /declare l int local
        | Assign var IniIDList all the spawn ids from buff ini file 2345|2195|2391| etc
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        /declare IniBuffCount int local 0
        /declare IniBBuffList string local
        /declare IniBuffList string local
        /declare IniStackCheck[50] string local
        /declare PBTimerID int local
        /declare IniTempBuff string local
        | Check Buffs from ini
        /if (${Redguides}) {
            | IniIDCount = number of Char IDs counted in ini file. If 0 skip or Buff is null the the process.
            /if (${IniIDCount}<=0 || ${BuffName.Equal[null]}) /return
            | Start scan of buffs listed on toons in ini file
            /for k 1 to ${IniIDCount}
                /if (${AggroTargetID}) /return
                | If the Spawn ID is not in the zone and not a PC/merc and not me skip to next ID
                /if (!${Spawn[${IniIDList.Arg[${k},|]}].ID} || ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Type},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,NPC,TRIGGER,TRAP,TIMER,MOUNT]} || ${IniIDList.Arg[${k},|]}==${Me.ID}) /goto :NextCharCheck
                | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip because none of these are cast on others
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${BuffName}]}>=1 Self:${Spell[${BuffName}].TargetType.Find[self]} \agLine#: ${Macro.CurLine}
                | Set buff to correct spell to check for with Dual tag
                /if (${2ndPart.Equal[Dual]}) {
                    /if (${Select[${Spell[${3rdPart}].TargetType},self]})  {
                        /goto :NextCharCheck
                    } else {
			/varset BuffName ${3rdPart}
		    }
                }
                | If buff marked MA skipped if spawn ID isn't MA
                /if (${2ndPart.Equal[MA]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.NotEqual[${MainAssist}]} || ${2ndPart.Equal[!MA]} && ${Spawn[${IniIDList.Arg[${k},|]}].CleanName.Equal[${MainAssist}]}) /goto :NextCharCheck
                /if ((${2ndPart.Equal[Caster]} && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${2ndPart.Equal[Melee]} && ${Select[${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /goto :NextCharCheck
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 1.1: 2ndPart: ${2ndPart} Class Name: ${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName} \agLine#: ${Macro.CurLine}
                | Temp variable to store buff name after stripping rk stuff makes it easier to compare
                /varset IniTempBuff ${BuffName}
                /if (${BuffName.Find[ Rk. III]}) /varset IniTempBuff ${BuffName.Left[-8]}
                /if (${BuffName.Find[ Rk. II]})  /varset IniTempBuff ${BuffName.Left[-7]}
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 2: ${Spawn[${IniIDList.Arg[${k},|]}].Name} ${IniIDList.Arg[${k},|]} ${IniTempBuff} ${BuffName} \agLine#: ${Macro.CurLine}
                | Assign var IniBBuffList blocked buffs list from ini file
                /varset IniBBuffList ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"Blockedbuffs"]}
                | If the current buff is on the blocked buff list skip it.
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 3: ${IniBBuffList.Find[${IniTempBuff}]} Buff blocked? \agLine#: ${Macro.CurLine}
                /if (${IniBBuffList.Find[${IniTempBuff}]}) /goto :NextCharCheck
                | Assign var IniBuffList buffs list from ini file
                /varset IniBuffList ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"Buffs"]}
                | If current buff is on the buff list skip it
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 4: ${IniTempBuff} ${IniBuffList.Find[${IniTempBuff}]} \agLine#: ${Macro.CurLine}
                /if (${IniBuffList.Find[${IniTempBuff}]}) /goto :NextCharCheck
                | Assign buff count
                /varset IniBuffCount ${Math.Calc[${IniBuffList.Count[|]}]}
                | Check if current buff stacks will all existing buffs in list
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs  IniBuffCheck 5: ${Spawn[${IniIDList.Arg[${k},|]}].Name} ${IniBuffCount} BuffsNum ${BuffName} \agLine#: ${Macro.CurLine}
                /for l 1 to ${IniBuffCount}
                    | Fix for stacking issues with Perfected Group Levitation there are a lot
                    /if (${IniBuffList.Arg[${l},|].Find[Group Perfected Levitation]} && !${BuffName.Find[Group Perfected Levitation]}) /goto :PGLevFix
                    /if (${Select[${Spell[${IniBuffList.Arg[${l},|]}].WillStack[${BuffName}]},TRUE,FALSE,NULL]}>=2) {
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck Stack: ${IniBuffList.Arg[${l},|]} !Stack ${BuffName} ${Select[${Spell[${IniBuffList.Arg[${l},|]}].WillStack[${BuffName}]},TRUE,FALSE,NULL]} \agLine#: ${Macro.CurLine}
                        /goto :NextCharCheck
                    }
                    :PGLevFix
                /next l
                | If buff has dual tag assign current buff to spell that needs to be cast
                /if (${2ndPart.Equal[Dual]}) /varset BuffName ${1stPart}
                | varset ini buff timer toon Id spell Id to shorten var and clarity
                /varset PBTimerID ${IniIDList.Arg[${k},|]}${Spell[${BuffName}].ID}
                | Define timer for spell i am about to cast
                /if (!${Defined[IniBuffTimer${PBTimerID}]}) /declare IniBuffTimer${PBTimerID} timer outer 0
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 6: ${Spawn[${IniIDList.Arg[${k},|]}].Name} Temp:${IniTempBuff} OnList:${IniBuffList.Find[${IniTempBuff}]} Timer:${IniBuffTimer${PBTimerID}} \agLine#: ${Macro.CurLine}
                | Check if toon is within spell range and cast buff
                /if (${Spawn[${IniIDList.Arg[${k},|]}].Distance}<=${BuffRange} && !${IniBuffTimer${PBTimerID}}) {
                    /if (${Spell[${BuffName}].TargetType.Equal[self]} && ${Spawn[${IniIDList.Arg[${k},|]}].ID}!=${Me.ID}) {
                        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs tried to buff ${Spawn[${IniIDList.Arg[${k},|]}].CleanName} with a self buff
                        /goto :NextCharCheck
                    }
                    /call CastWhat "${BuffName}" ${IniIDList.Arg[${k},|]} Buffs
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 7: /call CastWhat "${BuffName}" ${IniIDList.Arg[${k},|]} Buffs ${Macro.Return} \agLine#: ${Macro.CurLine}
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Buffing >> ${BuffName} << on ${Spawn[${IniIDList.Arg[${k},|]}].CleanName}
                        /varset IniBuffTimer${PBTimerID} 60s
                        /varset IniNextTimer 0
                        /doevents flush Worn_off
                        /varset WriteBuffsTimer 0
                        /call WriteBuffs
                    }
                }
                /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckINIBuffs IniBuffCheck 8: IniBuffTimer${PBTimerID}:${IniBuffTimer${PBTimerID}} IniNextTimer:${IniNextTimer} \agLine#: ${Macro.CurLine}
                :NextCharCheck
                /if (${2ndPart.Equal[Dual]}) /varset BuffName ${3rdPart}
            /next k
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckIniBuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: RegenOther
| ----------------------------------------------------------------------------
    Sub RegenOther(RGName, Stat, int StatPct, RegonOnClasses)
    | Casting on others during combat will interrupt fast med
    /if (${Medding} && ${MedCombat}) /return
    /if (${Me.Invis}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Enter \agLine#: ${Macro.CurLine} ${RGName} ${Stat} ${StatPct} ${RegonOnClasses} \agLine#: ${Macro.CurLine}
        /declare i int local 
        /declare ROResult string local FALSE
        /if (${RegonOnClasses.Equal[0]} || ${RegonOnClasses.Equal[null]}) {
            /if (${Stat.Equal[endurance]}) {
                /varset RegonOnClasses BER,BST,MNK,PAL,RNG,ROG,SHD,WAR
            }
            /if (${Stat.Equal[mana]}) {
                /varset RegonOnClasses BRD,BST,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHD,SHM,WIZ
            }
        }
        /for i 1 to 5 
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Class: ${Group.Member[${i}].Class.ShortName} AggroID: ${AggroTargetID}  GrpMemPct: ${Group.Member[${i}].Current${Stat}}<=${StatPct} GrpMemID: ${Group.Member[${i}].ID}  \agLine#: ${Macro.CurLine}        
            | If bard rallying call aa skip tank or he won't attack
            /if (${RGName.Find[Rallying Call]} && ${Group.Member[${i}].ID}==${Spawn[${MainAssist} ${MainAssistType}].ID}) /goto :NextGMember 
            | Bard Dichotomic uses endurance not mana
            /if  (${RGName.Find[Dichotomic Psalm]} && ${Me.CurrentEndurance}<6700) /goto :NextGMember 
            | Dichotomic Psalm & Quiet Miracle do not work on bards
            /if (${Group.Member[${i}].Class.Name.Equal[bard]} && (${RGName.Equal[Dichotomic Psalm]} || ${RGName.Equal[Quiet Miracle]})) /goto :NextGMember
            /if (${Select[${Group.Member[${i}].Class.ShortName},${RegonOnClasses}]} && !${AggroTargetID} && ${Group.Member[${i}].Current${Stat}}<=${StatPct} && ${Group.Member[${i}].Current${Stat}}>=1 && ${Group.Member[${i}].ID}) {            
                /call CastWhat "${RGName}" ${Group.Member[${i}].ID} Regenother
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting ${RGName} on ${Group.Member[${i}].CleanName} for ${Stat}.
                    /varset ROResult TRUE
                    /return ${ROResult}
                }
            }
            :NextGMember              
        /next i
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS RegenOther Leave \agLine#: ${Macro.CurLine}
    /return    ${ROResult}    
| -------------------------------------------------------------------------------------
| SUB: Target Window Buffs
| -------------------------------------------------------------------------------------     
    Sub TargetWinBuffs(int TWtargetID,Checkbuff,FromSub)
        /if (!${Checkbuff.Length} || ${Spawn[TWtargetID].ID}) /return
        /declare i int local
        /for i 0 to 50
            /if (${Window[TargetWindow].Child[Target_Buff${i}_Button].Tooltip.Find[${Checkbuff}]}) {
            /echo ${Target.CleanName} has ${Checkbuff} skipping to next buff
                /if (${FromSub.Equal[CastWhat]}) /call Interrupt
                /return TRUE 
            }
        /next i
    /return 
| -------------------------------------------------------------------------------------
| SUB: PetStateCheck
| -------------------------------------------------------------------------------------
Sub PetStateCheck 
    /if (${DebugPet}) /echo Checking Pet State. \agLine#: ${Macro.CurLine}
    /if (${Me.AltAbility[Suspended Minion]}>0) {    
        :CastSusMin
        /if (${Me.AltAbilityReady[Suspended Minion]}) {
            /casting "Suspended Minion" alt
            /delay 5s !${Me.Casting.ID}
            /doevents
        } else {
            /echo Waiting on Suspend Minion AA to be ready.
            /delay 10
            /goto :CastSusMin
        }
   } else {
        /echo You do not have the "Suspended Minion" AA, PetSuspend being turned off.
        /varset PetSuspend 0    
    }
    /if (${Me.Pet.ID}) /varset PetActiveState  1
/return

| -------------------------------------------------------------------------------------
| SUB: DoPetStuff
| -------------------------------------------------------------------------------------
    Sub DoPetStuff
        | /if (!${PetOn} || ${AggroTargetID} || ${Me.Invis} || ${Me.Hovering}) /return
        /if (!${PetOn}) /return
        /if (${AggroTargetID}) /return
        /if (${Me.Invis}) /return
        /if (${Me.Hovering}) /return
        /declare PetSummonTimer timer local 60s
        /doevents
        /if (${Debug}) /echo \atDEBUG DoPetStuff Enter \agLine#: ${Macro.CurLine}
        /declare FocusCurrent string local ${InvSlot[${PetFocus.Arg[2,|]}].Item.Name}
        /declare FocusSlot string local ${PetFocus.Arg[2,|]} ${PetFocus.Arg[1,|]}
        /declare FocusPet string local ${PetFocus.Arg[1,|]}
        /declare FocusSwitch int local 0
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]}) /pet get lost
        | Swap pet focus in pet cast
        /if (!${Me.Pet.ID} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
            | verbose
            /echo I have no pet. ${Me.Class}s live longer when we have pets.
            /varset PetActiveState 0
            /if (${PetFocus.Arg[1,|].Length} && ${FindItemCount[=${FocusPet}]}) {
                /if (!${Cursor.ID} && ${FocusPet.NotEqual[${FocusCurrent}]}) {
                    /call CheckCasting 50
                    /exchange "${FocusPet}" ${FocusSlot}
                    /varset FocusSwitch 1
                    /delay 10
                }
            }
            /doevents
            /delay 3
            | Pet spell mem check - Else try item like mage epic
            /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff
            | Summon Pet
            |- If using suspended pet function.
            /if (${PetSuspend}) {
               |- If I have a suspended pet bust him out!
               /if ((${PetTotCount}==1) && (${PetActiveState}==0) && (${PetSuspendState}==1)) {
                   /echo I have a suspended pet, summoning it now!
                   /call PetStateCheck           
               }
               |- If I don't have a suspended or an active pet, make them.
               /if (${PetTotCount}<2 && ${PetSuspendState}==0 && ${PetActiveState}==0 && ${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
                    :MakeMyPet1
                    /echo - Making pet now.
                    /echo ARISE ${PetSpell}
                    /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components to make this pet. Ending macro.
                        /end
                    } 
                    /delay 10s !${Me.Casting.ID}
                    /delay 1s ${Me.Pet.ID}            
                    /if (!${Me.Pet.ID} && ${PetSummonTimer}) {
                        /goto :MakeMyPet1
                    } else {                
                        /if (${Me.Pet.ID})  /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                        /varset PetActiveState 1
                        /call CheckPetBuffs
                        /if (${Me.Pet.ID} && ${PetToysOn}) {
                            /call PetToys ${Me.Pet.CleanName}
                            /if ((${PetSuspendState}==0) && (${PetActiveState}==1)) /varset PetToysDone 0
                            /if ((${PetSuspendState}==1) && (${PetActiveState}==1)) /varset PetToysDone 1
                        }
                    }
                    /call PetStateCheck
                    /if (${PetTotCount}<2 && ${PetSuspendState}==1 && ${PetActiveState}==0  && ${PetSummonTimer}) /goto :MakeMyPet1
                }
            } else /if (${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
                | Normal pet function for not using suspend pet.
                :MakeMyPet2
                /echo ARISE ${PetSpell}
                /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff
                /delay 10s !${Me.Casting.ID}
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components to make this pet. Ending macro.
                    /end
                } 
                /delay 1s ${Me.Pet.ID}
                /if (!${Me.Pet.ID}  && ${PetSummonTimer}) {
                    /goto :MakeMyPet2
                } else {                
                    /if (${Me.Pet.ID})  /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                    /varset PetActiveState 1                
                }
                | Swap pet focus out for regular item
                /if (${FocusSwitch} && !${Cursor.ID}) {
                    /call CheckCasting
                    /exchange "${FocusCurrent}" ${FocusSlot}
                    /delay 10
                }            
            }
            | Reset PetToysGave in config after pet creation, as well as memory variable so we will pickup if our pet needs toys after death, under new condition checks.
            /ini "${IniFileName}" "Pet" "PetToysGave" ""
            /if (${Me.Pet.ID} && ${PetToysOn}) /varset PetToysGave "NULL"
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]} && ${Me.Pet.Distance}>${CampRadius}) /pet follow
            /if (${PetHoldOn}) /pet ${PetHold} on      
            /if (${Me.AltAbility[Pet Discipline]}>5) /pet focus on
            /if (!${PetTauntOn} && ${Select[${Role},pettank,pullerpettank]}) /pet taunt on
        }
        /call CheckPetBuffs
        | Pet Toy routines
        | Condition revised to only call PetToys if I do not have my pet name in the PetToysGave string.
        /if (${Me.Pet.ID} && ${PetToysOn} && !${PetToysGave.Find[${Me.Pet.CleanName}]}) /call PetToys ${Me.Pet.CleanName}
        | Check to have pet come to owner if owner out of camp too long.
        /if (${Select[${Role},pettank,hunterpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) && ${Me.Pet.Stance.Equal[GUARD]}) /pet follow
        |/if (${Me.Pet.ID} && ${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscGem}]}) /memorize "${ReMemMiscGem}" gem${MiscGem}
        /if (${Me.Pet.ID} && ${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscGem}]}) /call MemSpell "${ReMemMiscGem}" ${MiscGem}
        /if (${Debug}) /echo \atDEBUG DoPetStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckPetBuffs
| -------------------------------------------------------------------------------------
Sub CheckPetBuffs
        /if (!${Me.Pet.ID}) /return
        /if (!${PetOn}) /return
        /if (!${PetBuffsOn}) /return
        /if (${CombatStart}) /return
        /if (${Pulling}) /return
        /if (${PetBuffCheck}) /return
        /if (${Me.Invis}) /return
        /if (${Debug}) /echo \atDEBUG CheckPetBuffs Enter \agLine#: ${Macro.CurLine}
        /declare PTempBuff string local
        /declare i int local
        /declare j int local
        /declare 1stPart string local 0
        /declare 2ndPart string local 0
        /declare 3rdPart string local 0                
        /declare FoundPetBuff int local 0
        /varset PetBuffCheck 60s
        /for i 1 to ${PetBuffs.Size}
            /doevents
            | Stop pet buffing if aggro detected
            /if (${AggroTargetID}) /return
            /if (${PetBuffs[${i}].Equal[Null]}) /goto :SkipPetBuff
            | Check for pet spells in book to prevent double casting of items
            /if (${Me.Book[${PetBuffs[${i}]}]} || ${Me.AltAbilityReady[${PetBuffs[${i}]}]}) {
                /varset PTempBuff ${PetBuffs[${i}]}
                /if (${PetBuffs[${i}].Find[ Rk. III]}) /varset PTempBuff ${PetBuffs[${i}].Left[-8]}
                /if (${PetBuffs[${i}].Find[ Rk. II]}) /varset PTempBuff ${PetBuffs[${i}].Left[-7]}
                /if (${Debug}) /echo \atDEBUG CheckPetBuffs ${i} ${Me.PetBuff[${PTempBuff}]} ${PetBuffs[${i}]} ${PTempBuff} \agLine#: ${Macro.CurLine}
                /for j 1 to 50
                    /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) /varset FoundPetBuff 1
                /next j
                /if (!${FoundPetBuff}) {
                    | Vebrose
                    /call CastWhat "${PetBuffs[${i}]}" ${Me.Pet.ID} Pet-nomem
                    /delay 20
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Buffing ${Me.Pet.CleanName}, my pet, with ${PetBuffs[${i}]}
                    /varset FoundPetBuff 0
                    /goto :SkipPetBuff
                }
            }
            /if (${Debug}) /echo \atDEBUG CheckPetBuffs ${FindItem[=${PetBuffs[${i}]}].Spell} ${Me.PetBuff[${FindItem[=${PetBuffs[${i}]}].Spell}]} \agLine#: ${Macro.CurLine}
            /if (${Me.PetBuff[${FindItem[=${PetBuffs[${i}]}].Spell}]}>=1) /goto :SkipPetBuff
            |- Cast item clicky buff (ItemName and PetBuff = DIFFERENT)
            |--- START: Multipart handling for PetBuffs.
            /if (${PetBuffs[${i}].Find[|]}) {            
                /varset 1stPart ${PetBuffs[${i}].Arg[1,|]}
                /varset 3rdPart ${PetBuffs[${i}].Arg[3,|]}
                /varset PTempBuff ${3rdPart}
                |--- START: DUAL Handle for different Effect names versus their Item name
                /if (${Debug}) /echo \atDEBUG CheckPetBuffs - Dual - ${1stPart} - ${3rdPart} \agLine#: ${Macro.CurLine}
                /if (${PetBuffs[${i}].Arg[2,|].Equal[Dual]}) {
                    /if (${FindItem[=${1stPart}].ID}) {
                        /for j 1 to 50
                             /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) /varset FoundPetBuff 1
                        /next j
                        /if (!${FoundPetBuff}) {
                            |Vebrose
                            /call CastWhat "${1stPart}" ${Me.Pet.ID} Pet
                            /delay 20
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Buffing ${Me.Pet.CleanName}, my pet, with (${3rdPart})
                            /varset FoundPetBuff 0        
                            /goto :SkipPetBuff
                        }
                    }
               }
               |--- END: DUAL Handle for different Effect names versus their Item name                
            }
            |--- END: Multipart handling for PetBuffs.

            |- Cast item clicky buff (ItemName and PetBuff = SAME)
            /if (${FindItem[=${PetBuffs[${i}]}].ID}) {
                /call CastWhat "${PetBuffs[${i}]}" ${Me.Pet.ID} Pet
                /call CheckCasting 75
            }
            :SkipPetBuff
            /varset FoundPetBuff 0
        /next i
    /if (${Debug}) /echo \atDEBUG CheckPetBuffs Pet Height: ${Me.Pet.Height} \agLine#: ${Macro.CurLine}
    /if (${Me.Pet.Height}>1.35 && ${PetShrinkOn}) {
        /call CastWhat "${PetShrinkSpell}" ${Me.Pet.ID} Pet
        /delay 20
    }
    /if (${Target.ID}==${Me.Pet.ID}) /squelch /target clear
    /if (${Debug}) /echo \atDEBUG CheckPetBuffs Leave \agLine#: ${Macro.CurLine}
/return
| ----------------------------------------------------------------------------
| SUB: Check PetToys - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub PetToys(string petName)
        /if (!${Me.Pet.ID}) /return
        /if (${DebugPet}) /echo \atDEBUGPet PetToys Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare GrabItem int local 0
        /declare PetToySpell string local 0
        /declare FullText string local
        /declare 2ndPart string local
        /declare 3rdPart string local
        /declare PetToysTemp string local ${Ini[${IniFileName},Pet,PetToysGave]}
        /declare GaveItem int local 1
        /call OpenInvSlot
        /declare petID int local ${Spawn[pet ${petName}].ID}
        /if (${BagNum}==0) {
            /echo You must have an empty Top Inventory slot for Pet Toys to work.
            /varset PetToysOn 0
            /return
        }
        /if (!${InvSlot[pack${BagNum}].Item.Container} && !${Me.FreeInventory}) {
            /echo Inventory is full
            /varset PetToysOn 0
            /return
        }
        | reset if different pet name only on my pet
        /if (!${PetToysTemp.Find[${petName}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
            /ini "${IniFileName}" "Pet" "PetToysGave" "0"
            /varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
        }
        /for i 1 to ${PetToys.Size}
        /if (${DebugPet}) /echo CHECKING: ${PetToys[${i}]} \agLine#: ${Macro.CurLine}
            /if (${DebugPet}) {
                /echo \atDEBUGPET PetToys 1: ${PetToys[${i}]} \agLine#: ${Macro.CurLine}
                /echo \atDEBUGPET PetToys 2: ${PetToysTemp} \agLine#: ${Macro.CurLine}
                /echo \atDEBUGPET PetToys 3: ${PetToys[${i}].Equal[Null]} || ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]} \agLine#: ${Macro.CurLine}
            }
            | Had to add pet name check else it will always skip giving weapons to OTHER pets.                        
            /if (${PetToys[${i}].Equal[Null]} || (${Me.Pet.CleanName.Equal[${petName}]} && ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]})) /goto :SkipPetToy
            | Are we handing weapons to the pet
            /if (${PetToys[${i}].Arg[2,|].Length}) {
                /varset FullText ${PetToys[${i}]}
                /varset PetToySpell ${PetToys[${i}].Arg[1,|]}
                /varset 2ndPart ${PetToys[${i}].Arg[2,|]}
                /varset 3rdPart ${PetToys[${i}].Arg[3,|]}
            } else {
                /varset PetToySpell ${PetToys[${i}]}
            }
            /if (${Me.Pet.CleanName.Equal[${petName}]} && ((${2ndPart.Length} && ${PetToysTemp.Find[${2ndPart}1]}) || (${3rdPart.Length} && ${PetToysTemp.Find[${3rdPart}2]}))) /goto :SkipPetToy
            | Check for pet toy spells in book to prevent double casting of items
            /if (${Me.Book[${PetToySpell}]}) {
                /call CastWhat "${PetToySpell}" ${Me.ID} Pet-nomem
                /if (!${PetToysTemp.Find[${petName}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
                    /ini "${IniFileName}" "Pet" "PetToysGave" "${petName}"
                    /varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
                }
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting pet toy spell >> ${PetToySpell} <<
                }

                /delay 15s ${Cursor.ID}
                /if (!${Cursor.ID}) /return
                | Check if spell has summoned a bag or folded pack
                /if (${Cursor.Container} || ${Cursor.Name.Find[Folded]}) {
                    | If item is in Inv Slot exchange it with bag on cursor
                    /if (${InvSlot[pack${i}].Item.ID}) /nomodkey /itemnotify pack${BagNum} leftmouseup
                    :Unfolded
                    /delay 2s ${Cursor.ID}
                    | Drop exchanged item into inventory
                    /autoinventory
                    /delay 1s
                    | If folded pack right click to convert to phantom satchel
                    /if (${InvSlot[pack${BagNum}].Item.Name.Find[folded]}) {
                        /nomodkey /itemnotify pack${BagNum} rightmouseup
                        /echo Opening ${InvSlot[pack${BagNum}].Item.Name}
                        /delay 3s
                        | Return to top to drop bag into inventory
                        /goto :Unfolded
                    }
                }
                /if (${InvSlot[pack${BagNum}].Item.Container} && (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]})) {
                    | Open the bag
                    /nomodkey /itemnotify pack${BagNum} rightmouseup
                    /delay 10
                    /if (${DebugPet}) /echo \atDEBUGPET PetToys ${i} ${PetToySpell} ${2ndPart} ${3rdPart} \agLine#: ${Macro.CurLine}
                    | Condition revised to allow for pet weapons to be given to other people's pets.
                    /if (((${Me.Pet.CleanName.Equal[${petName}]} && !${PetToysTemp.Find[${2ndPart}1]}) && ${2ndPart.Length} && ${FindItemCount[=${2ndPart}]}) || (!${Me.Pet.CleanName.Equal[${petName}]} && ${2ndPart.Length} && ${FindItemCount[=${2ndPart}]})) {
                        /call GiveTo "${2ndPart}" ${petID}
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}1
                        /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                    | Condition revised to allow for pet weapons to be given to other people's pets.
                    /if (((${Me.Pet.CleanName.Equal[${petName}]} && !${PetToysTemp.Find[${3rdPart}2]}) && ${3rdPart.Length} && ${FindItemCount[=${3rdPart}]}) || (!${Me.Pet.CleanName.Equal[${petName}]} && ${3rdPart.Length} && ${FindItemCount[=${3rdPart}]})) {                  
                        /call GiveTo "${3rdPart}" ${petID}
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${3rdPart}2
                        /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                    /if (!${2ndPart.Length}) {
                        /for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
                            /if (${InvSlot[pack${BagNum}].Item.Item[${j}].ID} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
                                /call GiveTo "${InvSlot[pack${BagNum}].Item.Item[${j}].Name}" ${petID}
                            }
                            /delay 10
                        /next j
                        /if (${j}>=8 && !${PetToysTemp.Find[${PetToySpell}]} && ${Me.Pet.CleanName.Equal[${petName}]}) {
                            /varset PetToysTemp ${PetToysTemp}|${PetToySpell}
                            /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                        }
                    }
                }
                /if (${Cursor.Name.Find[Summoned:]}) {
                    /call GiveTo "${Cursor.Name}" ${petID}
                    /varset PetToysTemp ${PetToysTemp}|${PetToySpell}
                    /if (${Me.Pet.CleanName.Equal[${petName}]}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    /varset GaveItem 0
                }
                /if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) /call DestroyBag
                /goto :SkipPetToy
            }
        :SkipPetToy
            | Reset spell vars
            /if (${2ndPart.Length}) {
                /varset FullText
                /varset 2ndPart
                /varset 3rdPart
            }
            /if (!${PetToysOn}) /return
        /next i
        | MUST reset PetToysGave after cycle complete in order to stop calling PetToys all the time.
        /varset PetToysGave ${PetToysTemp}
        /if (${Window[InventoryWindow].Open} && !${GaveItem}) /keypress inventory
        /varset PetToysDone 1
        /if (${DebugPet}) /echo \atDEBUGPET PetToys Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check OpenInvSlot - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub OpenInvSlot
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS OpenInvSlot Enter \agLine#: ${Macro.CurLine}
        /if (${BagNum}) /return
        /declare i int local
        /varset BagNum 0
        /for i 1 to 10
            /if (${InvSlot[pack${i}].Item.Container}) /goto :NextSlot
            /if (!${InvSlot[pack${i}].Item.Container} || ${InvSlot[pack${i}].Item.ID}==0) {
                | Must have at least 2 inv slots open in order to swap bags and items
                /if (${Me.FreeInventory}>=2) /varset BagNum ${i}
            }    
            /if (${BagNum}) {
                /echo Pet Toys: Inventory slot ${i} is empty using that one.
                /delay .5
                /return
            }
            :NextSlot
        /next i
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS OpenInvSlot Leave  \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check DestroyBag - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub DestroyBag
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS DestroyBag Enter  \agLine#: ${Macro.CurLine}
        /declare j int local
        | Make sure bag has no items other than summoned in it before deleting.
        /if (${InvSlot[pack${BagNum}].Item.Items}) {
            /for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
                /if (!${InvSlot[pack${BagNum}].Item.Item[${j}].NoRent} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
                    /echo Bag has non summoned item(s) in it. Aborting delete. Pet Toys Off
                    /varset PetToysOn 0
                    /return
                }
            /next j
        }
        /if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) {
            /nomodkey /itemnotify pack${BagNum} leftmouseup
            /delay 5s ${Cursor.ID}
            /if (${Cursor.Name.Find[Phantom Satchel]} || ${Cursor.Name.Find[Pouch of Quellious]}) /destroy
            /delay 20 !${Cursor.ID}
        }
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check GiveTo - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub GiveTo(string GItem, int GTarget)
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS GiveTo Enter \agLine#: ${Macro.CurLine}
        /declare ItemSummoned int local 0
        /if (${Target.ID}!=${GTarget}) {
            /target id ${GTarget}
            /delay 2s ${Target.ID}==${GTarget}
        }
        /if (${Target.Distance}>10 && ${Target.Distance}<=${CampRadius}) {
            /moveto id ${Target.ID}
            /delay 50 ${MoveTo.Stopped}
        }
        /if (!${Cursor.ID} && ${FindItemCount[=${GItem}]}>0) {
            /shift /itemnotify "${GItem}" leftmouseup
            /delay 20 ${Cursor.ID}
        }
        :CursorFree
            /if (${Cursor.ID} && ${Cursor.NoRent} && ${Cursor.ID}==${FindItem[=${GItem}].ID}) {
                /varset ItemSummoned 1
                /nomodkey /click left target
                /delay 10
            }
        /if (${Cursor.ID} && ${Cursor.NoRent}) /goto :CursorFree
        /delay 30 ${Window[GiveWnd].Open}
            /if (${ItemSummoned} && ${Window[GiveWnd].Open}) {
                /notify GiveWnd GVW_Give_Button leftmouseup
                /echo Giving ${GItem} to ${Target.CleanName}
            } else {
                /echo Item is NOT SUMMONED canceling trade
                /notify GiveWnd GVW_Cancel_Button leftmouseup
            }
            /delay 15 
            | New pet patch gives back item if pet has equipped. Delete item from cursor.
            /if (${Cursor.ID} && ${Cursor.NoRent} && ${Cursor.ID}==${FindItem[=${GItem}].ID}) {
            :delItem
                /destroy
                /delay 10
            /if (${Cursor.ID}) /goto :delItem
        }
        /delay 200 !${Window[GiveWnd].Open}
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS GiveTo Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Check Plugin
| ----------------------------------------------------------------------------
    Sub CheckPlugin(string pluginname)
        /if (${Debug}) {
			/echo \atDEBUG CheckPlugin: Enter \agLine#: ${Macro.CurLine}
		}
        /if (!${Bool[${Plugin[${pluginname}]}]}) {
            /squelch /plugin ${pluginname}
            /echo ${pluginname} not detected! This macro requires it! Loading ...
        }
        /if (${Debug}) {
			/echo \atDEBUG CheckPlugin: Leave \agLine#: ${Macro.CurLine}
		}
    /return
| ----------------------------------------------------------------------------
| SUB: Load Ini
| ----------------------------------------------------------------------------
Sub LoadIni(string sectionName, string varName, string varType, string varValue, string varArray, string varArray2, string FileName, string FileName2)
 |                "${ZoneName}"        MezImmune       string          "L"              NULL             False             ${InfoFileName}
    /if (${Debug}) {
        /echo \atDEBUG Sub Loadini S:${sectionName} varName:${varName} varType:${varType} varValue:${varValue} varArray:${varArray} varArray2:${varArray2} FileName:${FileName} FileName1:${FileName2} \agLine#: ${Macro.CurLine}
    }
	|/if (${varName.Equal[MedStart]}) /mqp on
	|/setchattitle Loading Ini ${sectionName}:${varName}
    /declare rkTemp                 string      local 
    /declare IsConditionVar         int         local        0 
    /declare UtilInt                int         local        0 
    /declare FileName1              string      local        ${FileName}
    /if (${FileName1.Length}==0 || ${FileName1.Equal[null]} || ${FileName1.Equal[NULL]}) {
        /varset FileName1 ${IniFileName}
    }
    | Check if ini value is asking for an array ie buff1 to buff20
	| cant check this if ${varArray} is NULL (cause then we are checking {NULL.Size}
	/if (${Bool[${varArray}]}) {
        /if (${${varArray}.Size}>0) {
        	/declare i int local
        	/for i 1 to ${${varArray}.Size}
				/varset IsConditionVar 0
        	    /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
					/ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
				}
        	    /if (${varName.Equal[OhShit]}) {
					/if (${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
						/varset ${varArray}[${i}] ${Ini[${FileName1},${sectionName},${varArray}${i},TRUE,noparse]}
						|ok so we are at in a special case, we need to set this var to 1 so it wont try to refer to an undeclared variable 
						|The user is using a OhShit, which is allowed to take undeclared varibles in its argument.
						/varset IsConditionVar 1
					}
				} else /if (${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
					/varset ${varArray}[${i}] ${Ini[${FileName1},${sectionName},${varArray}${i}]}
				}
        	    /if (${Debug}) {
					/echo \atDEBUG ${ConditionsOn} ${Int[${varArray2.Length}]} ${varArray2.Length} ${Bool[${varArray2.NotEqual[null]}]} ${varArray2}
				}
        	    /if (${Defined[ConditionsOn]}) {
        	        /if (${ConditionsOn} && ${Int[${varArray2.Length}]}>0 && ${varArray2.NotEqual[null]}) {
        	            | Check to see if the conditions file is a different file and update spell info.
        	            /if (!${IsConditionVar}) {
							|ok the user is NOT using a undeclared variable so its ok for us to read it.
							/if (${FileName2.NotEqual[${FileName1}]}) /ini "${FileName2}" "${sectionName}" "${varName}${i}" "${${varArray}[${i}]}"
        	            }
						/if (!${Ini[${FileName2},${sectionName},${varArray2}${i}].Length}) {
        	                /if (${${varArray}[${i}].NotEqual[null]}) {
        	                    /ini "${FileName2}" "${sectionName}" "${varArray2}${i}" "TRUE"
        	                } else {
        	                    /ini "${FileName2}" "${sectionName}" "${varArray2}${i}" "FALSE"
        	                }
        	            }
        	            /varset ${varArray2}[${i}]  ${Ini[${FileName2},${sectionName},${varArray2}${i},TRUE,noparse]}
						/if (${IsConditionVar}) {
							| the user IS using a undeclared variable in his condition, we should NOT check this against Rk. II
							| because if we read that var it is undeclared at this point so we skip.
							/continue
						}
        	        } else /if (${Int[${varArray2.Length}]}>0 && ${varArray2.NotEqual[null]}) {
        	            /varset ${varArray2}[${i}] TRUE
                	} 
                } else {
                	/varset ${varArray2}[${i}] TRUE
                }
                /if (${${varArray}[${i}].NotEqual[null]}) {
                	| find out if there is a Rank and fix spell name.
                	/if (${varType.Equal[string]} && ${Int[${${varArray}[${i}].Left[1]}]}==0) {
                	    /call Spell_Rk_Check "${${varArray}[${i}]}"
                	    /varset ${varArray}[${i}] ${Macro.Return}
                	}
                	| code to fix the Heal PCT for those zones that knock your HPs down to 
                	/if (${sectionName.Equal[Heals]} && ${Select[${Zone.ID},795,796]}) {
                	    /if (${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0) {
                	        /varset UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}
                	        /varcalc UtilInt 70*(${UtilInt}/100)
                	        /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                	    }
                	} else /if (${sectionName.Equal[DPS]} && ${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0 && ${${varArray}[${i}].Arg[3,|].Equal[debuffall]}) {
                	    /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
                	    /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                	}
                }
                /if (${Debug}) {
					/echo  \atDEBUG Loadini ${i} - ${varArray}[${i}] - ${${varArray}[${i}]} - ${Macro.Return} - ${Me.AltAbility[${Macro.Return}]} \agLine#: ${Macro.CurLine}
				}
			/next i
            /return
		}
	} else {
        /if (!${Defined[${varName}]} && ${Defined[varType]}) /declare ${varName} ${varType} outer 0
        |Using the varArray2 to tell if trying to find a conditional entry or not. False = conditional null = non-conditional
        /if (${varArray2.Length}==0 || ${varArray2.Equal[false]} || ${varArray2.Equal[NULL]}) {
            /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                /if (${varValue.Length}) {
                    /ini "${FileName1}" "${sectionName}" "${varName}" "${varValue}"
                    /varset ${varName} ${varValue}
                    /if (${Debug}) {
						/echo \atDEBUG Sub LoadIni /varset ${varName} ${varValue} \agLine#: ${Macro.CurLine}
					}
                }
            } else {
				/if (${varName.Equal[TheWinTitle]}) {
                    /varset TheWinTitle ${Ini[${FileName1},${sectionName},TheWinTitle,NULL,noparse]}
					|/echo Reading wintitle from infile, it is: ${TheWinTitle}
					|dont mess with this variable anymore, just return
					/return
		    	} else {
					/varset ${varName} ${Ini[${FileName1},${sectionName},${varName}]}
		    	}
            }
            /if (${FileName1.Equal[${IniFileName}]}) {
                /varset rkTemp ${${varName}}
                | find out if there is a Rank and fix spell name.
                /if (${varType.Equal[string]} && ${Int[${rkTemp.Left[1]}]}==0 && !${varName.Find[Help]}) {
                    /call Spell_Rk_Check "${${varName}}"
                    /if (${Macro.Return.NotEqual[null]}) /varset ${varName} ${Macro.Return}
                }
            }
        } else /if (${Defined[ConditionsOn]}) {
            /if (${ConditionsOn}) {
                /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                    /if (${varValue.Length}) {
                        /ini "${FileName1}" "${sectionName}" "${varName}" "${varValue}"
                        /varset ${varName} ${varValue}
                        /if (${Debug}) /echo \atDEBUG Sub Loadini /varset ${varName} ${varValue} \agLine#: ${Macro.CurLine}
                    }
                } else {
                    /varset ${varName} ${Ini[${FileName1},${sectionName},${varName}]}
                }
            } else {
                /varset ${varName} ${varValue}
            }
        } else {
            /varset ${varName} ${varValue}
        }
        /if (${Debug}) {
			/echo \atDEBUG Sub LoadIni: ${varName} - ${${varName}} \agLine#: ${Macro.CurLine}
		}
        /varset rkTemp 
    }
	|/if (${varName.Equal[MedStart]}) /mqp on
    /if (${Debug}) {
		/echo \atDEBUG Sub LoadIni: Leave \agLine#: ${Macro.CurLine}
	}
	/setchattitle Loading Ini ${sectionName}:${varName}
/return

| ----------------------------------------------------------------------------
| SUB: End Mac If
| ----------------------------------------------------------------------------
    Sub EndMacroIf
        /if (${Debug}) /echo \atDEBUG EndMacroIf: Enter \agLine#: ${Macro.CurLine}
        | I died wait for rez loop
        :WaitOnRez
        /if (${EverQuest.GameState.Equal[CHARSELECT]}) /endmac
        /if ((${Me.Hovering} || ${CampZone} != ${Zone.ID}) && ${RezAcceptOn} && ${IAmDead}) {
            /if (${Attacking}) /call CombatReset
            /delay 10
            /if (${ClickBacktoCamp}) /call CampfireBack
            /if (${CampOnDeath}) /call DoICamp
            /goto :WaitOnRez
        }
        /if (!${RezAcceptOn} && ${CampZone} != ${Zone.ID}) {
            /if (${CampOnDeath}) /call DoICamp
            /if (${IAmDead}) {
                /if (${Twist}) {
                    /twist off
                    /delay 20
                }
                /endmac
            }
        }
        /if (${Debug}) /echo \atDEBUG EndMacroIf: Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Do I Camp
| ----------------------------------------------------------------------------
    Sub DoICamp
        /if (!${CampOnDeath}) /return
        /if (!${CampOnDeathTimer} && ${CampZone} != ${Zone.ID} && ${Me.Buff[Revival Sickness].ID}) {
            /echo I am dead and not where I am suppose to be. Time to camp out.
            /if (${Twist}) {
                /twist off
                /delay 20
            }
            /docommand /camp desktop
            /delay 40s
            /endmac
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Do Bard Stuff
| ----------------------------------------------------------------------------
    Sub DoBardStuff
        /if (${Me.Class.Name.NotEqual[Bard]}) /return
        /if (!${BardStartTwist} && !${Me.Invis}) {
            /squelch /twist off
            /delay 10
            /if (${TwistWhat.Length} && ${TwistWhat.Find[order]}==0) {
		/squelch /twist ${TwistWhat}
	    }
            /varset BardStartTwist 1
	    /echo returning from DoBardStuff because BardStartTwist is 0
            /return
        }
        /if (${Me.Invis} && ${Twist} || (${Medding} && ${MedCombat} && ${AggroTargetID})) {
            /twist off
            /stop song
	    /echo returning from DoBardStuff because 1
            /return
        }
        /if (${Debug}) {
		/echo \atDEBUG DoBardStuff: Enter \agLine#: ${Macro.CurLine}
	}
        /if (${MeleeTwistOn} && ${CombatStart} && !${DPSTwisting}) {
            /varset DPSTwisting 1
            /varset Twisting 0
            /if (${MeleeTwistWhat.Equal[Continuous]}) {
                /if (${Twist}) {
                    /echo == Continuing normal twist for melee
                    /return
                }
            } else {
                /squelch /twist ${MeleeTwistWhat}
            }
            /echo == Starting melee twist
        }
        /if (${TwistOn} && !${CombatStart} && !${Twisting}) {
            /varset DPSTwisting 0
            /varset Twisting 1
            /if (${MeleeTwistWhat.Equal[Continuous]} && ${Twist} && ${Twist.Current}!=${TwistMed}) {
                    /echo == Continuing normal twist
                    /return
            } else {
                /squelch /twist ${TwistWhat}
                /echo == Starting normal twist
            }
        }
        /if (!${TwistOn} && !${CombatStart} && ${Twist}) {
		/echo turning off twist in DoBardStuff
		/squelch /twist off
	}
        /if (${Debug}) {
		/echo \atDEBUG DoBardStuff: Leave \agLine#: ${Macro.CurLine}
	}
    /return
| ----------------------------------------------------------------------------
| SUB: GroupEscape
| ----------------------------------------------------------------------------
    Sub GroupEscape
     /if (!${GroupEscapeOn}) /return
         /if (${Debug}) /echo \atDEBUG GroupEscape Enter \agLine#: ${Macro.CurLine}
         |- If (in combat) or (Have AgroID) AND (MA is not present) or (a corpse).
         /if ((${Me.CombatState.Equal[COMBAT]} || ${AggroTargetID}) && (!${Spawn[=${MainAssist}].ID} || ${Spawn[=${MainAssist}].Type.Equal[Corpse]})) {
         /if (${Debug}) /echo \atDEBUG GroupEscape: CombatState:${Me.CombatState.Equal[COMBAT]} AggroTargetID:${AggroTargetID} MA Dead:!${Spawn[=${MainAssist}].ID}|${Spawn[=${MainAssist}].Type.Equal[Corpse]} \agLine#: ${Macro.CurLine}
         /echo + The MA is dead and I'm in combat, activating Group Escape!
         /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
                 |-- Druid AA or Spell group evac casting.
                 /if (${Select[${Me.Class.ShortName},DRU]}) {
                     |- Drop Divine Barrier if it is up so we can exodus group!
                     /removebuff Divine Barrier
                     /if (${Me.AltAbilityReady[Exodus]}) {
                         /call CastWhat "Exodus" ${Me.ID} GroupEscape
                     } else /if (${Me.Book[Succor]}) {
                         /call CastWhat "Succor" ${Me.ID} GroupEscape
                     }
                 }
                 |-- Wizard AA or Spell group evac casting.
                 /if (${Select[${Me.Class.ShortName},WIZ]}) {
                     /if (${Me.AltAbilityReady[Exodus]}) {
                         /call CastWhat "Exodus" ${Me.ID} GroupEscape
                     } else /if (${Me.Book[Evacuate]}) {
                         /call CastWhat "Evacuate" ${Me.ID} GroupEscape
                     }
                 }                
             }            
         }
         /if (${Debug}) /echo \atDEBUG GroupEscape Leave \agLine#: ${Macro.CurLine}
    /return

Sub GetGroupMage
	/declare i                  int         local       0
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].Pet.ID} && ${Group.Member[${i}].Type.Equal[PC]} && ${Group.Member[${i}].Class.ShortName.Equal[MAG]}) {
			/return ${i}
		}
	/next i
/return 7
| ----------------------------------------------------------------------------
| SUB: CheckHealth
| ----------------------------------------------------------------------------
    Sub CheckHealth
		/if (${OhShitOn}) {
			/call OhShitStuff
		}
        /if (!${HealsOn}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${Medding} && ${MedCombat}) /return
        /if (${DebugHeal}) {
			/echo \amDEBUGHEALS CheckHealth Enter \agLine#: ${Macro.CurLine}
		}
        /declare i                  int         local       0
        /declare MostHurtName       string      local
        /declare MostHurtType       string      local
        /declare MostHurtID         int         local       0
        /declare MostHurtHP         int         local       100
        /declare MostHurtNo         int         local       0
	/declare MAGOwnerNum int local 0
        :CheckAgain
        /varset HealAgain    0
        | Check self health
        /if (${Me.PctHPs} <= ${SingleHealPoint}) {
			/call SingleHeal "${Me}" PC ${Me.PctHPs} 0
		}
        | Call MA health check for only those that can heal others
        /if (${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,RNG,PAL]}) {
            | This is to target Main Assist out of group if class can heal
			/if (${Select[${HealsOn},1,3]}) {
				/if (${Spawn[${MainAssist}].ID}!=${Me.ID}) {
					/if (${Spawn[${MainAssist} ${MainAssistType}].ID}) {
						/if (${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} && ${Spawn[${MainAssist}].ID}!=${Me.Pet.ID}) {
							/if ((!${SpawnCount[${MainAssist} ${MainAssistType} group]} && ${MainAssistType.NotEqual[pet]}) || (${Select[${Spawn[=${MainAssist}].Master},${Group.Member[1]},${Group.Member[2]},${Group.Member[3]},${Group.Member[4]},${Group.Member[5]}]}==0 && ${MainAssistType.Equal[pet]})) {
								| Skip targeting tank if MA is defined to watch for heals in XTarget
								/if (!${XTarHeal} || (${XTarHeal} && ${Me.XTarget[${XTarHeal}].ID}!=${Spawn[${MainAssist} ${MainAssistType}].ID}) && (${XTarHeal2} && ${Me.XTarget[${XTarHeal2}].ID}!=${Spawn[${MainAssist} ${MainAssistType}].ID})) {
									/target id ${Spawn[${MainAssist} ${MainAssistType}].ID}
									/delay 10
								}
							}
							/if (${DebugHeal}) {
								/echo \amDEBUGHEALS CheckHealth:  Tank OOG: ${Spawn[${MainAssist}].PctHPs} ${Spawn[${MainAssist} ${Spawn[${MainAssist} ${MainAssistType}].ID} ].ID}  ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} \agLine#: ${Macro.CurLine}
							}
							/if (${Spawn[${MainAssist} ${MainAssistType}].PctHPs} < 100 || ${MainAssistType.Equal[pet]}) {
								/call GetGroupMage
								/varset MAGOwnerNum ${Macro.Return}
								/if (${MAGOwnerNum}!=7) {
									/if (${Group.Member[${MAGOwnerNum}].Pet.PctHPs} < 100) {
										/call SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[${MainAssist} ${MainAssistType}].PctHPs} 6
									}
								}
							}
						}
					}
				}
			}
			/if (${AutoRezOn}) {
				/if (!${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
			}
			| Who is the most hurt
            /if (${Select[${HealsOn},1,2]} && ${Group} && !${JustZoned} && !${JoinedParty}) {
                /varset MostHurtName
                /varset MostHurtType
                /varset MostHurtID
                /varset MostHurtHP 100
                /varset MostHurtNo 0
                /for i 0 to ${Group}
                    /if (${HealsOn}==2) {
						/if (${Select[${Spawn[${MainAssist} ${MainAssistType}].ID},${Group.Member[${i}].ID},${Group.Member[${i}].Pet.ID}]}>0) /continue
					}
                    /if (${Group} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].PctHPs}>=1) {
						/if (${DebugHeal}) {
							/echo \amDEBUGHEALS CheckHealth:  -- Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP} \agLine#: ${Macro.CurLine}
                        }
						/if (${Group.Member[${i}].PctHPs} <= ${MostHurtHP}) {
                            /varset MostHurtName ${Group.Member[${i}].CleanName}
                            /varset MostHurtType ${Group.Member[${i}].Type}
                            /varset MostHurtID ${Group.Member[${i}].ID}
                            /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                            /varset MostHurtNo ${i}
                        }
                        /if (${HealGroupPetsOn}) {
							/if (${Select[${Group.Member[${i}].Class.Name},cleric,wizard]}==0 && ${Group.Member[${i}].Pet.ID}>0 && ${Group.Member[${i}].Pet.PctHPs} <= ${MostHurtHP}) {
								/varset MostHurtName ${Group.Member[${i}].Pet.CleanName}
								/varset MostHurtType Pet
								/varset MostHurtID ${Group.Member[${i}].Pet.ID}
								/varset MostHurtHP ${Group.Member[${i}].Pet.PctHPs}
								/varcalc MostHurtNo ${i}+8
							}
                        }
                    }
                /next i
                /if (${DebugHeal}) {
					/echo \amDEBUGHEALS CheckHealth: (${MostHurtHP} <= ${SingleHealPoint}) /call SingleHeal "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo} \agLine#: ${Macro.CurLine}
                }
				/if (${MostHurtHP} <= ${SingleHealPoint}) {
					/call SingleHeal "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo}
				}
            }
        }
        | Rez tank check
        /if (${AutoRezOn}) {
		/if (!${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
	}
        | Group Heal Check only call for those classes that can group heal
        /if (${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) {
            | Check for group heals
            /if (${Group}) {
		/call DoGroupHealStuff ${Group.AvgHPs}
	    }
        }
        | Rez tank check
        /if (${AutoRezOn}) {
			/if (!${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck
		}
        | Check xtarget health if on.
        /if (${XTarHeal}) {
            /if (${Select[${Spawn[${Me.XTarget[${XTarHeal}].ID}].Type},PC,Mercenary,Pet]}) {
		/if (${Me.XTarget[${XTarHeal}].ID} && ${Spawn[${Me.XTarget[${XTarHeal}].ID}].PctHPs} <= ${SingleHealPoint}) {
			/call SingleHeal "${Spawn[${Me.XTarget[${XTarHeal}].ID}].CleanName}" "${Spawn[${Me.XTarget[${XTarHeal}].ID}].Type}" ${Spawn[${Me.XTarget[${XTarHeal}].ID}].PctHPs} 7
			/if (${DebugHeal}) {
				/echo \amDEBUGHEALS CheckHealth: SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[${MainAssist} ${MainAssistType}].PctHPs} 7 \agLine#: ${Macro.CurLine}
			}
		}
	    }
        }
        /if (${XTarHeal2}) {
            /if (${Select[${Spawn[${Me.XTarget[${XTarHeal2}].ID}].Type},PC,Mercenary,Pet]}) {
				/if (${Me.XTarget[${XTarHeal2}].ID} && ${Spawn[${Me.XTarget[${XTarHeal2}].ID}].PctHPs} <= ${SingleHealPoint}) {
					/call SingleHeal "${Spawn[${Me.XTarget[${XTarHeal2}].ID}].CleanName}" "${Spawn[${Me.XTarget[${XTarHeal2}].ID}].Type}" ${Spawn[${Me.XTarget[${XTarHeal2}].ID}].PctHPs} 8
					/if (${DebugHeal}) {
						/echo \amDEBUGHEALS CheckHealth: SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[${MainAssist} ${MainAssistType}].PctHPs} 8 \agLine#: ${Macro.CurLine}
					}
				}
			}
        }
        /if (${PetOn}) {
			/if (${Me.Pet.ID} && ${Me.Pet.PctHPs} < 100) /call DoPetHealStuff
		}
        /if (${HealAgain}) /goto :CheckAgain
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckHealth leave \agLine#: ${Macro.CurLine}
        /if (${AutoRezOn}) /call RezCheck
        /call WriteDebuffs
    /return    
|----------------------------------------------------------------------------
| SUB: Single Heals
|----------------------------------------------------------------------------
    Sub SingleHeal(SHealName, SHealType, int SHealHPs, int WhoNum)
        /if (${DebugHeal}) {
		/echo \amDEBUGHEALS SingleHeal Enter: \ayName: ${SHealName} TType: ${SHealType} Hps%: ${SHealHPs} WhoNum:${WhoNum} \agLine#: ${Macro.CurLine}
        }
        /if (!${HealsOn}) /return
        /if (${Me.Moving}) /return
        /if (${Me.Hovering}) /return
        /if (${Spawn[${SHealName} ${SHealType}].ID}==0 ) {
		/echo \amDEBUGHEALS inside SingleHeal leaving cause : SHealName=${SHealName} and SHealType=${SHealType}
		/return
	}
        /if (${Select[${SHealType},PC,Pet,Mercenary]}==0) /return
        /if (${Me.Invis} && !${AggroTargetID}) {
		/return
	}
	/doevents
        /declare i               int     local   0
        /declare HealSpell      string  local
        /declare SHealTag        string  local
        /declare TheHealID       int     local   ${Spawn[=${SHealName} ${SHealType}].ID}
        /declare MainAssistID    int     local   ${Spawn[=${MainAssist}].ID}
        /declare SHealRange      int     local   0
        /declare HealLoopCount   int     local   0
        /declare HealLoopTimer   timer   local   5
        | Set MA ID to 6 to keep spell durations correct
        /if (${WhoNum}!=6 && ${TheHealID}==${MainAssistID}) /varset WhoNum 6
	:NoHeal
        /varset HealAgain 0
        /varset HealLoopCount 0
        | If heal is null or off |0 or spell/aa/item not ready skip it
        /for i 1 to ${SingleHeal.Size}
		/if (${DebugHeal}) /delay 2
		/varcalc HealLoopCount ${HealLoopCount}+1
            /if (${DebugHeal}) {
		/echo \amDEBUGHEALS SingleHeal \awSpell ${i}: ${SingleHeal[${i}]}  ${SingleHeal[${i}].Arg[1,|]}   ${SingleHeal[${i}].Arg[2,|]}   ${SingleHeal[${i}].Arg[3,|]} \agLine#: ${Macro.CurLine}
		/echo \amDEBUGHEALS SingleHeal \awSpellSkip: !${SingleHeal[${i}].Length} || ${SingleHeal[${i}].Arg[2,|].Equal[0]} \agLine#: ${Macro.CurLine}
            }
	    /if (!${SingleHeal[${i}].Length} || ${SingleHeal[${i}].Arg[2,|].Equal[0]}) /continue
            /varset HealSpell   ${SingleHeal[${i}].Arg[1,|]}
            /varset SHealPct     ${SingleHeal[${i}].Arg[2,|]}
            /varset SHealTag     ${SingleHeal[${i}].Arg[3,|]}
            /varset SHealRange ${Spell[${HealSpell}].Range}
            /if (${Spell[HealSpell].TargetType.Find[Group v]}) /varset SHealRange ${Spell[${HealSpell}].AERange}
            /if (!${SHealRange}) /varset SHealRange 100

	    | New Conditional Check to Skip spell
	    |/if (${ConditionsOn} && ${HealsCOn} && ${If[${SHCond[${i}]},0,1]}) /continue

            /if (${ConditionsOn} && ${HealsCOn}) {
				|/echo the healcondition for ${i} is: ${SHCond[${i}].Replace[$,#]}
				|/echo HealSpell=${HealSpell} SHealTag=${SHealTag} TheHealID=${TheHealID} SHealName=${SHealName} SHealHPs=${SHealHPs} WhoNum=${WhoNum}
				/if (${If[${SHCond[${i}]},0,1]}) {
					|/echo HealCondition for ${HealSpell} failed 1.
					/continue
	    		} else {
					/if (${TheHealID}==${Me.ID}) {
						/if (${SHealTag.Find[buff!=]}) {
							/varset SHealTag ${SHealTag.Mid[7,400]}
							/echo need to make sure ${SHealName} doesnt have ${SHealTag} on.
							/if (${Me.Buff[${SHealTag}].ID}) {
								/echo HealCondition for ${HealSpell} failed 2.
								/continue
							}
						} else /if (${SHealTag.Find[buff==]}) {
							/varset SHealTag ${SHealTag.Mid[7,400]}
							/echo need to make sure ${SHealName} does have ${SHealTag} on.
							|no need to change target I can access my own buffs
							/if (!${Me.Buff[${SHealTag}].ID}) {
								/echo HealCondition for ${HealSpell} failed 3.
								/continue
							}
						}
					} else {
						|crap we are actually gonna have to target them to find out...
						/if (${Target.ID}!=${TheHealID}) {
							/tar id ${TheHealID}
							/delay 5s ${TheHealID}==${Target.ID} && ${Target.BuffsPopulated}==TRUE
						}
						/if (${SHealTag.Find[buff!=]}) {
							/varset SHealTag ${SHealTag.Mid[7,400]}
							|/echo need to make sure ${SHealName} DOES have ${SHealTag} on.
							/if (${Target.Buff[${SHealTag}].ID}) {
								/echo HealCondition for ${HealSpell} failed 4.
								/continue
							}
						} else /if (${SHealTag.Find[buff==]}) {
							/varset SHealTag ${SHealTag.Mid[7,400]}
							|/echo need to make sure ${SHealName} DOES NOT have ${SHealTag} on.
							/if (!${Target.Buff[${SHealTag}].ID}) {
								/echo HealCondition for ${HealSpell} failed 5.
								/continue
							}
						}
					}
					|/echo healing because condition met! ${i}: ${SHCond[${i}]}
				}
			}
            | Skip Heal if pet 
            /if (${Spawn[${TheHealID}].Type.NotEqual[Pet]} && ${SHealTag.Equal[pet]}) {
			/echo skipping healing ${SHealName} with ${HealSpell} because he is not a Pet and the tag says Pet 1
			/continue
	    }
	    | If tag MA/Mob and heal target not MA or tag !MA and heal target MA skip
            /if (${TheHealID} != ${MainAssistID}) {
		/if (${HealGroupPetsOn}) {
			/if (${SHealTag.Equal[pet]} && ${Spawn[${TheHealID}].Type.NotEqual[pet]}) {
				/echo skipping healing ${SHealName} with ${HealSpell} because he is not a Pet and the tag says Pet 2
				/continue
			}
		} else {
			/if (${SHealTag.Equal[pet]}) {
				/echo skipping healing ${SHealName} with ${HealSpell} because it is a pet and HealGroupPetsOn = 0
				/continue
			}
		}
		/if (${SHealTag.Equal[Mob]} && ${Spawn[${TheHealID}].Type.NotEqual[NPC]}) {
			/echo skipping healing ${SHealName} with ${HealSpell} because he is not a NPC and the tag says Mob
			/continue
		}
 		/if (${SHealTag.Equal[MA]}) {
			/echo skipping healing ${SHealName} with ${HealSpell} because he is not MA and the tag says MA
			/continue
		}
	    } else {
		/if (${SHealTag.Equal[!MA]}) {
			/echo skipping healing ${SHealName} with ${HealSpell} because it's MA
			/continue
		}
	    }
            /if (${DebugHeal}) {
		/echo \amDEBUGHEALS SingleHeal \awSHealTag.Equal[MA]: ${SHealTag.Equal[MA]} TheHealID = ${TheHealID} MainAssistID = ${MainAssistID} || ${SHealTag.Equal[Mob]} && ${TheHealID}!=${MainAssistID} || ${SHealTag.Equal[!MA]} && ${TheHealID}==${MainAssistID} \agLine#: ${Macro.CurLine}
            }
            | Cleric Divine Arbitration and Epics do not work on pets or people out of group
            /if (${Spawn[${TheHealID}].Type.Equal[Pet]}) {
		/if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Divine Arbitration]}) {
			/echo skipping healing ${SHealName} with ${HealSpell} because it's a pet
			/continue
		}
	    }
            /if (!${Spawn[${SHealName} ${SHealType} group].ID}) {
		/if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Divine Arbitration]}) {
			/echo skipping healing ${SHealName} with ${HealSpell} because he is not in the group
			/continue
		}
	    }
            | intervention and survival lines only work on group members
            /if (!${Spawn[${SHealName} ${SHealType} group].ID}) {
		/if (${Select[${Me.Class.Name},Druid,Shaman]}) {
			/if (${HealSpell.Find[Intervention]} || ${HealSpell.Find[Survival]}) {
				/echo skipping healing ${SHealName} with ${HealSpell} because its a non grouped guy
				/continue
			}
		}
	    }
            | Check For Life Taps
            /if (${SHealTag.Find[Tap]}) {
                /if (!${Pulled} && ${CombatStart} && ${Me.PctHPs}<=${SHealPct} && ${Target.Type.NotEqual[Corpse]} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance}<=${SHealRange} && ${Spell${i}GM0}==0) {
                    /if (${Me.SpellReady[${HealSpell}]} || ${Me.AltAbilityReady[${HealSpell}]} || ${Me.CombatAbilityReady[${HealSpell}]}) {
                        /call CastWhat "${HealSpell}" ${Spawn[${MyTargetID}].ID} SingleHeal
                    } else {
			/echo ${HealSpell} not ready 1.
			/continue
		    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} o "${HealSpell} for  >> ${Me.CleanName} <<"
                        /varcalc Spell${i}GM0 (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod})*10
                        /if (${DebugHeal}) {
				/echo DEBUGHEALS SingleHeal Assign Timer:Spell${i}GM0 (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod}) ${Spell${i}GM0} Line#: ${Macro.CurLine}
			}
                        /return
                    } else {
				/if (${Macro.Return.Equal[CAST_CANCELED]}) /return
		    }
                } else {
			/echo Skipping ${HealSpell} shit shit!
			/continue
		}
            } else /if (${SHealTag.Find[Mob]}) {
		| Check For Nuke Heals - contibuted by thenomadman
                /if (!${AggroTargetID}) {
			/echo Skipping ${HealSpell} due to no AggroTargetID
			/continue
		}
                /doevents Switch
                /if ((${DPSOn} || ${MeleeOn}) {
			/if (!${MyTargetID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]}) /call Assist Heals
		}
                /if (${MyTargetID} && ${Spawn[${MainAssist}].PctHPs}<=${SHealPct} && ${Spawn[${MyTargetID}].LineOfSight} && ${Spawn[${MyTargetID}].Distance}<=${SHealRange} && !${Spawn[${MyTargetID}].Type.Equal[Corpse]}) {
                    /varset HealAgain 2
                    /if (${Me.SpellReady[${HealSpell}]} || ${Me.AltAbilityReady[${HealSpell}]} || ${Me.CombatAbilityReady[${HealSpell}]}) {
                        /call CastWhat "${HealSpell}" ${Spawn[${MyTargetID}].ID} SingleHeal
                    } else {
			/continue
		    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} o "${HealSpell} for >>${Spawn[${SHealName} ${SHealType}].CleanName} << cast on ${Spawn[${MyTargetID}].CleanName}"
                        /varset HealAgain 1
                        /return
                    } else /if (${Macro.Return.Equal[CAST_CANCELED]}) /return
                } else {
			/echo Skipping ${HealSpell} due to a mistake.
			/continue
		}
            }
            | Check conditons for heals
            /if (${DebugHeal}) {
		/echo \amDEBUGHEALS SingleHeal \aw${SHealHPs} <= ${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ${Spell${i}GM${WhoNum}}==0 \agLine#: ${Macro.CurLine}
            }
		/if (${SHealHPs} <= ${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ${Spell${i}GM${WhoNum}}==0 && (${Me.SpellReady[${HealSpell}]} || ${Me.AltAbilityReady[${HealSpell}]} || ${Me.CombatAbilityReady[${HealSpell}]})) {
                | target has qualified for a heal
                /varset HealAgain 2
                /if (${Spell[${HealSpell}].TargetType.Equal[Free Target]}) {
                    | Check if spalsh heal target is in line of sight
                    /if (${Target.ID}!=${TheHealID}) {
                        /target id ${TheHealID}
                        /delay 2s ${Target.ID}==${TheHealID}
                    }
                    /if (!${Target.CanSplashLand}) {
                        /echo Splash Spell will NOT land on target. Skipping.
                        /continue
                    }
                }
                /if (${Select[${EverQuest.Server},zek]}) {
			/if (${Select[${Target.Type},PC]} && ${Me.Combat}) {
				/attack off
				/delay 25 !${Me.Combat}
			}
		}
                /if (${TheHealID}==${MainAssistID}) {
			/if (${Spawn[${MainAssist} ${MainAssistType}].ID}) /removebuff Divine Barrier
		}
                /echo healing ${Spawn[${TheHealID}]} with ${HealSpell}
		/call CastWhat "${HealSpell}" ${TheHealID} SingleHeal
                /if (${DebugHeal}) {
			/echo \amDEBUGHEALS SingleHeal \awMR: ${Macro.Return} \agLine#: ${Macro.CurLine}
		}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast ${IRCOn} ${EQBCOn} o "${HealSpell} on  >> ${Spawn[${SHealName} ${SHealType}].CleanName} <<"
                    /if (${HealSpell.Find[Promised]}) {
                        /varset Spell${i}GM${WhoNum} 210
                    }    
                    /varcalc Spell${i}GM${WhoNum} (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod})*10
                    /if (${DebugHeal}) {
			/echo DEBUGHEALS SingleHeal Assign Timer:Spell${i}GM${WhoNum} ${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod} ${Spell${i}GM${WhoNum}} Line#: ${Macro.CurLine}
                    }
		    | Prioritize heals by setting flag to check Health again
                    /varset HealAgain 1
                    /return
                } else /if (${Macro.Return.Equal[CAST_CANCELED]}) /return
            }
        /next i
        | if target qualified for a heal but did not recieve one due to cooldown etc try to heal again. Release after 3s
        /if (${HealAgain}==2) {
		/if (${SingleHeal.Size}==${HealLoopCount} && ${HealLoopTimer}) /goto :NoHeal
	}
        /if (${DebugHeal}) {
		/echo \amDEBUGHEALS \aySingleHeal Leave \agLine#: ${Macro.CurLine}
	}
        /varset HealAgain 0
    /return    
| ----------------------------------------------------------------------------
| SUB: Do Group Heal Stuff
| ----------------------------------------------------------------------------
Sub DoGroupHealStuff(int GroupHealth)
    /if (${DebugHeal}) {
	/echo \amDEBUGHEALS DoGroupHealStuff Enter ${GroupHealth} \agLine#: ${Macro.CurLine}
    }
    /doevents
    /declare j              int     local
    /declare HealSpell      string  local
    /declare TheHealID      int     local ${Me.ID}   
    /declare HealPct        string  local
    /for j 1 to ${GroupHeal.Size}
        /if (!${Heals[${j}].Length} || ${Heals[${j}].Arg[2,|].Equal[0]}) {
		/echo returning in DoGroupHealStuff due to Heals[${j}].Length = ${Heals[${j}].Length} or Heals[${j}].Arg[2,|].Equal[0] = ${Heals[${j}].Arg[2,|].Equal[0]}
		/return
	}
        /varset HealSpell   ${GroupHeal[${j}].Arg[1,|]}
        /varset HealPct     ${GroupHeal[${j}].Arg[2,|]}
        /if (${DebugHeal}) {
		/echo \amDEBUGHEALS DoGroupHealStuff ${HealSpell} ${HealPct} \agLine#: ${Macro.CurLine}
        }
	/if (${DebugHeal}) {
		/echo \amDEBUGHEALS DoGroupHealStuff Group Heal Spell/Item:${Spell[${HealSpell}].TargetType.Find[group v]}/${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} Spell:${HealSpell} GpAvg:${GroupHealth} HealAt:${HealPct} Timer:${SpellGH${j}}==0 \agLine#: ${Macro.CurLine}
        }
	/if (${ConditionsOn} && ${HealsCOn}) {
		|ok both global and local is ON so we check the condition...
		/if (${If[${GHCond[${j}]},0,1]}) {
			|/echo [Condition: ${j}] well the condition for ${HealSpell}|${HealPct} -> ${GHCond[${j}].Replace[$,#]} <-> ${SpellGH${j}} <-> ${GHCond[${j}]} returned FALSE... so we should NOT moveon...
			/continue
		} else {
			|/echo [Condition: ${j}] well the condition for ${HealSpell}|${HealPct} -> ${GHCond[${j}].Replace[$,#]} <-> ${SpellGH${j}} <-> ${GHCond[${j}]} returned TRUE... so we SHOULD moveon...
		}
	}
            /if (${GroupHealth}<=${HealPct} && ${SpellGH${j}}==0 && ${Group}) {
                /call CastWhat "${HealSpell}" ${Me.ID} GroupHeal
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /if (${DebugHeal}) /echo \amDEBUGHEALS DoGroupHealStuff ${HealSpell} on  >> Group << \agLine#: ${Macro.CurLine}
                    /call BroadCast ${IRCOn} ${EQBCOn} o "${HealSpell} on  >> Group <<"
                    /varcalc SpellGH${j} (${Spell[${HealSpell}].Duration.TotalSeconds}*${DurationMod})*10
                    /if (${DebugHeal}) /echo DEBUGHEALS DoGroupHealStuff Assign Timer:SpellGH${j} (${Spell[${HealSpell}].Duration}*${DurationMod}.TotalSeconds) ${SpellGH${j}} Line#: ${Macro.CurLine}
                    /varset HealAgain    1
                    /return
                }
            }
    /next j
    /if (${DebugHeal}) /echo \amDEBUGHEALS DoGroupHealStuff Leave \agLine#: ${Macro.CurLine}
/return
| -------------------------------------------------------------------------------------
| SUB: DoPetHealStuff
| -------------------------------------------------------------------------------------
    Sub DoPetHealStuff
        | Check if my pet needs healing
        /if (!${Me.Pet.ID}) /return
        /if (${DebugHeal}) /echo \amDEBUGHEALS DoPetHealStuff Enter \agLine#: ${Macro.CurLine}
        /declare j int local
        /for j 1 to ${SingleHeal.Size}
            /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /goto :NextPetHeal
            /if (${Me.Pet.PctHPs}<=${SingleHeal[${j}].Arg[2,|]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) {
               /if (${DebugHeal}) {
					/echo \amDEBUGHEALS DoPetHealStuff (${SingleHeal[${j}].Arg[3,|].Find[PET]} && ${Me.Pet.PctHPs}<=${HealPct} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) \agLine#: ${Macro.CurLine}
               }
			   /call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Heal
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast ${IRCOn} ${EQBCOn} o "${SingleHeal[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} <<"
                    /varcalc PetHealTimer${j} (${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration.TotalSeconds}*${DurationMod})*10
                    /varset HealAgain    1
                }
            }
            :NextPetHeal
        /next j
        /if (${DebugHeal}) /echo \amDEBUGHEALS DoPetHealStuff Leave \agLine#: ${Macro.CurLine}
    /return

| -------------------------------------------------------------------------------------
| SUB: Rez Check
| -------------------------------------------------------------------------------------
    Sub RezCheck
    | Don't rez if AutoRezOn=0.  AutoRezOn=1 dmzone not instanced like pok, hovering, invis and no aggro, AutoRezOn=2 and aggro(rez after combat setting)
    /if (!${AutoRezOn}) /return
    /if (${DMZ} && ${Me.InInstance}==FALSE) /return
    /if (${Me.Hovering}) /return
    /if (${Me.Invis} && !${AggroTargetID}) /return
    /if (${AutoRezOn}==2 && ${AggroTargetID}) /return
    /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck Enter \agLine#: ${Macro.CurLine}
    /declare i int local
    /declare j int local
    /declare CorpseCount int local
    /declare RezMeID int local 
    /declare RezID int local
    /declare RezRadius int local 150
    | Do I have a Corpse
    /varset RezMeID ${Spawn[corpse ${Me} radius ${RezRadius} zradius 50].ID}
    /if (${RezMeID}) {
    	/if (!${Defined[OOCRezTimer${RezMeID}]}) /declare OOCRezTimer${RezMeID} timer outer 0

	/if (${OOCRezTimer${RezMeID}}==0 && ${Cast.Ready[${AutoRezWith}]}) {
        	/target id ${RezMeID}
        	/delay 10 ${Target.ID}
        	/if (${Target.Distance}>${CampRadius}) /corpse
        	/delay 10
        	/call  CastWhat "${AutoRezWith}" ${Target.ID}
        	/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            		/varset OOCRezTimer${RezMeID} 3m
            		/if (${SpawnCount[corpse ${Me} radius ${RezRadius} zradius 50]}==0 && ${MountOn} && !${Me.Mount.ID} && ${Me.CombatState.NotEqual[COMBAT]} && ${Zone.Outdoor}) {
				|/echo time to get a mount up! Zone.Outdoor is ${Zone.Outdoor}
				/call CastMount
	    		}
		}
    	}
    }
    | Does Group Member have a corpse?
    /for i 1 to ${Group}
        /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck ${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} corpse].Distance}<${RezRadius} ${Spawn[${Group.Member[${i}].CleanName} corpse].Deity.ID}  || !${Cast.Ready[${AutoRezWith}]} \agLine#: ${Macro.CurLine}
        /if (!${Spawn[${Group.Member[${i}].CleanName} pccorpse].ID}  || !${Cast.Ready[${AutoRezWith}]} || (${AutoRezWith.Find[Call of]} && ${Group.Member[${i}].OtherZone}==FALSE)) /goto :NextChar
        | Check for group member corpses and battle rez
        /if (${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} corpse].Distance}<${RezRadius}) {
            /squelch /tar id ${Spawn[${Group.Member[${i}].CleanName} corpse].ID}
            /delay 10 ${Target.ID}==${Spawn[${Group.Member[${i}].CleanName} corpse].ID}
            /if (${Target.Distance}<100) {
                /if (${Target.Distance}>${CampRadius} && !${Target.CleanName.Find[${MainAssist}]}) /corpse
                /delay 10
                /call CastWhat "${AutoRezWith}" ${Target.ID}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast ${IRCOn} ${EQBCOn} o "BATTLE REZZED =>> ${Group.Member[${i}]} <<="
                    /varset BattleRezTimer${i} 3m
                    /squelch /target clear
                    /if (${AutoRezWith.Find[Call of]}) /varset BattleRezTimer${i} 6m
                } else {
                    /if (${Group.Member[${i}].Name.NotEqual[${MainAssist}]}) /varset BattleRezTimer${i} 1m
                }
            }
        }
        :NextChar
    /next i
    | Out of Combat Rez | 
    /varset CorpseCount ${SpawnCount[corpse radius ${RezRadius} zradius 50]}
    /if (${CorpseCount}>0 && !${CombatStart}) {
        /for j 1 to ${CorpseCount}
            /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
            /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
		/if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
		/if (${OOCRezTimer${RezID}}==0 && ${Cast.Ready[${AutoRezWith}]} && (${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} || ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID} || (${XTarHeal} && ${Spawn[${RezID}].ID}==${Me.XTarget[${XTarHeal}].ID}))) {
			| If call of wild and toon in zone skip
			/if (${AutoRezWith.Find[Call of]} && ${Spawn[pc ${Spawn[${RezID}].CleanName.Left[-9]} ].ID}) /goto :NextCorpse
                	/target id ${RezID}
                	/delay 10 ${Target.ID}==${RezID}
                	/if (${Target.Distance}<=${RezRadius}) {
                    		/call  CastWhat "${AutoRezWith}" ${Target.ID}
                    		/if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        		/call BroadCast ${IRCOn} ${EQBCOn} o "Rezzing =>> ${Target.CleanName} <<="
                        		/varset OOCRezTimer${RezID} 5m
                        		/delay 30 !${Me.Casting.ID}
                        		/squelch /target clear
                    		}
                	}
            	}
	    }
        :NextCorpse
        /next j
    }
    /if (${DebugHeal}) /echo \amDEBUGHEALS RezCheck Leave \agLine#: ${Macro.CurLine}
/Return
| -------------------------------------------------------------------------------------
| SUB: Loot Stuff
| -------------------------------------------------------------------------------------
    Sub LootStuff
        /if (!${LootOn} || (!${Me.UseAdvancedLooting} && ${AggroTargetID}) || (${MainAssist.Equal[${Me}]} && ${AggroTargetID}) || (${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Invis}) /return
        /if (${Debug}) /echo \atDEBUG LootStuff: Enter \agLine#: ${Macro.CurLine}
        /if (${Me.FreeInventory}==0) {
            /echo Inventory is full. Looting OFF
            /varset LootOn 0
            /return
        }
        /doevents
        /if (${Me.UseAdvancedLooting}) {
            /call UseAdvLoot
        } else {
            /call LootMobs
        }
        /call DoWeMove "LootStuff"
        /if (${Debug}) /echo \atDEBUG LootStuff: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
|   Sub MobRadar
| -------------------------------------------------------------------------------------
    Sub MobRadar(int CountRadius,string calledfrom)
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        /if (${Debug}) /echo \atDEBUG MobRadar ${CountRadius} Enter (${calledfrom}) \agLine#: ${Macro.CurLine}
        /declare NMob int local
        /declare i int local
        /varset MobCount ${SpawnCount[npc targetable los radius ${CountRadius} zradius 50 noalert 3]}
        /for i 1 to ${MobCount}
            /varset NMob ${NearestSpawn[${i},npc targetable los radius ${CountRadius} zradius 50 noalert 3].ID}
            /if (${i}>13) /goto :ArrayExceed
            /if (${NMob} && (${Spawn[${NMob}].Type.Equal[Corpse]} || !${Spawn[${NMob}].ID})) /call RemoveFromArray AddsArray ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}
            /if (${MobCount}>0 && ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}==0) /call AddToArray AddsArray ${NMob}
            :ArrayExceed
       /next i
        | Check if NPC Pet is on Xtarget
        /if (!${MobCount} && ${Me.XTarget[${XTSlot}].ID}) {
            /if (${Debug}) /echo \atDEBUG MobRadar MobCount=0 but Mob on Xtarget Setting Mobcount to 1 \agLine#: ${Macro.CurLine}
            /varset MobCount 1  
        }    
        /if (${Debug}) /echo \atDEBUG MobRadar Leave ${MobCount} \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
|   Sub MezRadar
| -------------------------------------------------------------------------------------
    Sub MezRadar
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        /if (${DebugMez}) /echo \atDEBUG MezRadar Enter \agLine#: ${Macro.CurLine}
        /declare NMMob int local 0
        /declare i int local
        /varset MezMobCount 0
        /varset MezMobAECount 0
        /varset MezAEClosest 0
        /for i 1 to 13
        /if (${DebugMez}) /echo \atDEBUG MezRadar:  ${i} ${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.Equal[NPC]} \agLine#: ${Macro.CurLine}
            /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.Equal[NPC]}) {
                /varset NMMob ${Me.XTarget[${i}].ID}
                /varcalc MezMobCount ${MezMobCount}+1 
                | Setup closest mob for AE mez target necros can't aemez
                /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
                    /if (!${MezAEClosest} && ${Spawn[${NMMob}].Distance}<=${MezRadius}) /varset MezAEClosest ${NMMob}
                    /if (${MezAEClosest} && ${Spawn[${NMMob}].Distance}<${Spawn[${MezAEClosest}].Distance} && ${Spawn[${NMMob}].Distance}<=${MezRadius}) /varset MezAEClosest ${NMMob}
                    /if (${Spawn[${NMMob}].Distance}<=${MezRadius}) /varcalc MezMobAECount ${MezMobAECount}+1 
                }
                /if (${DebugMez}) /echo \atDEBUG MezRadar: MezMobCount ${MezMobCount} ${NMMob} \agLine#: ${Macro.CurLine}
                /if (${NMMob} && (${Spawn[${NMMob}].Type.Equal[Corpse]} || !${Spawn[${NMMob}].ID})) /call RemoveFromArray MezArray ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}
                /if (${MezMobCount}>0 && ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}==0) {
                    /if (${DebugMez}) /echo \atDEBUG MezRadar: ADDING -> Name: ${Spawn[${NMMob}].Name} ID: ${NMMob} to mezlist \agLine#: ${Macro.CurLine}
                    /call AddToArray MezArray ${NMMob} 
                }
                /varset NMMob 0
            }
        /next i
        /if (${DebugMez}) /delay 5
       /if (${DebugMez}) /echo \atDEBUG MezRadar: MezMobCount: ${MezMobCount} Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Add to Array
| -------------------------------------------------------------------------------------
    Sub AddToArray(ArrayName, int AddMobID)
    /if (!${AddMobID}) /return
        /if (${Debug}) /echo \atDEBUG AddToArray ${AddMobID} Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /for i 1 to 13
            /if (${${ArrayName}[${i},1].Equal[NULL]}) {
                /varset ${ArrayName}[${i},1] ${Spawn[${AddMobID}].ID}
                /varset ${ArrayName}[${i},2] ${Spawn[${AddMobID}].Level}
                /varset ${ArrayName}[${i},3] ${Spawn[${AddMobID}].CleanName}
                /if (${Debug}) /echo ARRAY Assign >> ${${ArrayName}[${i},3]} << to ${ArrayName}${i}. \agLine#: ${Macro.CurLine}
                /return
            }
        /next i
        /if (${Debug}) /echo \atDEBUG AddToArray Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Remove From Array
| -------------------------------------------------------------------------------------
    Sub RemoveFromArray(RArrayName, int ArNum)
        /if (${${RArrayName}[${ArNum},1].Equal[NULL]}) /return
        /if (${ArNum}<1 || ${ArNum}>${${RArrayName}.Size}) /return
        /if (${Debug}) /echo \atDEBUG RemoveFromArray ${ArNum} Enter \agLine#: ${Macro.CurLine}
        /if (${Debug}) /echo \atDEBUG ARRAY Remove >> ${${RArrayName}[${ArNum},3]} << from ${RArrayName}${ArNum}. \agLine#: ${Macro.CurLine}
        /varset ${RArrayName}[${ArNum},1] NULL
        /varset ${RArrayName}[${ArNum},2] NULL
        /varset ${RArrayName}[${ArNum},3] NULL
        /if (${MezOn} && ${ArNum}<=13) {
            /varset MezCount[${ArNum}] 0
            /varset MezTimer${ArNum} 0
        }
        /if (${Debug}) /echo \atDEBUG RemoveFromArray Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Do Mez Stuff
| -------------------------------------------------------------------------------------
    Sub DoMezStuff
        /doevents 
        /if (!${MezOn}) /return
        /if (${Me.Hovering}) /return
        /if (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]}) /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${DebugMez}) /echo \atDEBUGMEZ DoMezStuff: Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare j int local 0
        | Reset skip mez on health setting if tank dies to 1%
        /if (!${Spawn[=${MainAssist}].ID}) /varset MezStopHPs 1
        /call MezRadar
        /if (${DebugMez}) /echo DoMezStuff MezMobCount ${MezMobCount} \agLine#: ${Macro.CurLine}
        /if (${MezMobCount}<2 && ${Spawn[=${MainAssist}].ID}) {
                /if (${DebugMez}) /echo MezMobCount was ${MezMobCount} (so less than 2) & ${MainAssist} is alive so we return \agLine#: ${Macro.CurLine}
                /return
        }
        | Necros can't AE mez. But you don't need to sheck it twice.
        /if (${Select[${MezOn},1,3]} && ${MezAECount}>0 && ${MezMobAECount}>=${MezAECount} && ${MezAETimer}==0 && ${Select[${Me.Class.ShortName},BRD,ENC]})  {
            /if (${DebugMez}) /echo I'm about to AEMez \agLine#: ${Macro.CurLine}
            /if (${SpawnCount[npc xtarhater loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]}>=${SpawnCount[npc loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]})  /call MezMobsAE ${MezAEClosest}
        }
        /for i 1 to 13
            | Every Mez test conditon is listed seperately for clarity
            /if (${DebugMez}) /echo we are in the mezcondition loop i is: ${i} \agLine#: ${Macro.CurLine}
            | Test -> Is my single mez spell ready
            /if (!${Me.SpellReady[${MezSpell}]} && !${IAmABard}) {
                /if (${DebugMez}) /echo ${MezSpell} not ready, goto return \agLine#: ${Macro.CurLine}
                /return
            }
            | Test -> array not empty,
            /if (${MezArray[${i},1].Equal[NULL]}) {
                /if (${DebugMez}) /echo ${i}  MezArray[${i},1] was equal to NULL, goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            | Test -> Target is dead
            /if (${MezArray[${i},3].Find[corpse]} ||  !${Spawn[${MezArray[${i},1]}].ID}) {
                /if (${DebugMez}) /echo ${i}  ${MezArray[${i},3]} is dead, goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            | Is mob in MezRadius distance
            /if (${Spawn[${MezArray[${i},1]}].Distance}>=${MezRadius}) {
                /if (${DebugMez}) /echo ${i}  Mob distance is greater than MezRadius: ${Spawn[${MezArray[${i},1]}].Distance} goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            | Test -> is target MA's current Target
            /if (${Spawn[${MezArray[${i},1]}].ID}==${MyTargetID} && ${Spawn[=${MainAssist}].ID}) {
                /if (${DebugMez}) /echo ${Spawn[${MezArray[${i},1]}].Name} had the same ID(${Spawn[${MezArray[${i},1]}].ID}) as MyTargetID(${MyTargetID}) & ${MainAssist}(${Spawn[=${MainAssist}].ID}), goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            | Test -> is  MA's a merc skip 1st target so he attackes it.
            /if (${AggroTargetID} && !${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) {
                /if (${DebugMez}) /echo AggroTargetID = ${AggroTargetID}  MyTargetID = ${MyTargetID} & Spawn[=MainAssist].ID = ${Spawn[=${MainAssist}].ID} & Spawn[=MainAssist].Type.Equal[Mercenary] was true, goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
             | Test -> is taget above mez hps threshold
            /if (${Spawn[${MezArray[${i},1]}].PctHPs}<${MezStopHPs}) {
                /if (${DebugMez}) /echo Spawn[MezArray[${i},1]].PctHPs(${Spawn[${MezArray[${i},1]}].PctHPs}) was less than MezStopHPs(${MezStopHPs}), goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
             | Test -> is target within levels defined in ini file
            /if (${MezArray[${i},2]}>${MezMaxLevel} || ${MezArray[${i},2]}<${MezMinLevel}) {
                /if (${DebugMez}) /echo MezArray[${i},2](${MezArray[${i},2]}) was greater than MezMaxLevel(${MezMaxLevel}) OR less than MezMinLevel(${MezMinLevel}), goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
             | Test -> is the target in line of sight
            /if (!${Spawn[${MezArray[${i},1]}].LineOfSight}) {
			/if (${MoveCloserIfNoLOS} && ${Spawn[${MezArray[${i},1]}].Distance3D} < 50 && ${Navigation.MeshLoaded}) {
					|/beep
					/echo I cant see the mob lets move closer
		            		/nav id ${Spawn[${MezArray[${i},1]}].ID}
					/delay 5s ${Navigation.Active}
			} else {
				/if (${DebugMez}) /echo I dont have LineOfSight to Spawn[MezArray[${i},1]](${Spawn[${MezArray[${i},1]}].Name} ID:${Spawn[${MezArray[${i},1]}].ID}), goto :SkipMez \agLine#: ${Macro.CurLine}
				/goto :SkipMez
			}
            }
             | Test -> I am a bard and if the player is dumb enough to have me tank then don't mez.
            /if (${IAmABard} && ${MainAssist.Equal[${Me}]} && ${MyTargetID} && ${AggroTargetID} && ${MezArray[${i},1].Equal[${MyTargetID}]}) {
                /if (${DebugMez}) /echo im a bard and stuff, goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
             | Test -> is target a giant unmezzable
            /if (${Spawn[${MezArray[${i},1]}].Body.Name.Equal[Giant]}) {
                /if (${DebugMez}) /echo Spawn[MezArray[${i},1]] (${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]}) is a giant, goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
             | Test -> is target on my mez immune list
            /if (${Alert[4].Size}) {
                /for j 0 to ${Alert[4].Size}
                    /if (${Alert[4].List[${j}].Name.Equal[${MezArray[${i},3]}]} && ${Alert[4].List[${j}].Name.Length}) {
                        /if (${MMTimer${i}}==0) /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Immune Detected -> ${MezArray[${i},3]} <- ID:${MezArray[${i},1]}"
                        /varset MMTimer${i} 1m
                        /if (${DebugMez}) /echo ${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]} is immune, goto :SkipMez \agLine#: ${Macro.CurLine}
                        /goto :SkipMez
                    }
                /next j
            }
            | Test -> Do i have enough mana to cast the spell 
            /if (${Me.CurrentMana}<${Spell[${MezSpell}].Mana}) {
                /if (${DebugMez}) /echo i didnt have enough mana to cast ${MezSpell}, goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            | Test -> Do i have a mez timer on the mob?
            /if (${MezTimer${i}} > 0) {
                /if (${DebugMez}) /echo MezTimer${i}(${MezTimer${i}}) was greater than 0 , goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            | Stop mezzing last mob because pets and mercs won't attack it.
            /if (${MezMobCount}<=1 && ${Spawn[=${MainAssist}].ID} && (${Spawn[=${MainAssist}].Type.Equal[Mercenary]} || ${Spawn[=${MainAssist}].Type.Equal[Pet]})) {
                /if (${DebugMez}) /echo MezMobCount(${MezMobCount}) was less or equal to 1 & ( MainAssist(${MainAssist}) was a Mercenary OR a Pet ), goto :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            /if (${Spawn[${MainAssist} ${MainAssistType} group].ID} && ${Select[${MezArray[${i},1]},${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID}]}==0) {
                /if (${DebugMez}) /echo If tank is alive and mob not on xtarget go to :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            /if (${MezImmuneIDs.Find[|${MezArray[${i},1]}]}) {
                /if (${DebugMez}) /echo Mez Immune Mob Detected: ${MezArray[${i},3]} go to :SkipMez \agLine#: ${Macro.CurLine}
                /goto :SkipMez
            }
            /if (${DebugMez}) /echo \atDEBUGMEZ MezTimer${i} ${MezTimer${i}} ${Spawn[${MezArray[${i},1]}].ID} ${i} \agLine#: ${Macro.CurLine}
            /if (${Select[${MezOn},1,2]}) {
                /if (${DebugMez}) /echo im gonna singlemez ${MezArray[${i},1]} \agLine#: ${Macro.CurLine}
                /call MezMobs ${MezArray[${i},1]} ${i}
            }
            :SkipMez
        /next i
        /if (${DebugMez}) /echo \atDEBUGMEZ DoMezStuff: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs AE
| -------------------------------------------------------------------------------------
Sub MezMobsAE(int AEMezID)
    | Bard AE mez code
    /declare i int local 1
    /declare WasChasing int local 0
    /if (${IAmABard}) {
        /squelch /twist once ${Me.Gem[${MezAESpell}]}
        /call BroadCast ${IRCOn} ${EQBCOn} g "MEZZING-> AE Mezzing Now - ${MezAESpell} "
        /delay 35
        /varset MezAETimer 300
    }
    | Enchanter AE mez code
    /if (${Me.Class.Name.Equal[Enchanter]}) {
        /if (${ChaseAssist}) {
            /varset ChaseAssist 0
            /varset WasChasing 1
            /squelch /stick off
            /moveto off
            /if (${Bool[${Plugin[mq2navigation]}]}==TRUE || ${Bool[${Plugin[mq2nav]}]}==TRUE) {
				/if (${Navigation.Active}) {
					/echo 5 stopping nav 
					/nav stop
				}
				/delay 30 !${Me.Moving}
			}
		}
        /echo I AM AE MEZZING ${MezAESpell}
        /call CastWhat "${MezAESpell}" ${AEMezID} Mez
        /echo I JUST CAST AE MEZ ${MezAESpell}
        /delay 10 ${Me.SpellReady[${MezAESpell}]}
        /varset MezAETimer ${Spell[${MezAESpell}].Duration.TotalSeconds}s
        /if (${DebugMez}) /echo \atDEBUGMEZ TIMER SET ${MezAETimer} \agLine#: ${Macro.CurLine}
        /call BroadCast ${IRCOn} ${EQBCOn} g "AE MEZZING-> ${MezAESpell} "
        /if (${WasChasing}) /varset ChaseAssist 1
    }
    | Reset all mez timers to 0 after AE Mez
    /for i 1 to 30
        /varset MezTimer${i} 0
    /next i
/return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs
| -------------------------------------------------------------------------------------
    Sub MezMobs(int MobID, int TimerNum)
        /if (${DebugMez}) /echo \atDEBUGMEZ MezMobs Enter MobID:${MobID} Timer#:${TimerNum} \agLine#: ${Macro.CurLine}
        /declare MezFail int local 0
        /declare MezTry int local 1
        /declare ReMez int local 0
        /if (${Me.Combat}) {
                /attack off
                /delay 25 !${Melee.Combat}
        }
        /squelch /target id ${MobID}
        /delay 20 ${Target.ID}==${MobID} && ${Target.BuffsPopulated}==TRUE
        /if (${Target.ID}==${MobID}) {
            /if (${Int[${Target.Mezzed.ID}]} && ${Target.Mezzed.Name.Equal[${MezSpell}]}) {
                /if (${DebugMez}) /echo DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} Target Info: ${Target.Mezzed.ID} ${Target.Mezzed.Name} ${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds} Line#: ${Macro.CurLine}
                /if (${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds}>${Math.Calc[(${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*.10]}) {
                    /varcalc MezCount[${TimerNum}] 1
                    /varcalc MezTimer${TimerNum} (${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds}*10)*.85
                    /return
                }            
            }
            /if (${MezCount[${TimerNum}]}<1) {
                /call BroadCast ${IRCOn} ${EQBCOn} g "MEZZING-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
            } else {
                /call BroadCast ${IRCOn} ${EQBCOn} g "ReMEZZING-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                /varset ReMez 1
            }
            | Chanter mez code
            :retrymez
            /if (${Me.Class.Name.Equal[Enchanter]}) {
                /call CastWhat "${MezSpell}" ${MobID} Mez
                /varcalc MezFail ${MezFail}+1
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /if (!${ReMez})  /call BroadCast ${IRCOn} ${EQBCOn} g "JUST MEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                    /if (${ReMez})  /call BroadCast ${IRCOn} ${EQBCOn} g "JUST REMEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                    /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                    /varcalc MezTimer${TimerNum} ((${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*10)*.90
                    /if (${DebugMez}) /echo DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} Line#: ${Macro.CurLine}
                }
                /if (${Macro.Return.Equal[CAST_RESIST]} && ${MezFail}<2) {
                    /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                    /goto :retrymez
                }
                /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                    /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                }
            }
            | Bard mez code
            /if (${IAmABard}) {
                /squelch /twist once ${Me.Gem[${MezSpell}]}
                /delay 35
                /squelch /target clear
                /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                /varset MezTimer${TimerNum} 110
            }
            | Necro mez code
            /if (${Me.Class.Name.Equal[Necromancer]}) {
                /call CastWhat "${MezSpell}" ${MobID} Mez
                /call CheckCasting 50
                /varcalc MezFail ${MezFail}+1
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                    /varcalc MezTimer${TimerNum} ((${Spell[${MezSpell}].Duration.TotalSeconds}+${MezMod})*10)*.95
                    /if (${DebugMez}) /echo MezTimer${TimerNum} ${MezTimer${TimerNum}} Line#: ${Macro.CurLine}
                    | Necro flag to release from mez loop since spell has 6 sec refresh.
                }
                /if (${Macro.Return.Equal[CAST_RESIST]} && ${MezFail}<2) {
                    /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                    /goto :retrymez
                }
                /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                    /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                }
            }
            /varset MezTry 0
        }
    /if (${DebugMez}) /echo \atDEBUGMEZ MezMobs Leave \agLine#: ${Macro.CurLine}
    /return 
| -------------------------------------------------------------------------------------
| SUB: Do Debuff Stuff
| -------------------------------------------------------------------------------------
    Sub DoDebuffStuff(int FirstMobID)
        /if (${DebugCombat}) /echo \atDEBUGDEBUFF DoDebuffStuff: Enter \agLine#: ${Macro.CurLine}
        /doevents
        /if (!${DebuffAllOn} || !${DebuffCount} || ${Window[RespawnWnd].Open} || (${DMZ} && ${Me.InInstance}==FALSE) || (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]})) /return
        |/if (${Role.Find[tank]}) /return
        /if (${DPSPaused}) {
           /if (${DebugCombat}) /echo DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
           /return
        }
        /declare i               int      local 0
        /declare j               int      local 0
        /declare k               int      local 0
        /declare DebuffTargetID  int      local 0
        /declare DebuffText      string   local

        /if (${IAmABard} && ${MainAssist.Equal[${Me}]} && ${MyTargetID} && ${AggroTargetID}) {
           /if (${DebugCombat}) /echo im a bard and stuff so im getting out of here. Returning \agLine#: ${Macro.CurLine}
           /return
        }
        /call MobRadar ${MeleeDistance} DoDebuffStuff
        /for i 1 to ${DebuffCount}
           /if (${DBOList${i}.Length}) {
              /varset k 1
              /if (!${DBOTimer${i}}) {
                  | Reset the list with only the current DPS mob ID. So you won't try and debuff the mob again.
                 /varset DBOList${i} |${MyTargetID}
              } else {
                 |Remove mobs from list that are dead or over 200 units away.
                 /while (${DBOList${i}.Arg[${k},|].Length}) {
                    /if (!${Spawn[${DBOList${i}.Arg[${k},|]}].ID} || ${Spawn[${DBOList${i}.Arg[${k},|]}].Distance}>200 || ${Spawn[${DBOList${i}.Arg[${k},|]}].Type.Equal[Corpse]}) {
                       /varset DBOList${i} ${DBOList${i}.Replace[|${DBOList${i}.Arg[${k},|]},]}
                    } else {
                       /varcalc k ${k}+1
                    }
                 }
              }
           }
        /next i
        | For Mobs
        /if (${DebugCombat}) /echo MobCount was ${MobCount} MainAssist: ${MainAssist} FirstMobID: ${FirstMobID} MyTargetID: ${MyTargetID} \agLine#: ${Macro.CurLine}
        /call DebuffCast "${FirstMobID}" 1
        /for j 1 to 13
           |--- only call code for GroupEscape kick off.
           /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
           /if (${DPSPaused}) {
              /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
              /return
           }
           /if (!${Me.XTarget[${j}].ID} || (${Me.XTarget[${j}].ID}==${FirstMobID})) /goto :SkipMob
           | Every Debuff test conditon is listed seperately because Maskoi forgets why he does anything.
           /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: we are in the debuffcondition loop j is: ${j} \agLine#: ${Macro.CurLine}
           | Is Xtarget type not of type auto hater
           /if (${Me.XTarget[${j}].TargetType.NotEqual[Auto Hater]} || ${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[Corpse]}) {
              /if (${DebugCombat}) /echo XTarget Type: ${Me.XTarget[${j}].TargetType} Spawn Type: ${Spawn[${Me.XTarget[${j}].ID}].Type}  \agLine#: ${Macro.CurLine}
              /goto :SkipMob
           }
           | Is mob in spell Radius distance
           /if (${Spawn[${Me.XTarget[${j}].ID}].Distance}>=${MeleeDistance}) {
              /if (${DebugMez}) /echo \atDEBUGCOMBAT DoDebuffStuff: ${j}  Mob distance is greater than MeleeDistance: ${Spawn[${Me.XTarget[${j}].ID}].Distance} goto :SkipMob \agLine#: ${Macro.CurLine}
              /goto :SkipMob
           }
           | Test -> is the target in line of sight
		   /if (!${Spawn[${Me.XTarget[${j}].ID}].LineOfSight}) {
				/if (${MoveCloserIfNoLOS} && ${Spawn[${Me.XTarget[${j}].ID}].Distance3D} < 50 && ${Navigation.MeshLoaded}) {
					|/beep
					/echo I cant see the mob lets move closer 2
				   	/nav id ${Me.XTarget[${j}].ID}
					/delay 5s ${Navigation.Active}
				} else {
					/if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff: I dont have LineOfSight to Spawn[${Me.XTarget[${j}].ID}] ${Spawn[${Me.XTarget[${j}].ID}].Name} so im going to :SkipMob \agLine#: ${Macro.CurLine}
				    /goto :SkipMob
				}
           }
           /varset DebuffTargetID ${Me.XTarget[${j}].ID}
           /if (${DebugCombat}) {
		/echo \atDEBUGCOMBAT DoDebuffStuff Target: ${DebuffTargetID}=${Target.ID} Timer: ${DBOTimer${j}} DebuffAllOn: ${DebuffAllOn} J: ${j} \agLine#: ${Macro.CurLine}
           }
	   /if (${Me.Combat} && (${MainAssist.NotEqual[${Me}]} || ${DebuffTargetID}!=${Target.ID})) {
              /attack off
              /delay 10 !${Me.Combat}
           }
           | ****************  For Spells  *****************************
              /if (${DebuffAllOn}==2) {
                 /call DebuffCast "${DebuffTargetID}" 1 
              } else {
                 /call DebuffCast "${DebuffTargetID}" 0
              }
           :SkipMob
           /if (${DebugCombat}) /echo \atDEBUGCOMBAT DoDebuffStuff 4.0 \agLine#: ${Macro.CurLine}
           | Reset values if 3rd value in dps for All
           /varset DebuffTargetID ${MyTargetID}
           | ************ Next Mob ***************
        /next j
        :SkipDoDebuff
        /if (${Target.ID}!=${MyTargetID}) {
           /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]}) {
              /target id ${MyTargetID}
              /delay 1s ${Target.ID}==${MyTargetID}
           }
        }
        /if (${DebugCombat}) /echo \atDEBUGDEBUFF DoDebuffStuff: Leave \agLine#: ${Macro.CurLine}
    /return
|--------------------------------------------------------------------------------
| SUB: Event DebuffCast
| -------------------------------------------------------------------------------------
    Sub DebuffCast(int DebuffTargetID, int FWait)
        /declare c               int      local 0
        /declare f               int      local 0
        /declare f1              int      local 0
        /declare g               int      local 0
        /declare i               int      local 0
        /declare DebuffText      string   local
        /declare TempTimer       timer    local 0
        /declare Tag1            string   local
        /declare Tag2            string   local 
        /declare echoTimer       timer    local 0
        | ****************  For Spells  *****************************
        /if (${DebugCombat}) /echo DebuffCast Enter. \agLine#: ${Macro.CurLine}
        | g  - is control variable for remaining in loop while checking for mobs to debuff and spell is ready to cast.
        | c  - is to tell if the current mob is NOT on the Debuffed List or the debufftimer has runout. c=1 mob needs debuff, c=0 Mob can be skipped
        | f  - is a flag that is changed if we find a mob to debuff, but the current Spell or AA is not ready for casting, f=1 Spells/AA's were ready, f=0 Spell/AA not ready.
        | i  - is the index of the debuff to cast.
        | !${c} This mob has all debuffs, !${f} There is a debuff that was not ready for this mob.
        /while (1) {
           /varset TempTimer 70
           /varset g 1
           /while (${g} && ${TempTimer}) {
              /varset c 0
              /varset f 1
              /if (${i}==${DebuffCount}) /varset i 0
              /while (${f} && ${i}<${DebuffCount}) {
                 /varset f1 0
                 /varcalc i ${i}+1
                 /varset DebuffText ${DPS[${i}].Arg[1,|]}
                 /if (${DebugCombat}) /echo ${DebuffText} ${DPS[${i}].Length}  ${DebuffText.NotEqual[null]} ${DBOList${i}.Find[|${DebuffTargetID}]} ${DBOTimer${i}} ${i} ${DebuffCount} ${TempTimer} \agLine#: ${Macro.CurLine}                 
                 |If mob not on list or debuff timer expired then increment counter of mobs needing debuff.
                 /if (${DPS[${i}].Length} && ${DebuffText.NotEqual[null]} && (!${DBOList${i}.Find[|${DebuffTargetID}]} || ${DBOTimer${i}}==0)) {
                    /varset c 1
                    | is spell or AA ready to cast? If ready set flag to drop out of loop.
                    /if (${Select[TRUE,${Me.SpellReady[${DebuffText}]},${Me.AltAbilityReady[${DebuffText}]},${Me.ItemReady[=${DebuffText}]}]}) {
                       /varset f 0
                    } else {
                       /if (${FWait} && !${echoTimer}) {
                          /varset f1 ${Select[TRUE,${Bool[${Me.Book[${DebuffText}]}]},${Bool[${Me.AltAbility[${DebuffText}]}]},${Bool[${FindItem[=${DebuffText}].ID}]}]}
                          | This is a spell.
                          /if (${f1}==1) {
                             /if (${Me.SpellInCooldown}) {
                                /if (${Int[${Me.Gem[${DebuffText}]}]}) {
                                   /if (!${Me.GemTimer[${DebuffText}]}) {
                                      /echo Waiting on Spell Global Cool Down To Cast ${DebuffText}
                                      /varset echoTimer 3s
                                   }
                                }
                             } else /if (${Int[${Me.Gem[${DebuffText}]}]} && ${Me.GemTimer[${DebuffText}]}) {
                                /echo Waiting on Spell: ${DebuffText} to Refresh. Time Remaining: ${Me.GemTimer[${DebuffText}].TotalSeconds} Seconds.
                                /varset echoTimer ${Me.GemTimer[${DebuffText}]}
                             }
                             | This is an AltAbility
                          } else /if (${f1}==2) {
                             /if (${Me.AltAbilityTimer[${DebuffText}]}<=${TempTimer}) {
                                 /echo Waiting on AltAbility To Cast ${DebuffText}
                                 /varset echoTimer 3s
                             }
							 | else {
                                |/echo Skipping AltAbility. Wait time is to long for ${DebuffText}
                             |}
                             | This is an Item
                          } else /if (${f1}==3) {
                             /if (${Math.Calc[${FindItem[=${DebuffText}].TimerReady}*10]}<=${TempTimer}) {
                                 /echo Waiting on Item To Cast ${DebuffText}
                                 /varset echoTimer 3s
                             }
							 | else {
                                |/echo Skipping Item. Wait time is to long for ${DebuffText}
                             |}                          
                          }
                       }
                    }
                 }
              }
              /if (${DebugCombat}) /echo ${c} ${f}  ${FWait} \agLine#: ${Macro.CurLine}
              /if (!${c} || !${f} || (${f} && !${FWait})) /varset g 0 
           }
           /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast 0 DebuffTargetID: ${DebuffTargetID} ${i} C: ${c} F: ${f} FWait: ${FWait} \agLine#: ${Macro.CurLine}
           /if (${MezOn}) /varset MezBroke 0
           /doevents
           /if (${DPSPaused}) {
              /if (${DebugCombat}) /echo DebuffCast: Return from DebuffCast cause DPSPaused is ${DPSPaused} \agLine#: ${Macro.CurLine}
              /return
           }
           /if (!${c} || ${g} || (${f} && !${FWait})) {
              /if (${DebugCombat}) /echo DebuffCast Exit. \agLine#: ${Macro.CurLine}
              /return
           }
           /if (${DebugCombat}) {
		/echo \atDEBUGCOMBAT DebuffCast 1 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} \agLine#: ${Macro.CurLine}
           }
	   /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
           /if (${MezOn} && !${MezBroke}) /call DoMezStuff
           /varset TempTimer 0
           /varset Tag1 ${DPS[${i}].Arg[4,|]}
           /varset Tag2 ${DPS[${i}].Arg[5,|]}
           /if (${Tag1.Equal[always]}) /varset Tag2 always
           | Test -> Do i have enough mana to cast the spell 
           /if (${Me.CurrentMana}<${Spell[${DebuffText}].Mana}) {
              /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: i didnt have enough mana to cast ${DebuffText} so im going to :SkipCast \agLine#: ${Macro.CurLine}
              /goto :SkipCast
           }
           /if (${Spawn[${DebuffTargetID}].Type.Equal[Corpse]} || ${Int[${Spawn[${DebuffTargetID}].ID}]}==0) /return
           /target id ${DebuffTargetID}
           /delay 50 ${Target.ID}==${DebuffTargetID} && ${Target.BuffsPopulated}==TRUE
           /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: Debuff: ${DebuffText} TargetID: ${Target.ID} DebuffTargetID: ${DebuffTargetID} : ${Target.Buff[${DebuffText}].ID} ${Target.Buff[${DebuffText}].Caster} ${Me.SpellInCooldown} ${Tag1} ${Tag2} \agLine#: ${Macro.CurLine}
           | Check Target for Buffs
           /if (${Target.BuffCount}) {
              | Does the Target have the debuff I am about to cast
              /if (${Target.Buff[${DebuffText}].ID}) {
                 /if (${Target.Buff[${DebuffText}].Caster.Equal[${Me.CleanName}]} || (${Target.Buff[${DebuffText}].Caster.NotEqual[${Me.CleanName}]} && ${Tag2.NotEqual[always]})) {
                    /varcalc TempTimer ${Target.BuffDuration[${DebuffText}].TotalSeconds}*10
                 }
              }
              | If timer didn't get set above then check this
              /if (${TempTimer}==0) {          
                  | Does the mob have one of the following debuffs if so lets skip casting
                  /if (${Tag1.Equal[strip]} && (${Int[${Target.Beneficial.ID}]}==0 || ${Int[${Target.Beneficial.ID}]}==38728 || ${Int[${Target.Beneficial.ID}]}==38727 || ${Int[${Target.Mezzed.ID}]})) {
                     /varset TempTimer 70
                  } else /if (${Tag2.NotEqual[always]}) {
                     /if (${Tag1.Equal[slow]} && ${Target.Slowed.ID}) {
                        /varcalc TempTimer ${Target.BuffDuration[${Target.Slowed.Name}].TotalSeconds}*10
                     } else /if (${Tag1.Equal[tash]} && ${Target.Tashed.ID}) {
                        /varcalc TempTimer ${Target.BuffDuration[${Target.Tashed.Name}].TotalSeconds}*10
                     } else /if (${Tag1.Equal[malo]} && ${Target.Maloed.ID}) {
                        /varcalc TempTimer ${Target.BuffDuration[${Target.Maloed.Name}].TotalSeconds}*10
                     } else /if (${Tag1.Equal[crip]} && ${Target.Crippled.ID}) {
                        /varcalc TempTimer ${Target.BuffDuration[${Target.Crippled.Name}].TotalSeconds}*10
                     } else /if (${Tag1.Equal[snare]} && ${Target.Snared.ID}) {
                        /varcalc TempTimer ${Target.BuffDuration[${Target.Snared.Name}].TotalSeconds}*10
                     }
                  }
              }
              /if (${TempTimer}) {
                 /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                 /goto :SkipCast
              }
              /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: DebuffTargetID: ${DebuffTargetID} Slowed: ${Target.Slowed.ID} Tashed: ${Target.Tashed.ID} Maloed: ${Target.Maloed.ID} Crippled:${Target.Crippled.ID} Tag1: ${Tag1} Tag2: ${Tag2} TempTimer: ${TempTimer} \agLine#: ${Macro.CurLine}
           } 
           /if (${HealsOn}) /call CheckHealth
           | Wait here for a sec, your spell bar may still be in global cool down.
           /if (${Me.SpellInCooldown}) {
              /delay 10
           }
           | When you get here you won't want to cast Eradicate Magic if the mob has NO Beneficial Buffs
           /if (${Tag1.Equal[strip]} && (${Int[${Target.Beneficial.ID}]}==0 || ${Int[${Target.Mezzed.ID}]})) {
               /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
               /varset TempTimer 70
               /goto :SkipCast
           }
           | Conditional Check Added.
			/if (${ConditionsOn}) {
				/if (${DPSCOn}) {
					|/echo Why the embedded If? 
					| This is like checking If twice...
					/if (${If[${DPSCond[${i}]},0,1]}) {
						|/if (${i}==1) {
							|/echo The DPSCond${i} (${DPSCond[${i}]}==FALSE) for ${DPS[${i}]} returned FALSE so we skip it.
						|}
						/goto :SkipCast
					} else {
						|/echo The DPSCond${i} (${DPSCond[${i}]}==TRUE) for ${DPS[${i}]} returned TRUE so we move on!
					}
				}
		   }
           | Everything is ready, lets debuff this mob
           /call CastWhat "${DebuffText}" ${DebuffTargetID} DebuffCast
           /if (${DebugCombat}) /echo \atDEBUGCOMBAT DebuffCast: Return From CastWhat: ${Macro.Return} \agLine#: ${Macro.CurLine}
           /if (${Macro.Return.Equal[CAST_RESIST]}) {
               /echo [${Time}] ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - RESISTED
               /goto :SkipCast
           }
           /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
              /echo [${Time}] ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - DID NOT TAKE HOLD
              /varset TempTimer 3m
              /goto :SkipCast
           }
           /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
              /echo [${Time}] ** ${Spawn[${DebuffTargetID}].CleanName} is IMMUNE to - ${DebuffText}
              /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
              /varset TempTimer 3m
              /goto :SkipCast
           }
           /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
              /echo [${Time}] ** Debuffing: ==> ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << DebuffTargetID: ${DebuffTargetID} Target: ${Target.ID} DBOList: ${DBOList${i}}
              /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
              | Timers for items    
              /if (${FindItemCount[=${DebuffText}]}) {
                 /varcalc TempTimer ${FindItem[=${DebuffText}].Spell.Duration.TotalSeconds}*10
                 | Timers for AltAbilities
              } else /if (${Me.AltAbility[${DebuffText}]}) {
                 /varset TempTimer ${Me.AltAbility[${DebuffText}].ReuseTime}s
                 | Timers for spells
              } else /if (${Me.Book[${DebuffText}]}) {
                 | - Custom timer for counterbias
                 /if (${Me.Class.Name.Equal[Shaman]} && ${DebuffText.Find[counterbias]}) {
                    /varset TempTimer 1.5m
                    | Custom timer for Chanter suffocation
                 } else /if (${Me.Class.Name.Equal[enchanter]} && ${DebuffText.Find[suffocation]}) {
                    /varset TempTimer 1m
                    | Custom timer for Beastlord Feralgia Timer
                 } else /if (${Me.Class.Name.Equal[Beastlord]} && ${DebuffText.Find[feralgia]}) {
                    /varset TempTimer 1.5m
                    | Regular spells
                 } else /if (${Spell[${DebuffText}].Duration}>0) {
                    /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                    | Spells with no timers assign DPS interval
                 } else {
                    /varset TempTimer ${DPSInterval}s
                 }
                 | AA and disc timers
              } else /if (${Spell[${DebuffText}].Duration}>0) {
                 /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                 | AA and disc with no timers assign DPS interval
              } else {
                 /varset TempTimer ${DPSInterval}s
              }
           |}
           :SkipCast
           | Check Debuff Timer not set and the Temp Timer has been set.
           | You only want to set the DBOTimer for the first mob you get the Debuff to land on. Don't need a timer for every mob.
           /if (!${DBOTimer${i}} && ${TempTimer}) {
              /varcalc DBOTimer${i} ${TempTimer}*.95
           }
        }
        | ************ Next Spell ***********
        	/if (${DebugCombat}) {
			/echo \atDEBUGCOMBAT DebuffCast 2 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} \agLine#: ${Macro.CurLine}
        	}
	}
        /if (${DebugCombat}) /echo DebuffCast Exit. \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezBroke
| -------------------------------------------------------------------------------------
Sub Event_MezBroke(meztext,mezmob,mezbreaker)
    /if (${DebugMez}) /echo \atDEBUGMEZ event mezbroke Enter \agLine#: ${Macro.CurLine}
        /if (!${MezOn}) /return
        |/if (${MyTargetID}==${Spawn[${mezmob}].ID}) /return
        /if (${Spawn[${mezbreaker}].CleanName.Equal[${MainAssist}]}) /return
        /if (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[${MainAssist}].Master.CleanName.Equal[${mezbreaker}]}) /return
        /declare tempMobID int local ${Target.ID}
        /assist ${mezbreaker}
        /delay 5s ${Me.AssistComplete}==TRUE
        /if (${Target.ID} && ${Target.ID}==${MyTargetID}) {
           /target id ${tempMobID}
           /delay 10 ${Target.ID}==${tempMobID}
           /return
        }
        /declare i int local
        /call BroadCast ${IRCOn} ${EQBCOn} g ">>  ${Spawn[${mezbreaker}].CleanName} << has awakened -> ${mezmob}<-"
        /for i 1 to 30
            /if (${MezArray[${i},3].Equal[${mezmob}]}) {
                /echo Resetting Mez Timer ${mezmob} ID: ${MezArray[${i},1]}
                /varset MezTimer${i} 0
            }
        /next i
        /doevents flush MezBroke
        /call DoMezStuff
        | Set MezOn = 2 to let us know that the event was triggered. Will be set back to 1 in other location
        /varset MezBroke 1
    /if (${DebugMez}) /echo \atDEBUGMEZ event mezbroke Leave \agLine#: ${Macro.CurLine}
/return
| -------------------------------------------------------------------------------------
| SUB: Event MezImmune
| -------------------------------------------------------------------------------------
    Sub Event_MezImmune(int MezID)
    /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
        | Assign temp var MezImmune list
        /declare ImmuneAdd string local ${MezImmune}
        | If mezimmune default text with the word null in it assign var spawn clean name
        /if (${ImmuneAdd.Find[null]}) {
            /varset ImmuneAdd ${Spawn[${MezID}].CleanName}
        } else {
            /varset ImmuneAdd ${ImmuneAdd},${Spawn[${MezID}].CleanName}
        }
        /if (!${MezImmune.Find[${Spawn[${MezID}].CleanName}]}) /ini "${InfoFileName}" "${Zone}" "MezImmune" "${ImmuneAdd}"
        /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Adding to MezImmune list."
        | Reassign mezimmune var the new list
        /varset MezImmune ${ImmuneAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: AddMezImmune
| -------------------------------------------------------------------------------------
    Sub AddMezImmune(int MezID)
    /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
    /if (${MezImmuneIDs.Find[|${MezID}]}) /return
    /varset MezImmuneIDs ${MezImmuneIDs}|${MezID} 
    /call BroadCast ${IRCOn} ${EQBCOn} g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Skipping."
    /return

Sub CrapTest

/return 1

Sub PlayersInGroup
	/call CrapTest
	/echo CrapTest returned ${Macro.Return}
	/declare i int local 0
	/declare gcnt int local 0
	/for i 1 to ${Group.Members}
		/if (${Group.Member[${i}].Type.Equal[PC]}) {
			/varcalc gcnt ${gcnt}+1
		}
	/next i
/return ${gcnt}

Sub Bind_DoHalfCircle(string radius)
	/echo [${Time} - StackSize = ${Macro.StackSize}] halfmoon bind called radius is ${radius}
	/declare GrpCount int local 0
	/call PlayersInGroup
	/varset GrpCount ${Macro.Return}
	/if (!${GrpCount}) {
		/echo no members in the group to order around, returning
		/return
	}
	/declare i int local 0
	/declare XOff float local 0
	/declare YOff float local 0
	/declare XMove float local 0
	/declare YMove float local 0
	/declare BaseRadians local
	/declare Multiplier local 90
	/if (${GrpCount}==2) {
		/varset Multiplier 318
	} else /if (${GrpCount}==3) {
		/varset Multiplier 270
	} else /if (${GrpCount}==4) {
		/varset Multiplier 245
	} else /if (${GrpCount}==5) {
		/varset Multiplier 196
	}
	/declare MyHeading float local ${Math.Calc[${Me.Heading.Degrees} - ${Multiplier}]}
	/declare BaseRadian float local ${Math.Calc[180 / ${GrpCount}]}
	/echo I have ${GrpCount} players in my Group and my radian is ${BaseRadian}
	/for i 1 to ${Group.Members}
		/if (${Group.Member[${i}].Type.Equal[PC]}) {
			/varcalc XMove ${Math.Cos[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc YMove ${Math.Sin[ ${BaseRadian} * ${Float[${i}]} + (${MyHeading}) ]}
			/varcalc XOff ${Me.X} + ( ${Int[${radius}]} * ${XMove} )
			/varcalc YOff ${Me.Y} + ( ${Int[${radius}]} * ${YMove} )
			/bct ${Group.Member[${i}]} //sheepmove ${Me.ID} ${YOff} ${XOff}
		}
	/next i
	/echo Done with Pattern: HalfMoon
/return

Sub Bind_SheepMove(int shepherdID, int l_YLoc, int l_XLoc)
	/echo shepherdID=${shepherdID} l_YLoc=${l_YLoc} l_XLoc=${l_XLoc}
	/if (!${shepherdID}) {
		/echo cant invoke sheepmove, not enough arguments supplied
		/return
	}
	/declare oldRTC int local 0
	/declare oldChase int local 0
	/if (${Bool[${Plugin[mq2moveutils]}]}==TRUE) {
		/varset oldRTC ${ReturnToCamp}
		/varset oldChase ${ChaseAssist}
		/if (${Bool[${Plugin[mq2advpath]}]}==TRUE) {
        	       	/play off
 		}
		/if (${Bool[${Plugin[mq2navigation]}]}==TRUE || ${Bool[${Plugin[mq2nav]}]}==TRUE) {
        		/if (${Navigation.Active}) {
				/nav stop
			}
        	}
		/call Bind_ToggleVariable ReturnToCamp off
		/call Bind_ToggleVariable ChaseAssist off
        	/if (${MoveTo.Moving}) /moveto off
		/if (${Stick.Active}) /squelch /stick off
		/moveto mdist 3
		/moveto loc ${l_YLoc} ${l_XLoc}
		/delay 3s ${MoveTo.Moving}
		/echo woohooo, im a sheep moving and waiting up to 30s for me to stop!
		/delay 30s !${MoveTo.Moving}
		/delay 1s
		/moveto mdist 5
		/echo I have arrived at ${Me.X} ${Me.Y}
		/face id ${shepherdID}
		/if (${oldChase}) /call Bind_ToggleVariable ChaseAssist on
		/if (${oldRTC}) /call Bind_ToggleVariable ReturnToCamp on
	} else {
		/echo SheepMove failed because you don't have mq2moveutils loaded.
	}
/return

| -------------------------------------------------------------------------------------
| SUB: Bind AddMezImmune
| -------------------------------------------------------------------------------------
    Sub Bind_AddMezImmune(MTImmune)
        /if (!${MTImmune.Length} || ${MTImmune.Find[null]} || ${Spawn[${MTImmune}].ID}==${Me.ID} ) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MezImmune list
        /declare MezImmuneAdd string local ${MezImmune}
        | If MezImmune default text with the word null in it assign var spawn clean name
        /if (${MezImmuneAdd.Find[null]} && ${MezImmune.Find[null]}) {
            /varset MezImmuneAdd ${Spawn[${MTImmune}].CleanName}
        } else {
            /varset MezImmuneAdd ${MezImmune},${Spawn[${MTImmune}].CleanName}
        }
        | Remove's corpse if closest match is a mob corpse
        /if (${MezImmuneAdd.Right[-10].Find[corpse]}) /varset MezImmuneAdd ${MezImmuneAdd.Right[-8]}
        /if (${MezImmune.Find[${Spawn[${MTImmune}].CleanName}]}) {
            /echo >> ${Spawn[${MTImmune}].CleanName} << already on Mez Immune List.
            /return
        }
        /if (${Spawn[${MTImmune}].CleanName.Equal[null]}) {
            /echo No Mob with ${MTImmune} in Name detected.
            /return
        }
        /if (!${MezImmune.Find[${Spawn[${MTImmune}].CleanName}]}) {
            /ini "${InfoFileName}" "${ZoneName}" "MezImmune" "${MezImmuneAdd}"
            /echo MezImmune -> ${Spawn[${MTImmune}].CleanName} <- Adding to Mez Immune  list.
        }
        | Reassign MezImmune var the new list
        /varset MezImmune ${MezImmuneAdd}
    /return    
| -------------------------------------------------------------------------------------
| SUB: Bind AddToIgnore
| -------------------------------------------------------------------------------------
    Sub Bind_AddToIgnore(MTIgnore)
        | Take the targeted mob as a parameter for mob to ignore.
        /if (!${Defined[MTIgnore]}) /declare MTIgnore string local ${Target.CleanName}
        /if (${MTIgnore.Equal[null]} || !${Spawn[${MTIgnore}].Type.Equal[NPC]} || ${Spawn[${MTIgnore}].CleanName.Equal[null]}) {
            /echo No NPCs named (${MTIgnore}) detected. Nothing added to list.
            /return
        }
        | Assign temp var   list
        /declare IgnoreAdd string local ${MobsToIgnore}
        | If MobsToIgnore default text with the word null in it assign var spawn clean name
        /if (${IgnoreAdd.Find[null]}) {
            /varset IgnoreAdd ${Spawn[${MTIgnore}].CleanName}
        } else {
            /varset IgnoreAdd ${IgnoreAdd},${Spawn[${MTIgnore}].CleanName}
        }  
        | Remove's corpse if closest match is a mob corpse
        /if (${IgnoreAdd.Right[-10].Find[corpse]}) /varset IgnoreAdd ${IgnoreAdd.Right[-8]}
        /if (${MobsToIgnore.Find[${Spawn[${MTIgnore}].CleanName}]}) {
            /echo >> ${Spawn[${MTIgnore}].CleanName} << already on Ignore List.
            /return
        }
        /ini "${InfoFileName}" "${ZoneName}" "MobsToIgnore" "${IgnoreAdd}"
        /echo AddToIgnore -> ${Spawn[${MTIgnore}].CleanName} <- Adding to Ignore list.
        | Reassign MobsToIgnore var the new list
        /varset MobsToIgnore ${IgnoreAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddToPull
| -------------------------------------------------------------------------------------
    Sub Bind_AddToPull(MTPull)
        /if (!${MTPull.Length} || ${MTPull.Find[null]} || ${Spawn[${MTPull}].ID}==${Me.ID} ) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MobsToPull list
        /declare PullAdd string local ${MobsToPull}
        | If MobsToPull default text with the word null in it assign var spawn clean name
        /if (${PullAdd.Find[all]}) {
            /varset PullAdd ${Spawn[${MTPull}].CleanName}
        } else {
            /varset PullAdd ${PullAdd},${Spawn[${MTPull}].CleanName}
        }
        | Remove's corpse if closest match is a mob corpse
        /if (${PullAdd.Right[-10].Find[corpse]}) /varset PullAdd ${PullAdd.Right[-8]}
        /if (${MobsToPull.Find[${Spawn[${MTPull}].CleanName}]}) {
            /echo >> ${Spawn[${MTPull}].CleanName} << already on Pull List.
            /return
        }
        /if (${Spawn[${MTPull}].CleanName.Equal[null]}) {
            /echo ERROR: No Mob with ${MTPull} in Name detected.
            /return
        }
        /if (!${MobsToPull.Find[${Spawn[${MTPull}].CleanName}]}) {
            /ini "${InfoFileName}" "${ZoneName}" "MobsToPull" "${PullAdd}"
            /echo AddToPull-> ${Spawn[${MTPull}].CleanName} <- Adding to Pull list.
        }
        | Reassign MobsToPull var the new list
        /varset MobsToPull ${PullAdd}
    /return
| ----------------------------------------------------------------------------
| SUB: Add a friend to mq2posse list
| ----------------------------------------------------------------------------
    Sub Bind_AddAFriend
        /declare AFriend string local ${Target.CleanName}
        /if (!${Target.ID} || ${Spawn[${Target.ID}].Type.NotEqual[pc]} || ${Target.ID}==${Me.ID}) {
            /echo --ADDFRIEND: Target a PC to add your Posse list.
            /return
        }
        /docommand /posse add ${AFriend}
        /docommand /posse save
        /docommand /posse load
    /return    
| -------------------------------------------------------------------------------------
| SUB: Bind_ToggleVariable  Check whenever the player is changing any variable via /echo
| -------------------------------------------------------------------------------------
Sub Bind_ToggleVariable(string Command, string Command2, string Command3)
	/echo ${Time} ${Command} ${Command2} ${Command3}
    /declare i int local
    /declare OnOff local
    | Toggle Variables & Set Variables
    /if (${Command2.Length}) {
        /if (${Select[${Command2},0,off]}) {
            /varset ${Command} 0
            /varset OnOff Off
        } else /if (${Select[${Command2},1,on]}) {
            /varset ${Command} 1
            /varset OnOff On
        } 
    } else /if (${${Command}}) {
        /varset ${Command} 0
        /varset OnOff Off
        /if (!${ChaseAssist} && ${Stick.Active})  /squelch /stick off
    } else {
        /varset ${Command} 1
        /varset OnOff On
    }
	/if (${Command.Find[Debug]}) {
        /if (${Everquest.CurrentUI.NotEqual[Default]}) {
            /echo You are using a Custom UI. Please switch to Default UI before Posting.
        }
    }
    /echo >> Setting: (${Command}) to (${If[${Select[${OnOff},on,1]}>0,On,Off]})
    /if (${Command.Equal[ChaseAssist]} && ${OnOff.Equal[on]} ) {
        /if (${ReturnToCamp}) /varset ReturnToCamp 0
    } else /if (${Command.Equal[ReturnToCamp]} && ${OnOff.Equal[on]}) {
        /varset CampXLoc ${Me.X}
        /varset CampYLoc ${Me.Y}
        /varset CampZLoc ${Me.FloorZ}
        /varset LookForward ${Me.Heading.DegreesCCW}
        | Turn off ChaseAssit if on
        /if (${ChaseAssist}) {
            /varset ChaseAssist 0
            /if (${Stick.Active}) /squelch /stick off
            /echo >> ChaseAssist Off
        }
        /echo >> New camp set ${Me.Y}, ${Me.X}
    } else /if (${Command.Equal[conditions]}) {
        /if (${Command2.Equal[all]}) {
            /if (${Select[${Command3},1,on]}) {
                /varset ConditionsOn 1
                /varset GoMCOn 1
                /varset DPSCOn 1
                /varset HealsCOn 1
                /varset BurnCOn 1
                /varset BuffsCOn 1
            } else {
                /varset ConditionsOn 0
                /varset GoMCOn 0
                /varset DPSCOn 0
                /varset HealsCOn 0
                /varset BurnCOn 0
                /varset BuffsCOn 0
            }
            /echo >> Setting: (${Command}) ${Command2} to (${If[${Select[${Command3},on,1]}>0,On,Off]})
        } else /if (${Select[${Command2},on,off,1,0]}>0) {
            /if (${Select[${Command2},1,on]}) {
                /varset ConditionsOn 1
            } else {
                /varset ConditionsOn 0
            }
            /echo >> Setting: (ConditionsOn) to (${If[${ConditionsOn},On,Off]})
        } else {
            /if (${Select[${Command3},1,on]}) {
                /varset OnOff 1
            } else {
                /varset OnOff 0
            }
            /if (${Command2.Equal[gom]}) {
                /varset GoMCOn ${OnOff}
            } else /if (${Command2.Equal[dps]}) {
                /varset DPSCOn ${OnOff}
            } else /if (${Command2.Equal[heals]}) {
                /varset HealsCOn ${OnOff}
            } else /if (${Command2.Equal[burn]}) {
                /varset BurnCOn ${OnOff}
            } else /if (${Command2.Equal[buffs]}) {
                /varset BuffsCOn ${OnOff}
            } 
            /echo >> Setting: (${Command}) ${Command2} to (${OnOff})
        }
	}
/return
| -------------------------------------------------------------------------------------
| SUB: DoMiscStuff
| -------------------------------------------------------------------------------------
    Sub DoMiscStuff
    /if (!${ChainPull} && (${CombatStart} || ${AggroTargetID})) /return
    /if (${Debug}) /echo \atDEBUG DoMiscStuff Enter \agLine#: ${Macro.CurLine}
        /if (${Window[alertwnd].Open}) /nomodkey /notify alertwnd ALW_Close_Button leftmouseup
        | Accept trades
        /if (${Window[TradeWnd].Open} && ${Window[TradeWnd].HisTradeReady} && !${Cursor.ID}) /notify TradeWnd TRDW_Trade_Button leftmouseup
        | Accept group invite
        /if (${Window[GroupWindow].Child[GW_FollowButton]} && ${AcceptInvitesOn}) /invite
        | Open HoTT window if available
        /if (${HoTTOn} && !${Window[TargetOfTargetWindow].Open}) /windowstate TargetOfTargetWindow open
        | Ditch wizards familiar
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]} && ${Me.Class.ShortName.Equal[Wiz]}) /pet get lost
        | Drop random items on cursor like drive by mod rods into inventory after 30s min
        /if (${Cursor.ID} && !${CursorIDTimer}) {
            /varset CursorIDTimer 20s
            /if (${Me.FreeInventory}) {
                /echo ${Cursor.Name} is stuck on my cursor. Dropping it into inventory in 15s.
                /timed 150 /autoinventory
            } else /if (!${Me.FreeInventory}) {
                /echo HEY YOUR INVENTORY IS FULL!
            }
        }      

    /if (${ChainPull} && ${ChainPullPause.NotEqual[0]} && !${ChainPullHold} && !${ChainPullTimer2}) {
           /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
           /varset ChainPullTimer2 ${ChainPullPause.Arg[2,"|"]}m
    }
    /if (${ChainPull} && ${ChainPullPause.NotEqual[0]} && !${ChainPullTimer}) {
            /if (!${ChainPullHold}) {
            /echo Pausing Pulls for ${ChainPullPause.Arg[2,"|"]} Minutes. 
            /varset ChainPullHold 2
            /varset ChainPullTimer ${ChainPullPause.Arg[2,"|"]}m
            } else /if (${ChainPullHold}==2) {
            /echo Resetting Pull Timer for ${ChainPullPause.Arg[1,"|"]} Minutes. 
            /varset ChainPullHold 0
            /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
            /varset ChainPullTimer2 ${ChainPullPause.Arg[2,"|"]}m
            }
        } 
        /if (${Debug}) /echo \atDEBUG DoMiscStuff Leave \agLine#: ${Macro.CurLine}
/return

| -------------------------------------------------------------------------------------
| SUB: Can I do Stuff  - Check if invis moving ducked etc
| -------------------------------------------------------------------------------------
    Sub CanIDoStuff
    /if ((${CombatStart} || ${AggroTargetID})) /return
    /if (${Debug}) /echo \atDEBUG CanIDoStuff Enter \agLine#: ${Macro.CurLine}
    /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0) ) /varset IAmDead 0
    | Turn off twist while invis
    /if (${Me.Invis}) {
		/if (${IAmABard}) {
			/if (${Twist}) {
	        		/twist off
	        		/stop song
			}
		}
    }
    | Assign Master looter    
    /if (${Select[${Me},${Group.Leader}]}==1) /call AssignLooter
    :IAmBusy
        /doevents
        /call WriteDebuffs
        /call Roguestuff
        /call EndMacroIf
        /if (${Me.Moving} || ${Me.State.Equal[feign]} || (${ChaseAssist}==0 && ${AggroTargetID}==0 && ${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || ${Me.Stunned} || ${Me.Ducking}  || (${Me.State.Equal[BIND]} && !${Window[LootWnd].Open})) /goto :IAmBusy
        /if (${Window[MerchantWnd]} || ${Window[GiveWnd]} || ${Window[SpellBookWnd]} || ${Window[BigBankWnd]} || ${Window[BankWnd]} || ${Window[GuildBankWnd]}  || ${Window[TributeMasterWnd]} || ${Window[GuildTributeMasterWnd]}) /goto :IAmBusy
    /if (${Debug}) /echo \atDEBUG CanIDoStuff Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Mercs Do What
| -------------------------------------------------------------------------------------
    Sub MercsDoWhat
        /if (!${MercOn}) /return
        /if (${Group.Member[1].Owner.Name.Equal[${Me}]}) /varset MyMerc ${Group.Member[1].Name}
        /if (${Debug}) /echo \atDEBUG MercsDoWhat Enter \agLine#: ${Macro.CurLine}
        /if (${Mercenary.State.Equal[Active]}) /varset MercInGroup 1
        | Revive the merc if dead and previously detected in group
        /if (${MercInGroup} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Mercenary.State.Equal[DEAD]}) /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
        /if (${MercAssistAt}>=${Spawn[${MyTargetID}].PctHPs} && ${Mercenary.State.Equal[Active]} && !${MercAssisting} && (${CombatStart} || ${Select[${Role},Puller]} && ${Pulled})) {
            /mercassist
            /if (${DebugCombat}) /echo \atDEBUGCOMBAT MercsDoWhat ${Spawn[${MyTargetID}].CleanName} %:${Spawn[${MyTargetID}].PctHPs} ID:${Spawn[${MyTargetID}].ID} \agLine#: ${Macro.CurLine}
            /varset MercAssisting 1
        }
        /if (${Debug}) /echo \atDEBUG MercsDoWhat Enter \agLine#: ${Macro.CurLine}
    /return

| -------------------------------------------------------------------------------------
| Sub Assign Main Assist
| -------------------------------------------------------------------------------------
Sub Bind_AssignMainAssist(string maname)
	/declare maclean string local ${Target.CleanName}
	/declare matype string local ${Target.Type}
	/declare maclass string local ${Target.Class.ShortName}
	/if (${maname.Length}) {
		/varset maclean ${Spawn[=${maname}].CleanName}
		/varset matype ${Spawn[=${maname}].Type}
		/varset maclass ${Spawn[=${maname}].Class.ShortName}
		/echo Changing MA to ${maclean}
	}  
	/if (${Debug}) {
		/echo \atDEBUG AssignMainAssist Enter \agLine#: ${Macro.CurLine}
	}   
	/varset MainAssist ${maclean}
	/varset MainAssistType ${matype}
	/varset MainAssistClass ${maclass}
	/if (${Debug}) {
		/echo \atDEBUG AssignMainAssist Leave \agLine#: ${Macro.CurLine}
	}
	/if (!${Group.Member[${MainAssist}].ID}) {
		/if (${XTarHeal} && !${Me.XTarget[${XTarHeal}].ID}) {
			/xtarget set ${XTarHeal} ${MainAssist}
		}
	}
/return

| -------------------------------------------------------------------------------------
| Check and set roles
| -------------------------------------------------------------------------------------
    Sub CheckRoles
        /if (${Debug}) {
			/echo \atDEBUG CheckRoles Enter \agLine#: ${Macro.CurLine}
		}
        /if (${Role.Equal[assist]}) {
            /if (${Debug}) /echo \atDEBUG Looks like I am assisting. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
        } else /if (${Role.Equal[tank]}) {
            /if (${Debug}) {
				/echo \atDEBUG Looks like I am Main Tank. Wish me luck. \agLine#: ${Macro.CurLine}
			}
            /if (!${Defined[MainAssist]}) {
				/echo I am setting MainAssist to ${Me} in CheckRoles
				/varset MainAssist ${Me}
			}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /varset StickHow front 15
        } else /if (${Role.Equal[puller]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role puller \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Puller. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Pet.ID} && ${Me.Pet.Distance}>${CampRadius}) /pet follow        
        } else /if (${Role.Equal[pullertank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pullertank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Puller and Tank. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /varset StickHow front 12
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID} && ${Me.Pet.Distance}<=${CampRadius}) /pet guard
            /if (${Pet.ID} && ${Me.Pet.Distance}>${CampRadius}) /pet follow            
        } else /if (${Select[${Role},hunter]}) {
            /if (${DebugPull})  /echo \atDEBUGPULL role hunter \agLine#: ${Macro.CurLine}
            /if (${DebugPull})  /echo \atDEBUGPULL Looks like I am Hunting. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /varset StickHow front 12
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /varset ReturnToCamp 0
            /varset MobsTooClose 15
            /if (${Pet.ID}) /pet follow
        } else /if (${Role.Equal[hunterpettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role hunterpettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am Hunting and my pet is tanking. \agLine#: ${Macro.CurLine}
            /varset MainAssist ${Me}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange 115            
            /varset ReturnToCamp 0
            /varset ChaseAssist 0
            /varset MountOn 0
            /varset MobsTooClose 15
            /if (${Pet.ID}) /pet follow
        } else /if (${Select[${Role},petassist]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role petassist \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am assisting a pet. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
        } else /if (${Select[${Role},pettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like my pet is tanking. \agLine#: ${Macro.CurLine}   
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange 115
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            :PTauntOn1
            /if (${Me.Pet.ID} && !${PetTauntOn}) {
                /pet taunt on
                /delay 10
                /doevents PTaunt
                /if (!${PetTauntOn}) /goto :PTauntOn1
            }            
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow            
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend}) /call PetStateCheck                        
        } else /if (${Select[${Role},pullerpettank]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL role pullerpettank \agLine#: ${Macro.CurLine}
            /if (${DebugPull}) /echo \atDEBUGPULL Looks like I am pulling and my pet is tanking. \agLine#: ${Macro.CurLine}
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset AssistAt 100
            /varset MeleeOn 0
            /varset PetTanking 1
            /varset PetAttackRange 115
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            :PTauntOn2
            /if (${Me.Pet.ID} && !${PetTauntOn}) {
                /pet taunt on
                /delay 10
                /doevents PTaunt
                /if (!${PetTauntOn}) /goto :PTauntOn2
            }
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow
            /if (${PullRoleToggle} && ${Group.Leader.ID}!=${Me.ID}) {
                /echo You are set to toggle puller mode but are NOT the group leader.
                /echo Please correct this and restart KissAssist. 
                /end
            }
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend}) /call PetStateCheck           
        } else /if (${Role.Equal[manual]}) {
                /if (${UseMQ2Melee}) /squelch /melee aggro=0
                /varset MeleeOn 0
                /varset ReturnToCamp 0
                /varset ChaseAssist 0
                /varset DPSOn 0
                /varset BuffsOn 0
                /varset DebuffAllOn 0
                /if (${Defined[HealsOn]}) /varset HealsOn 0
                /if (${Defined[MezOn]}) /varset MezOn 0
        }    
        /if (${Select[${Role},puller,pullerpet]}==0 && ${ChainPull}) /varset ChainPull 0 
        /if (${Debug}) {
			/echo \atDEBUG CheckRoles Leave \agLine#: ${Macro.CurLine}
		}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullRange
| -------------------------------------------------------------------------------------
   Sub SetPullRange
       /if (${DebugPull}) /echo \atDEBUGPULL PullRange Enter \agLine#: ${Macro.CurLine}
       /declare PullItemRange int local
        /if (${Select[${FindItem[=${PullWith.Arg[1,|]}].Type},Archery,Throwing,Throwingv1,Throwingv2,ammo]} && ${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /varset PullItem ${PullWith.Arg[1,|]}
            /varset PullItemRange ${FindItem[=${PullWith.Arg[1,|]}].Range}
            /if (!${PullItemRange}) /varset PullItemRange 50
            /if (${FindItem[=${PullWith.Arg[2,|]}].WornSlot[ammo]} && ${FindItemCount[=${PullWith.Arg[2,|]}]}) {
                /varset PullAmmo ${PullWith.Arg[2,|]}
                /if (${FindItem[=${PullWith.Arg[1,|]}].Type.Equal[Archery]}) {
                    /varcalc PullItemRange ${PullItemRange}+${FindItem[=${PullWith.Arg[2,|]}].Range}
                }
                /call PullVars ${Math.Calc[${PullItemRange}*.9]} Ranged ${PullItemRange}
            } else {
                /echo I can't find any ammo defaulting to Melee for PullWith
                /varset PullWith Melee
                /call PullVars 15 Melee 15
                /return
            }
	    /if (${DebugPull}) /echo \atPullWith=(${PullWith}) PullItem=(${PullItem}) PullItemRange=(${PullItemRange}) PullItemCount=(${FindItemCount[=${PullWith.Arg[1,|]}]}) PullAmmo=(${PullAmmo})\agLine#: ${Macro.CurLine}
        }
        /if (${FindItemCount[=${PullWith}]} && !${PullWith.Arg[2,|].Length} && ${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /varset PullItemRange ${FindItem[=${PullWith}].Spell.Range}
            /call PullVars  ${Math.Calc[${PullItemRange}*.9]} "${PullWith}" ${PullItemRange}
            /return
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullRange PullWith: ${PullWith} - CA:${Me.CombatAbility[${PullWith}]}/SPELL:${Me.Book[${PullWith}]}/ AA: ${Me.AltAbility[${PullWith}]} \agLine#: ${Macro.CurLine}
        /if (${Me.CombatAbility[${PullWith}]} || ${Me.Book[${PullWith}]} || ${Me.AltAbility[${PullWith}]})  {
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]}) /call PullVars ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].Range}/1.11]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].Range}
            /if (${Select[${Role},hunter]})  {
                /if (${DebugPull}) /echo ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].Range}/2.75]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].Range} \agLine#: ${Macro.CurLine}
                /call PullVars ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].Range}/2.75]} "${PullWith}" ${Spell[${Spell["${PullWith}"].ID}].Range}
            }
        }
        /if (${PullWith.Equal[Pet]}) {
            /if (${Role.Equal[hunterpettank]}) {
                /call PullVars ${Math.Calc[${PetAttackRange}*.80]} Pet ${Math.Calc[${PetAttackRange}*.80]}
            } else {
                /call PullVars 185 Pet 185
            }
        }
        /if (${PullWith.Equal[Melee]}) {
            /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                /beep
                /beep
                /beep
                /popup You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /if (${DebugPull}) /echo ${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}
                /echo You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /endmac
            } else {
                /call PullVars 15 Melee 15
            }
        }
        /if (${DebugPull}) /echo \atDEBUGPULL PullRange Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: PullVars
| -------------------------------------------------------------------------------------
    Sub PullVars(int pRange, pType, int pRange2)
        /if (${DebugPull}) /echo \atDEBUGPULL PullVars Enter \agLine#: ${Macro.CurLine}
        /varset PullRange ${pRange}
        /varset PullWith ${pType}
        /varset PullRangeActual ${pRange2}
        /if (${Bool[${Plugin[MQ2Map]}]}) /mapfilter CastRadius ${PullRange}
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) /varcalc MaxRadius ${TempMaxRadius}+${PullRangeActual}
        /if (${DebugPull}) /echo MaxRadius is now ${MaxRadius} \agLine#: ${Macro.CurLine}
        /if (${DebugPull}) /echo \atDEBUGPULL PullVars Leave \agLine#: ${Macro.CurLine}
    /return
| -----------------------------------------------------------------------------------------------------------
| SUB: FindMobToPull(int PullFlag) (NEW VERSION) PullFlag 1 - Find mob and pull  0 - Check to see if there is a mob
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobToPull(int PullFlag)
	/if (${Me.Class.CanCast} && ${Me.PctMana}<100 && !${Me.Mount.ID} && ${Me.Standing}) {
		/echo going to sit 3
		/sit
		/delay 2s !${Me.Standing}
	}
        /if (${ChainPull}==2 && ${PullFlag}) /varset ChainPull 1
        /if ((${DMZ} && ${Me.InInstance}==FALSE) || (${PullFlag} && !${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) || (!${PullFlag} && !${Role.Find[puller]}) || ${Pulled} || (${AggroTargetID}  && !${ChainPull}) || ${ChainPullHold} || ${DPSPaused}) /return 0
            /call MobRadar ${MeleeDistance} FindMobToPull
        /if (${ChainPull} && (${MobCount}>1 || ${Me.XTarget[${XTSlot2}].ID})) /return 0
        /if (${PullFlag}) {
            /if (${ChainPull}) {
                /if (${Target.ID}==${Me.ID}) {
                    /squelch /target clear
                    /delay 10 !${Target.ID}
                }
                /if (${Me.XTarget[${XTSlot}].ID} && ((!${MyTargetID} && !${Target.ID}) || ${Target.PctHPs}>=${ChainPullHP} || (${MyTargetID} && ${Spawn[${MyTargetID}].PctHPs}>=${ChainPullHP}))) /return 0
                /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>75) /return 0
            }
			/if (!${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID} || ${IAmDead}) /return 0
			/if (${Select[${Me.Class.ShortName},MAG,NEC,BST]}) {
				/if (${PetRampPullWait} && !${Me.CombatState.Equal[COMBAT]} && ${Select[${Role},pullerpettank]}) /call CheckRampPets
			}
		}
        /if (${DebugPull}) {
			/echo \atDEBUGPULL FindMobToPull Enter ${PullFlag} \agLine#: ${Macro.CurLine}
		}
        /call SetPullRange
        /doevents
        /declare i int local
        /declare j int local
        /declare k int local
        /declare l int local
        /declare f1 int local 0
        /declare secpullon int local 0
        /declare PullMob int local 0
        /declare PullMobName string local 0
        /declare PullMobDistance float local 0
        /declare PullMobValid int local 0
        /declare PullCount int local
        /declare DistanceCheck int local
        /declare MobsNearCamp int local
        /declare PullingTimer timer local 5s
        /declare Start1 int local
        /declare WPMobCount int local
        | Sort by path-lengths for MQ2Nav vars
        /declare PathArray[999] int local 0
        /declare PathDistance[999] float local 0
        /declare Smallsub int local 0
        /declare tempSortID int local 0
        /declare tempSortDist float local 0
        /declare i2 int local 0
        /declare CanUseNav int local 0
	/if (${mq2navloaded}) {
		/if (${Navigation.MeshLoaded}) /varset CanUseNav 1
	}
        /varset Pulling 0
        /call GroupWatch
        /if (${ChainPullHold}) /return 0
:checksecs
	/if (${PullFlag}) {
           /echo hi Looking for Close Range Mobs ${secpullon}
        } else {
           /if (!${SpamTimer}) {
              /echo Checking for Close Range Mobs ${secpullon}
              /varset SpamTimer 50
           }   
        }
        | Clear alert list 1, add mobs to ignore alert list1, set timer to keep alert list manageable for pulling no alert 1
        /if (!${PullAlertTimer}) {
            | Add Ignore Mob list to alert list
            /call AlertAddToList 1 "${MobsToIgnore}"
            /varset PullAlertTimer 5m
        }
        :FindMob
        | Advpath searches for mobs along the path using Pullwith radius not Maxradius
        /if (${PullPathWpCount} && ${PullPath.Length} && ${PullMoveUse.Equal[advpath]}) {
            /if (${Target.ID}) /squelch /target clear
            /varset PullMobValid 0 
            | loop through pathwaypoints and check for mobs
            /for k 1 to ${PullPathWpCount}
            /varset WPMobCount 0
            /varset PullMob 0
                /varset WPMobCount ${SpawnCount[npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${Math.Calc[${PullRange}*.8]} zradius ${MaxZRange} targetable noalert 1]}
                /if (${WPMobCount}) {
                    /varset i 0
                    /for l 1 to ${WPMobCount}
                        /varset PullMob ${NearestSpawn[${l}, npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${Math.Calc[${PullRange}*.8]} zradius ${MaxZRange} targetable noalert 1].ID}
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 1: WP: ${k} MobID ${PullMob} LOS ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} YXZ ${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z} \agLine#: ${Macro.CurLine}
                        /if (${DebugPull}) /delay 1
                        /if (${PullMob} && ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                /if (${k}<${PullPathWpCount}) {
                                    /varcalc i ${k}+1
                                    /while (${i}<=${PullPathWpCount} && ${DistanceCheck}>${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                        /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                        /varcalc i ${i}+1
                                    }
                                    /varset k ${i}
                                }
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: WP ${k} MobCount ${l} ${WPMobCount} \agLine#: ${Macro.CurLine}
                            /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                            /varset PullMobDistance ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                                /varcalc AdvpathPointNum ${k}
                            /varset AdvpathPointX ${PullPathArrayX[${k}]}
                            /varset AdvpathPointY ${PullPathArrayY[${k}]}
                            /varset AdvpathPointZ ${PullPathArrayZ[${k}]}
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 2: WP: ${k} Pullmob ${PullMob} Waypoint: ${AdvpathPointNum} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]}<${PullRange} \agLine#: ${Macro.CurLine}
                            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 2: AdvPull: Pullmob: ${PullMobName} ID ${PullMob} Waypoint: ${PullPathWpCount} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} \agLine#: ${Macro.CurLine}
                            /call PullValidate ${PullMob} ${PullFlag} ${secpullon}
                            /varset PullMobValid ${Macro.Return}
                            /if (${PullMobValid}) /goto :FoundMob
                        }
                    /next l
                }
            /next k        
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: Mob Not Found. AdvPull: PullFlag: ${PullFlag} Role: ${Role} ID: ${PullMob} PullRange: ${PullRange} \agLine#: ${Macro.CurLine}
            /return 0            
            | Check for mobs in max pull radius for normal,MQ2nav pulling
        } else /if (${CanUseNav} && ${PullMoveUse.Equal[nav]}) {    
            /varset PullCount ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        } else /if (${Select[${Role},hunter,hunterpettank]}) {
            /varset PullCount ${SpawnCount[npc radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        } else {
            /varset PullCount ${SpawnCount[npc los loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
            /varset MobsNearCamp ${SpawnCount[npc los loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange} targetable noalert 1]}
        }
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull PullFlag:${PullFlag} Pullcount: ${PullCount} MobsNearCamp: ${MobsNearCamp} \agLine#: ${Macro.CurLine}
        /if (!${PullFlag} && ${PullCount}>0 && ${Spawn[${LastMobPullID}].Distance}>=${MeleeDistance}) /return 0
        /if (!${PullFlag}) /varcalc PullCount ${PullCount}-${MobsNearCamp}
        /if (${PullCount}) {
               /if (!${PullFlag} && ${MobsNearCamp}) {
                  /varset f1 2
                } else {
                    /varset f1 1
                }
                | Pull mob with shortest path JooJooBean
                /if (${CanUseNav} && ${PullMoveUse.Equal[nav]}) {
                    /varset PullCount ${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1]}
                    /echo Pullcount is:  ${PullCount}  range is: ${MaxRadius}

                    /for i 1 to ${PullCount}
                        /varset PathArray[${i}] ${NearestSpawn[${i}, npc loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                        /varset PullMob    ${PathArray[${i}]}
			/if (${Navigation.PathExists[locxyz ${Spawn[${PullMob}].X} ${Spawn[${PullMob}].Y} ${Spawn[${PullMob}].FloorZ}]}) {
				/if (${PullNamedsFirst} && ${Spawn[${PullMob}].Named}) {
					/echo Lets pull nameds first mkay...
					/varset PathDistance[${i}] 1
				} else {
					/varset PathDistance[${i}] ${Navigation.PathLength[locxyz ${Spawn[${PullMob}].X} ${Spawn[${PullMob}].Y} ${Spawn[${PullMob}].FloorZ}]}
			        }
				/if (${DebugPull}) /echo [${i}] Succsesfully Added ${Spawn[${PullMob}].ID} ${Spawn[${PullMob}]} at ${Spawn[${PullMob}].X} ${Spawn[${PullMob}].Y} ${Spawn[${PullMob}].FloorZ} (dist :${PathDistance[${i}]}) to the pull array.    
			} else {
				/varset PathDistance[${i}] 100000
			}
                    /next i

                    /for i 1 to ${PullCount}
                        /varset Smallsub ${i}
                        /varset i2 ${Math.Calc[${i} + 1]}
                        /for j ${i2} to ${PullCount}
                            /if (${PathDistance[${j}]} < ${PathDistance[${Smallsub}]}) /varset Smallsub ${j}
                        /next j
                        /varset tempSortID ${PathArray[${i}]}
                        /varset tempSortDist ${PathDistance[${i}]}
                        /varset PathArray[${i}] ${PathArray[${Smallsub}]}
                        /varset PathArray[${Smallsub}] ${tempSortID}
                        /varset PathDistance[${i}] ${PathDistance[${Smallsub}]}
                        /varset PathDistance[${Smallsub}] ${tempSortDist}
                        /if (${i2}==${PullCount}) /break
                        /if (${DebugPull}) /echo \atDEBUGPULL /echo \atDEBUGPULL FindMobToPull: PathNum: ${PathDistance[${i}]} PathDistance:${PathDistance[${Smallsub}]} \agLine#: ${Macro.CurLine}
                    /next i
                }
            /for i 1 to ${PullCount}
                /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 1.0:  PullFlag: ${PullFlag} Pullcount: ${PullCount} \agLine#: ${Macro.CurLine}
                /if (${CanUseNav} && ${PullMoveUse.Equal[nav]}) {
                    /varset PullMob ${PathArray[${i}]}
                    /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                   /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} MQ2Nav: Name: ${PullMobName} ID: ${PullMob} \agLine#: ${Macro.CurLine}
                } else /if (${Select[${Role},hunter,hunterpettank]} && ${PullMoveUse.NotEqual[advpath]}) {
                   /varset PullMob ${NearestSpawn[${i}, npc radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                   /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                   /if (${DebugPull} && ${Select[${Role},hunter]}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Role: ${Role} Name: ${PullMobName} ID: ${PullMob} \agLine#: ${Macro.CurLine}
                } else /if (${PullMoveUse.NotEqual[advpath]}) {
                   /varset PullMob ${NearestSpawn[${i}, npc los loc ${CampXLoc} ${CampYLoc} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
                   /if (${PullMob}) /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                   /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Normal Name: ${PullMobName} ID: ${PullMob} LOS: ${LineOfSight[${CampYLoc},${CampXLoc},${CampZLoc}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} \agLine#: ${Macro.CurLine}
                }
                /if (${PullMob}) {
                    |/echo we have a mob to pull its ${Spawn[id ${PullMob}]} ${Spawn[id ${PullMob}].Distance} feet away
                    /varset PullMobDistance ${Spawn[id ${PullMob}].Distance}
                }
                /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull 1.1:  PullFlag: ${PullFlag} Pullcount: ${PullCount} Name:  ${PullMobName} MobID: ${PullMob} MobDistance: ${PullMobDistance} MaxRadius: ${MaxRadius} PullRange: ${PullRange} \agLine#: ${Macro.CurLine}
                /varset PullMobValid 0
                /if (${PullMob}) {
                    /call PullValidate ${PullMob} ${PullFlag} ${secpullon}
                    /if (${Macro.Return}) { 
                        /varset PullMobValid 1
                        /varset ChainPullTemp ${PullMob}
                    }
                }
                /if (${PullMobValid}) /goto :FoundMob
            /next i
            /varset ChainPullTemp 0
            /varset PullMob 0
            /varset PullMobDistance 0
        } else {
           /varset PullMob 0
           /varset PullMobValid 0
           /varset ChainPullTemp 0
           /varset PullMobDistance 0
        }
        :FoundMob
	/echo PullMobValid ${PullMobValid} PullFlag ${PullFlag}
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: 1.2: PullFlag: ${PullFlag} Name: ${Spawn[${PullMob}].CleanName} MobID: ${PullMob} Valid: ${PullMobValid} PullCount: ${PullCount} \agLine#: ${Macro.CurLine}
	/if (${PullMobValid}) {
		/if (${PullFlag}) {
            		/if (!${PullPathWpCount} && ${Spawn[${PullMob}].Distance3D} < 120 && ${Spawn[${PullMob}].LineOfSight}) {
                		/target id ${PullMob}
                		/delay 20 ${Target.ID}==${PullMob}
              		}
           	} else {
                	/return ${PullCount}
           	}
        } else {
		/if (!${PullFlag}) {
			/return 0
		} else {
			/echo ok we got this far and there was no valid mob
			/echo lets check secondary then, maybe its a slow day...
			/delay 1s
			/if (!${secpullon} && ${MobsToPullSecondary.NotEqual[NULL]}) {
				/varset secpullon 1
				/goto :checksecs
			}
		}
        }
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: 2.0: PullFlag: ${PullFlag} MobID: ${PullMob} Valid: ${PullMobValid} \agLine#: ${Macro.CurLine}
        /if (${PullMob} && ${Spawn[${PullMob}].ID}) {
            /varset Pulling 1
            | Advpath skill validate mob
            /if (${PullMob} && ${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                /varset MyTargetID ${PullMob}
                /varset MyTargetName ${Spawn[${PullMob}].CleanName}
                /if (${Spawn[${PullMob}].Distance3D} < 120 && ${Spawn[${PullMob}].LineOfSight}) {
			/target id ${PullMob}
                	/delay 20 ${Target.ID}==${PullMob}
		}
                | Is mob really in range. check for spawn lag
                /if (${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}>${PullRange}) {
                    /alert add 1 id ${PullMob}
                    /echo Mob is OOR after targeting. Trying Again.
                    /squelch /target clear
                    /varset Pulling 0
                    /goto :FindMob
                }
                /call ValidateTarget
            } else /if (${Target.ID} && ${Target.ID}==${PullMob}) {
                /call ValidateTarget
            } else {
               /if (${PullMob} && ${Spawn[${PullMob}].ID}) /call ValidateTarget ${PullMob}
            }
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Target: ${Spawn[${PullMob}].CleanName} Valid: ${ValidTarget} MacReturn ${Macro.Return} \agLine#: ${Macro.CurLine}
            /if (${ValidTarget}==0 || (${Target.ID} && ${PullMoveUse.NotEqual[advpath]} && ${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) {
                /squelch /alert add 1 id ${PullMob}
                /squelch /target clear
                /varset Pulling 0
                /goto :FindMob
            }
            /call BroadCast ${IRCOn} ${EQBCOn} t "PULLING-> ${Spawn[${PullMob}].CleanName} <- ID:${PullMob} at ${Int[${Math.Distance[${Spawn[${PullMob}].Y},${Spawn[${PullMob}].X}:${CampYLoc},${CampXLoc}]}]} feet."
            /varset MyTargetID ${PullMob}
            /varset MyTargetName ${Spawn[${PullMob}].CleanName}
            /if (${Pulling} && ${MyTargetID}) {
                /if (${PullWith.Equal[Pet]} && (${Me.Pet.Stance.NotEqual[FOLLOW]})) /pet follow  
                /if (${Target.ID} && ${Target.ID}!=${PullMob}) {
                   /if (${Me.Combat}) /attack off
                   /squelch /target clear
                }
                /call Pull
                /if (${ChainPull} && ${ChainPullPause.NotEqual[0]}) /varset ChainPullTimer2 ${Math.Calc[${ChainPullPause.Arg[2,"|"]}+1]}m
                /return 0
            }
        }
        /if (!${PullMob}) {
            /varcalc FailCounter ${FailCounter}+1
            /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} No Valid Target in Range ${MaxRadius} - ${FailCounter} Time(s) \agLine#: ${Macro.CurLine}
            /if (${FailCounter}>=${FailMax}) {
                /call ClearOutAlerts 1
                /varset FailCounter 0
                /varset PullAlertTimer 0
                /if (${PullWait}) {
                    /echo Waiting ${PullWait} seconds for mobs to respawn.
                    /call BroadCast ${IRCOn} ${EQBCOn} t "PULLING-> Waiting ${PullWait} seconds for mobs to respawn."
                    /call PullDelay ${PullWait}
                }
                /if (${Select[${Role},hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull Returning hunter to camp \agLine#: ${Macro.CurLine}
                    /varset ReturnToCamp 1
                    /echo ${Role}: There are no mobs within ${MaxRadius} trying to return to camp.
                    /call DoWeMove "FindMobToPull"
                }    
                /return 0
            }
            /if (!${PullingTimer}) /return 0
            /goto :FindMob
        }
        /if (${DebugPull}) /echo \atDEBUGPULL FindMobToPull: PullFlag: ${PullFlag} Leave \agLine#: ${Macro.CurLine}
    /return 0
| -------------------------------------------------------------------------------------
| SUB: PullDelay
| -------------------------------------------------------------------------------------
    Sub PullDelay(int TimerAmount)
        /if (${DebugPull}) /echo PullDelay ${TimerAmount} Enter \agLine#: ${Macro.CurLine}
        /declare PDTimer timer local ${TimerAmount}s
        /varset Pulling 0
        :WaitForTimer
            /doevents
            /call CheckForCombat 1 PullDelay
            /delay 2
            /if (${PDTimer}) /goto :WaitForTimer
        /if (${DebugPull}) /echo PullDelay Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: PullValidate
| ----------------------------------------------------------------------------
    Sub PullValidate(PVPullMob, int PFlag, int checksec)
        /declare j int local
          /if (!${MobsToPull.Find[All for all]} && ${MobsToPull.NotEqual[All]}) {
		/for j 1 to 25
	                /if (${DebugPull}) {
				 /if (${MobsToPull.Arg[${j},,].Length}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} j = ${j} PullList ${Spawn[id ${PVPullMob}].CleanName}/${MobsToPull.Arg[${j},,]} ${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]} \agLine#: ${Macro.CurLine}
			}
	                /if (${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]}) /goto :MobToPullSkip
	        /next j
		|lets check secondary as well
		/if (${checksec} && ${MobsToPullSecondary.NotEqual[NULL]}) {
			/for j 1 to 25
		        	/if (${DebugPull}) {
					/if (${MobsToPullSecondary.Arg[${j},,].Length}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} j = ${j} PullList ${Spawn[id ${PVPullMob}].CleanName}/${MobsToPullSecondary.Arg[${j},,]} ${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPullSecondary.Arg[${j},,]}]} \agLine#: ${Macro.CurLine}
				}
		        	/if (${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPullSecondary.Arg[${j},,]}]}) {
					/echo nice its slow pickings, and i have a secondary mob to pull its a ${MobsToPullSecondary.Arg[${j},,]}]}
					/goto :MobToPullSkip
				}
		        /next j
		}
           	/if (${DebugPull}) {
			/echo \atDEBUGPULL PullValidate ${Spawn[id ${PVPullMob}].CleanName} NOT on MobsToPull List \agLine#: ${Macro.CurLine}
            	}
		/return 0
        }
	:MobToPullSkip
        /if (${DebugPull}) /echo \atDEBUGPULL PullValidate Pulling: ${Spawn[id ${PVPullMob}].CleanName} \agLine#: ${Macro.CurLine}
        | Check spawn for out of range - macro start point as epicEnter
        /if (!${PullPathWpCount} && ${Math.Distance[${Spawn[id ${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Out of Range \agLine#: ${Macro.CurLine}
            /return 0
        }
        | Check spawn for eye of zomm/tallon ${SpawnCount[pc ${PVPullMob.Right[${Math.Calc[${PVPullMob.Length}-7]}]}]}
        /if (${Spawn[${PVPullMob}].CleanName.Find[Eye of]} && ${SpawnCount[pc ${PVPullMob.Right[${Math.Calc[${PVPullMob.Length}-7]}]}]}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Eye of Zomm/Tallon \agLine#: ${Macro.CurLine}
                /return 0
        }
        | Check spawn for line of sight - no mq2nav
        /if (!${PullPathWpCount} && ${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${PVPullMob}].LineOfSight}) {
		/if (${mq2navloaded}) {
			/if (!${Navigation.MeshLoaded}) {
            			/if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No line of sight \agLine#: ${Macro.CurLine}
                		/return 0
			}
		} else {
			/return 0
		}
        }
        | Check spawn for Level Range
        /if (${Spawn[${PVPullMob}].Level}<${PullMin} || ${Spawn[${PVPullMob}].Level}>${PullMax}) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].Level} invalid target Reason: Invalid NPC Level \agLine#: ${Macro.CurLine}
            /return 0
        }
        | Check if any PC/toon is near the mob
        /if (${SpawnCount[loc ${Spawn[${PVPullMob}].Y} ${Spawn[${PVPullMob}].X} radius 15 pc]}>=1 && ${Pulling} && ${Math.Distance[${Spawn[${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${Me.Y},${Me.X}]}>=16) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: PCs near mob \agLine#: ${Macro.CurLine} \agLine#: ${Macro.CurLine}
                /return 0
        }
        | Check spawn for 100% health
        /if (${Spawn[${PVPullMob}].PctHPs}<=99) {
            /if (${DebugPull}) {
		/echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Mob not 100% health \agLine#: ${Macro.CurLine} \agLine#: ${Macro.CurLine}
            }
	    | If chain pulling then target mob to update server.
            /if (${PFlag} && ${Target.ID} != ${PVPullMob}) {
                /echo Mob not at 100% HPs Double checking for server lag PFlag: ${PFlag} PVPullMob: ${PVPullMob} - ${Spawn[${PVPullMob}].CleanName} MobCount: ${MobCount}
                /target id ${Spawn[${PVPullMob}].ID} 
                /delay 20 ${Target.ID}==${PVPullMob} && ${Target.BuffsPopulated}==TRUE
                /if (${Target.PctHPs} > 99) /return 1
            }
            /return 0                
        }
        /if (${Spawn[${PVPullMob}].Named} && ((${PFlag} && ${MobCount} && ${Me.XTarget[${XTSlot}].ID}) || !${PFlag})) {
            /if (${DebugPull}) /echo \atDEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No Pull Names with Mobs in Camp \agLine#: ${Macro.CurLine}
            /return 0
        }
	/if (${Spawn[${PVPullMob}].Named}) {
		/echo Found a named to pull: ${Spawn[${PVPullMob}].Name}
	}
    /return 1
|-------------------------------------------------------------------------------- 
|SUB: CheckRampPets - Writtten by Trehuggindruid for KissAssist
|-------------------------------------------------------------------------------- 
    Sub CheckRampPets
        /declare i int local
        /if (!${Me.CombatState.Equal[COMBAT]}) {
            | Wait for rampage pets to poof before pulling.
            /for i 0 to 20
                /if (${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /echo +++ My rampage pet is up: (${Spawn[${Me.CleanName}`s_pet0${i}]}|${Spawn[${Me.CleanName}`s_pet0${i}].ID}), HOLDING . . .
                :WaitOnRampagePets
                /delay 1
                    /if (!${Me.CombatState.Equal[COMBAT]} && ${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /goto :WaitOnRampagePets
            /next i
            | /echo - No rampage pet is active, starting pulls.
        }
    /return    
| -------------------------------------------------------------------------------------
| SUB: Pull
| -------------------------------------------------------------------------------------
    Sub Pull
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}==0) /return
        /if (!${Pulling}) /return
        /if (${DPSPaused}) /return
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Enter \agLine#: ${Macro.CurLine}
        /declare PullTimer timer local 50
        /declare PullAttempts int local 0 
        /declare StuckCount int local 0 
        /declare PullDist float local ${PullRange}
        /declare tempAmmo string local ${InvSlot[ammo].Item.Name}
        /declare rangedSwitch int local 0
        /declare CalmOldID int local 0
        /declare CalmID int local 0
        /declare CanUseNav int local 0
	/if (${mq2navloaded}) {
		/if (${Navigation.MeshLoaded}) /varset CanUseNav 1
	}
        /declare ammoSwitch int local 0
        /declare WasTwistingPull bool local ${Twist}
        /declare AdvpathPaused int local 0
        /declare WPCurrent int local 0
        /declare AdvpathDirection string local
        /varset Pulled 0
        /varset PullTooFar 0
        /varset CantHit 0
        /varset ToClose 0
        /declare AutoFireOff int local ${AutoFireOn}
        /declare X1 int local
        /declare Y1 int local
        /declare X2 int local
        /declare Y2 int local
        /declare BeginMobID string local
        /declare AdjustHeadingTimer timer local 0
        /if (${DebugPull}) /echo \atDEBUGPULL Pull: PullWith:${PullWith} PullDist: ${PullDist} \agLine#: ${Macro.CurLine}
        | Set autofire setting off during pulls if not using ranged item to pull
        /if (${AutoFireOff}) /varset AutoFireOn 0
        /if (${IAmABard}) {
		/if (!${PullTwistOn} && ${WasTwistingPull}) { 
			/squelch /twist off
		}
        }
        /if (!${Me.Mount.ID} && ${Me.Sitting}) {
		/echo going to stand 8
		/stand
	}
        /if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}!=${Me.ID}) {
            /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /call TogglePullMode TurnOn
        }
        /varset BeginMobID ${Me.XTarget[${XTSlot}].ID}
       :PullAgain
        /doevents 
        /if (${DPSPaused}) /return  
        | vars used to determine if we are stuck
            /varset X1 ${Int[${Me.X}]}
            /varset Y1 ${Int[${Me.Y}]}            
            /if ((${AggroTargetID} && !${ChainPull}) || (${ChainPull} && ${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID}))) {
            /if (${DebugPull}) /echo Pulling 1.1 \agLine#: ${Macro.CurLine}
                /varset Pulled 1
                /varset MyTargetID ${AggroTargetID}
                /varset MyTargetName ${Spawn[${AggroTargetID}].CleanName}
                /if (${mq2navloaded}) {
			/if (${Navigation.Active}) {
				/echo 6 stopping nav 
				/nav stop
			}
		}
                /if (${MoveTo.Moving}) /moveto off
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Aggro detected \agLine#: ${Macro.CurLine}
                /goto :DonePulling
            }
            | Exit pull and reset if timed out or wandered too far from camp
            /if (${DebugPull}) /echo Pulling 1.2 PullTimer: ${PullTimer} Distance: ${Math.Distance[${CampYLoc},${CampXLoc}]} MaxRadius: ${MaxRadius} PullAttempts: ${PullAttempts} MyTargetID: ${Spawn[${MyTargetID}].ID}  Target LOS: ${Spawn[${MyTargetID}].LineOfSight} \agLine#: ${Macro.CurLine}
            /if (${PullTimer}==0 || ${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius} || ${PullAttempts}>=7 && !${Spawn[${MyTargetID}].LineOfSight} && !${Select[${Role},hunter,hunterpettank]} || !${Spawn[${MyTargetID}].ID}) {
                /squelch /alert add 1 id ${MyTargetID}
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: /echo Adding ${Spawn[${MyTargetID}].CleanName} ID: ${MyTargetID} to temp ignore list \agLine#: ${Macro.CurLine}
                /if (${ReturnToCamp}) {
                    /call DoWeMove "FindMobToPull 2"
                }
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: Done Pulling-Timer expired, Mob unreachable or exceeded max pull radius. \agLine#: ${Macro.CurLine}
                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                    /call PullReset
                    /return
                }
            }
            /if (((${AggroTargetID} && !${ChainPull}) || (${Me.XTarget[${XTSlot2}].ID} && ${ChainPull})) && ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                /echo Looks like mobs in camp aborting pull.
                /call PullReset
                /if (!${ChainPull}) /call CheckForCombat 1 Pull
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Mobs in camp detected \agLine#: ${Macro.CurLine}
                /return
            }
            /if (${PullWith.Equal[Ranged]}) {
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: Ranged \agLine#: ${Macro.CurLine}
                | Cursor check sometimes summoned items get stuck on cursor.
                /if (${Cursor.ID}) /autoinventory
                /if (${OrigRanged.NotEqual[${PullItem}]} && ${OrigRanged.NotEqual[null]}) {
                    /call CheckCasting 50
                    /exchange "${PullItem}" ranged
                    /varset rangedSwitch 1
                    /delay 10
                }
                /if (${tempAmmo.NotEqual[null]} && ${tempAmmo.NotEqual[${PullAmmo}]}) {
                    /call CheckCasting 50
                    /exchange "${PullAmmo}" ammo
                    /delay 10
                    /if (${tempAmmo.NotEqual[${PullAmmo}]}) /varset ammoSwitch 1
                }
            }
            | - Filter to prevent pulling until AA/Disc/Spell/Item is ready.
            /if (${DebugPull}) /echo \atDEBUGPULL Check Ability: ${AggroTargetID} ${ChainPull} ${Select[${PullWith},Melee,Pet,Ranged]} ${Me.SpellReady[${PullWith}]} ${Me.AltAbilityReady[${PullWith}]} ${Me.CombatAbilityReady[${PullWith}]} ${Me.ItemReady[${PullWith}]} ${PullWith} ${PullWith.Equal[Ranged]} ${Me.RangedReady} \agLine#: ${Macro.CurLine}
            /if (${PullTimer} && (!${AggroTargetID} && !${ChainPull}) && ((!${Select[${PullWith},Melee,Pet,Ranged]} && !${Select[TRUE,${Me.SpellReady[${PullWith}]},${Me.AltAbilityReady[${PullWith}]},${Me.CombatAbilityReady[${PullWith}]},${Me.ItemReady[${PullWith}]}]}) || (${PullWith.Equal[Ranged]} && !${Me.RangedReady}))) /goto :PullAgain
            /if (${DebugPull}) /echo \atDEBUGPULL Pull Starting \agLine#: ${Macro.CurLine}
            /varset PullAttempts 0
            | Set group role puller to adjust for merc running up while pulling if soloing
            /if (${Group}==1 && !${Group.Puller.Name.Equal[${Me}]} && ${Select[${Role},puller]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) /call AssignGroupRole set "${Me.CleanName}" 3
            /if ((${Spawn[${MyTargetID}].Distance}>${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}<${MaxRadius}) {
            :WeThereYet
            | Advpath pull does not use max pull radius. It uses pullwith radius
                /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]} && ${mq2advpathloaded}) {
                    /play ${PullPath} nodoor smart normal 
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull /play ${PullPath} nodoor smart normal \agLine#: ${Macro.CurLine}
                    :RunningThePath 
                        /if (${DebugPull}) /delay 5 
                        /if (${DebugPull}) {
				/echo \atDEBUGPULL Pull /echo Waypoint: ${AdvPath.NextWaypoint} Target: ${Target.ID} MyTargetID: ${MyTargetID} Aggro: ${AggroTargetID} MobToWPDist: ${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}<${PullDist} MeToWPDist: ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}>50 WP<NWP: ${AdvPath.NextWaypoint}>=${AdvpathPointNum} \agLine#: ${Macro.CurLine}
                        }
			| Do we have aggro?
                        /if (${AggroTargetID}) /goto :StopPath
                        | Has the mob move out of range from the original way point
                        /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}>${PullDist}) /goto :StopPath
                        | Is mob within pull range and LOS
                        /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${Me.Y},${Me.X}]}<${PullDist} && ${Spawn[${MyTargetID}].LineOfSight}) /goto :StopPath
                        | Stop at our waypoint
                        /if (${AdvPath.NextWaypoint}>=${AdvpathPointNum} && ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}<=5) {
                            /varset WPCurrent ${AdvPath.NextWaypoint}
                            /goto :StopPath
                        }
                    /goto :RunningThePath
                    :StopPath
					/play off
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull /play ${PullPath} nodoor smart normal \agLine#: ${Macro.CurLine}
                |/echo Is Pull mob inside range of max pull radius and not using advpath
                } else /if (${CanUseNav} && !${Select[${Role},hunter,hunterpettank]}) {
                       	/varset PullDist ${PullRange}
                       	|/nav locxyz ${Spawn[${MyTargetID}].X} ${Spawn[${MyTargetID}].Y} ${Spawn[${MyTargetID}].FloorZ}
               	        /nav id ${MyTargetID}
               	        | Timer for /nav to adjust heading when mob is moving
               	        /varset AdjustHeadingTimer 20
               	        :DistanceCheck
               	            /delay 10
               	            /if (${PullTimer}==0) /goto :NavPullRelease
               	            |Corrects heading when mob is moving and your using Navigation.
               	            /if (${Spawn[${MyTargetID}].Speed}>25 && !${AdjustHeadingTimer}) {
               	                /nav id ${MyTargetID}
               	                /varset AdjustHeadingTimer 20
               	            }
               	            | Check for Unexpected Aggro
               	            /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID})) && ${ChainPull})) /goto :PullAgain
               	    | Check for being to far from camp.
               	    /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius}) {
               	        /if (${Navigation.Active}) {
				/echo 7 stopping nav 
				/nav stop
			}
               	     /if (${ReturnToCamp}) {
                	         /call DoWeMove "FindMobToPull 3"
                   	     }
                   	     /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                   	         /call PullReset
                    	        /return
                    	    }
                    	}
                    	/if ((${Spawn[${MyTargetID}].Distance}>${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull}))) /goto :DistanceCheck
                       	:NavPullRelease
                       	/if (${Navigation.Active} && ${Spawn[${MyTargetID}].LineOfSight} && ${Spawn[${MyTargetID}].Distance} < ${PullDist}) {
				/echo 8 stopping nav 
				/nav stop
			}
                       	/if (${DebugPull}) /echo Pulling ${PullDist} ${Target.Distance} \agLine#: ${Macro.CurLine}
                | We are pulling by LOS.  
                } else /if (${Spawn[${MyTargetID}].LineOfSight}) {
		   /echo moveto 7
                   /moveto id ${MyTargetID} mdist ${PullDist}
                   /delay 3
                   /varset X2 ${Int[${Me.X}]}
                   /varset Y2 ${Int[${Me.Y}]}            
                   /if (${DebugPull}) /echo \atDEBUGPULL Pull LOS ${Spawn[${MyTargetID}].LineOfSight} ${PullDist} \agLine#: ${Macro.CurLine}
                } else {
                    /if (${X2}!=0 && ${Math.Distance[${Me.Y},${Me.X}:${Y2},${X2}]}>200) {
                        /echo Mob is no Longer in LOS. Returning to Camp.
                        /squelch /alert add 1 id ${MyTargetID}
                        /if (${MoveTo.Moving}) {
				/moveto off
			}
                        /if (${ReturnToCamp}) {
                            /call DoWeMove "FindMobToPull 4"
                        }
                        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                            /call PullReset
                            /return
                        }
                    }
                }
            }    
            /varset CantSee 0
            /doevents
            |Checking to see if you are far from camp to try and fix the exceed to far from camp check.
            /if (!${PullPathWpCount} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > ${MaxRadius}) /goto :PullAgain
            /if (${DPSPaused}) /return 
            | Extending PullTimer if moving closer or target moving && !${Select[${Role},hunter]})
            /if (!${PullPathWpCount}) {
		/if (${mq2navloaded}) {
			/if (${Navigation.Active} || ${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed}>25 && ${Spawn[${MyTargetID}].Distance}>${PullRange})) {
				/varcalc PullTimer ${PullTimer}+50
			}
		} else {
			/if (${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed}>25 && ${Spawn[${MyTargetID}].Distance}>${PullRange})) /varcalc PullTimer ${PullTimer}+50
		}
	    }
            | Pull counter used to in conjunction with 1s delay for timing
            /varcalc PullAttempts ${PullAttempts}+1
            | Try and pull again after 7 seconds or 3 seconds if target is moving
            /if (!${PullPathWpCount}) {
                /if (${PullAttempts}>=7) {
                    | Make range smaller to creep closer to mob if not los
                    /if (${Spawn[${MyTargetID}].Distance}<=${PullDist} && !${Spawn[${MyTargetID}].LineOfSight}) /varcalc PullDist ${PullDist}*.6
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull PullDist: ${PullDist} - PullLoops: ${PullAttempts} LineOfSight: ${Spawn[${MyTargetID}].LineOfSight} \agLine#: ${Macro.CurLine}
                    /goto :PullAgain
                } else /if (${PullAttempts}>=3 && ${Spawn[${MyTargetID}].Speed}>25) {
                    | Make range smaller to creep closer to mob if Mob is Moving
                    /varcalc PullDist ${PullDist}*.6
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull PullDist: ${PullDist}*.6 - PullLoops: ${PullAttempts} \agLine#: ${Macro.CurLine}
                    /goto :PullAgain
                }
            }
            | 1s timer used in conjunction with PullAttempts to control pulling
            /delay 10
        | - Check to see if we are stuck
        /if ((${Int[${Me.X}]}==${X1}) && (${Int[${Me.Y}]}==${Y1})) {
            /varcalc StuckCount (${StuckCount})+1
            /if (${StuckCount}>=2) {
                /if (${IAmDead} || ${Me.Hovering}) {
                    /if (${MoveTo.Moving}) /moveto off
                    /if (${Navigation.Active}) {
			/echo 9 stopping nav 
			/nav stop
		    }
                    /if (${AdvPath.State}) /play off
                    /return
                } else {
                    /call Stuck
                } 
            }
            /if (${StuckCount}>=7 && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull}))) {
                /echo I am stuck aborting pull
                 /squelch /alert add 1 id ${MyTargetID}
                /if (${MoveTo.Moving}) /moveto off
                /if (${mq2navloaded}) {
			/if (${Navigation.Active}) {
				/echo 10 stopping nav 
				/nav stop
			}
		}
                /if (${AdvPath.State}) /play off
                /if (${ReturnToCamp}) {
                    /call DoWeMove "FindMobToPull 5"
                }
                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                    /call PullReset
                    /return
                }
            }
        }
        /if (${DebugPull})  /echo \atDEBUGPULL Pull Loop Count: ${PullAttempts} \agLine#: ${Macro.CurLine}
        | Not using advpath
        /if (!${PullPathWpCount}) {
            | Distance loop check until mob in range to pull
            /if ((${Spawn[${MyTargetID}].Distance}>${PullRange} || !${Spawn[${MyTargetID}].LineOfSight}) && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull}))) /goto :WeThereYet
            | If mob moves out of line of sight during pull try moveto mob again
            /if (!${Spawn[${MyTargetID}].LineOfSight} && !${Select[${Role},hunter,hunterpettank]} && ${PullTimer}) {
                /varcalc PullDist ${PullDist}*.8
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Decrease pull distance to ${PullDist} \agLine#: ${Macro.CurLine}
                /goto :PullAgain
            }
            /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID})) && ${ChainPull})) /goto :PullAgain
        }
        /if (${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance}<${PullRange} && (( !${AggroTargetID} && !${ChainPull} ) || ( !${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull} ))) {
            /if (${MoveTo.Moving}) /moveto off
            /if (${mq2navloaded}) {
				/if (${Navigation.Active}) {
					/echo 11 stopping nav 
					/nav stop
				}
		    }
            /if (${mq2advpathloaded}) {
				/if (${AdvPath.State}) /play off
	    	}
            | Target mob before Aggroing
            /target id ${MyTargetID}
            /delay 20 ${Target.ID}==${MyTargetID}
            | Validate target one more time before pulling
                /call ValidateTarget
                /if (${ValidTarget}==0) {
                    /squelch /alert add 1 id ${Target.ID}
                    /squelch /target clear
                    /echo Aborting Pull! Target invalid now! Reason:${Macro.Return}
                    /if (${ReturnToCamp}) {
                        /call DoWeMove "FindMobToPull 6"
                    }
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                        /call PullReset
                        /return
                    }
                }
            | Handle pulling with Melee setting
            /if (${PullWith.Equal[Melee]} || (${PullWithAlt.Equal[Melee]} && ${ToClose})) {
                /if (${DebugPull}) /echo \atDEBUGPULL PULL: Melee \agLine#: ${Macro.CurLine}
                /if (!${Select[${Role},hunter,hunterpettank]}) {
                    | Turn off mq2melee function so puller and pullertank doesn't attack mob on pull
                    /if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=0
                    :AttackAgain
                        /moveto id ${MyTargetID} mdist 15
                        /if (${Target.ID}) {
				/echo face 2
				/face nolook
			}
                        /look 0
                        /attack on
                        /if (${PullMeleeStick} && !${AggroTargetID}) /stick id ${MyTargetID} 70%
                        /delay 10
                    /if (((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${ChainPull})) && ${Target.PctHPs}==100) /goto :AttackAgain
                    | Turn off combat so puller returns to camp. You mean run like hell.
                    /if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]}) {
                        :StopCombat
                            /attack off
                            /if (${Stick.Active}) /stick off
                            /squelch /target clear
                        | Cycle until combat off and mob is aggro'd
                        /if (${Me.Combat} && ((${AggroTargetID} && !${ChainPull}) || ${Target.PctHPs}<100)) /goto :StopCombat
                        | Turn on mq2melee function back on after pull
                        /if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=1
                    }
                }
                /varset Pulled 1
                /varset ToClose 0
            | Pull with ranged
            } else /if (${PullWith.Equal[Ranged]} && !${ToClose}) {
                /if (${DebugPull}) /echo \atDEBUGPULL PULL: Ranged \agLine#: ${Macro.CurLine}
                :RangedAgain
                    /doevents
                    /if (${ToClose}) {
                       /varset PullDist 15
                       /goto :PullAgain
                    }
                    /if (${DPSPaused}) /return 
                    /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) && ${ChainPull})) {
                        /varset Pulled 1
                        /goto :DonePulling
                    }
                    /if (${CantHit}) {
                        /varset CantHit 0
                        /varcalc PullDist ${PullDist}*.8
                        /goto :PullAgain
                    }
                   /if (${CantSee}) {
                      /if (${Target.ID}) {
				/echo face 3
				/squelch /face nolook
		      }
                      /delay 10
                      /varset CantSee 0
                      /if (${DebugPull}) /echo Could Not see Target. Trying Again. \agLine#: ${Macro.CurLine}
                   }
                   | Mod for puller to turn back to camp after /range this saves on the puller turning AFTER mob is aggroed  and turns facing camp while waiting for mob to aggro.
                   /if (${Me.Combat}) {
                      /Attack off
                      /delay 20 !${Me.Combat}
                   }
                   /if (${Stick.Active}) /stick off
                   /if (${Target.ID}) {
			/echo face 4
			/squelch /face nolook
		   }
                   /look 0
                   /delay 20 ${Me.Heading.ShortName.Equal[${Target.HeadingTo}]}
                   /if (${Target.ID}==${MyTargetID}) /range
                   /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius}) {
                       /delay 10
                       /if (${Target.ID}) {
				/echo facing nolook loc ${CampYLoc},${CampXLoc}
				/squelch /face nolook loc ${CampYLoc},${CampXLoc}
			}
                    }
                    /if (!${ChainPull}) {
                        /delay ${Math.Calc[1+${Target.Distance}/50].Int}s ${AggroTargetID}
                    } else {
                       /delay ${Math.Calc[1+${Target.Distance}/50].Int}s ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}
                    }
                    /if (${DebugPull}) /echo \atDEBUGPULL Pull: ${PullTimer} && (!${AggroTargetID} || ${Target.PctHPs}==100) ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID} \agLine#: ${Macro.CurLine}
                    /if (${PullTimer} && !${PullTooFar} && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${ChainPull}))) /goto :RangedAgain
                    /if (${AggroTargetID}) {
                        /varset Pulled 1
                        /goto :DonePulling
                    }
            | PetPull section - Written by TreeHuginDruid for RedGuides
            } else /if (${PullWith.Equal[Pet]}) {                
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: Pet \agLine#: ${Macro.CurLine}         
                /if (${Target.ID}) {
			/echo face 6
			/face nolook
		}
                |- Ensure we are in pull range and pet is following!                              
                /if (${Me.Pet.Stance.NotEqual[FOLLOW]}) /pet follow
                | - Send in pet if I don't have a mob in extended target)               
               :SendInPet
                /if ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${ChainPull})) {
                    /pet attack
                    /delay 10 (${AggroTargetID} && !${ChainPull}) || ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID} 
                    | Fix for HunterPetTank
                    /if (${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Type.NotEqual[corpse]} && ((!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${Me.Pet.ID} && ${ChainPull}))) /goto :SendInPet
                }
                | - If I have a extended target, flag as pulled.
                /if ((${AggroTargetID} && !${ChainPull}) || ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) {
                    /varset Pulled 1
                    /if (${PetHoldOn}) /pet ${PetHold} on
                    /pet back off
                    /goto :DonePulling
                } 
            | Pull with cast
            } else {
                /if (${DebugPull}) /echo \atDEBUGPULL Pull: Casting to pull mob \agLine#: ${Macro.CurLine}
                /delay 5s !${Me.Moving} || (${AggroTargetID} && !${ChainPull}) || ${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}
                /if (${Target.ID}) {
			/echo face 7
			/face nolook
		}
                /look 0                 
                /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) && ${ChainPull})) /goto :PullAgain
                /if (!${SpawnCount[npc los id ${Target.ID}]}) {
                    /varcalc PullDist ${PullDist}*.8
                    /goto :PullAgain
                }
                /if (!${Me.Moving}) {
			/if (${UseCalm}) {
				/varset CalmOldID ${Target.ID}
				/echo in calm sequence, CalmOldID is ${Target.ID}
				/echo there are ${SpawnCount[npc loc ${Target.X} ${Target.Y} radius 50]} mobs within a 50 radius of our target.
				|only cast if its needed...
				/if (${SpawnCount[npc loc ${Target.X} ${Target.Y} radius 50]} > 1) {
					/echo there are more than 1 mob within a 50 radius of our target...
					/varset CalmID ${NearestSpawn[2,NPC loc ${Target.X} ${Target.Y} radius 50]].ID}
					/echo CalmID is ${CalmID}
					/echo ${Spawn[id ${CalmID}]} is ${Spawn[id ${CalmID}].Distance} away, the ${CalmWith} spell range is ${Spell[${CalmWith}].Range}
                			:moveabitcloserforcalm
					/if (${Spawn[id ${CalmID}].Distance3D} > ${Spell[${CalmWith}].Range}) {
						|/echo crap we are out of range for ${CalmWith}
						|/echo lets move a little bit closer
						/squelch /face nolook id ${CalmID}
						/keypress forward hold
						/delay 1
						/keypress forward up
						/goto :moveabitcloserforcalm
					}
					/if (${CalmID} && ${Spawn[id ${CalmID}].Distance3D} <= ${Spell[${CalmWith}].Range}) {
						/echo its ok to calm them down!
						/tar id ${CalmID}
						/delay 2s ${Target.ID}==${CalmID}
						/delay 5s ${Target.BuffsPopulated}
						/if (!${Target.Buff[${CalmWith}].ID}) {
							/echo time to calm down the situation... casting ${CalmWith} on ${Target}
							/call CastWhat "${CalmWith}" ${CalmID} Calm
							/delay 2s ${Bool[${Target.Buff[${CalmWith}].ID}]}==TRUE
						}
						/tar id ${CalmOldID}
						/delay 2s ${Target.ID}==${CalmOldID}

					}
				}
			}
			/call CastWhat "${PullWith}" ${Target.ID} Pull
                	/if (${Macro.Return.Equal[CAST_SUCCESS]} || (${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) && ${ChainPull})) /varset Pulled 1
                	/delay 1s (${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${Target.ID}) && ${ChainPull})
            	}
	    }
            |- Toggle puller mode off if option enabled.
            /if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}==${Me.ID}) /call TogglePullMode TurnOff            
        } else /if ((${AggroTargetID} && !${ChainPull}) || ((${Me.XTarget[${XTSlot2}].ID} || ${Me.XTarget[${XTSlot}].ID}==${MyTargetID}) && ${ChainPull})) {
            | The else /if fixes when puller stalls because puller grabs aggro with out getting to pull.
            /varset Pulled 1
        }
        | If pull failed start over while timer > 0
        /if (!${PullPathWpCount} && !${Pulled}) /goto :PullAgain
        :DonePulling
        | reset mq2moveutils mdist back to 10 from pull distance to ensure correct movement
	/echo moveto 8
        /moveto mdist 10
        /if (${rangedSwitch}) {
            /call CheckCasting 50
            /exchange "${OrigRanged}" ranged
            /varset rangedSwitch 0
            /delay 10
        }
        /if (${ammoSwitch}) {
            /call CheckCasting
            /if (${Cursor.ID}) /autoinventory
            /exchange "${tempAmmo}" ammo
            /varset ammoSwitch 0
            /delay 10
        }
        /varset Pulling 0
        | Turn autofire back on
        /if (${AutoFireOff}) {
            /if (${DebugPull}) /echo \atDEBUGPULL Pull AutoFire on \agLine#: ${Macro.CurLine}
            /varset AutoFireOff 0
            /varset AutoFireOn 1
        }
        /if (${Select[${Role},hunter,hunterpettank]} && ${MyTargetID}) {
            /if (${PullWith.Equal[Melee]} && ${Target.Moving}) {
                /moveto id ${MyTargetID} mdist 10
                /if (${Target.ID}) {
			/echo face 8
			/face nolook
		}
                /if (${Me.FeetWet}) {
                    /stick uw ${StickHow} 8 id ${MyTargetID}
                } else {
                    /stick ${StickHow} 8 id ${MyTargetID}
                }
            }
            /call Combat
            /call CombatReset
            /call PullReset
            | Try to return home if exceeding max radius while in ANY hunter mode
            /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${Math.Calc[${MaxRadius}*.95]}) {
                /if (${DebugPull}) /echo \atDEBUGPULL Pull Returning hunter to camp \agLine#: ${Macro.CurLine}
                /echo ${Role}: Reached edge of ${MaxRadius} hunting radius. Trying to return to camp.
                /varset ReturnToCamp 1
                /call DoWeMove "FindMobToPull 7"
            }    
            /if (${DebugPull}) /echo \atDEBUGPULL Pull Leaving hunter combat \agLine#: ${Macro.CurLine}
            /return
        }
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Done Pulling \agLine#: ${Macro.CurLine}
        /echo \atDEBUGPULL Pull Done Pulling \agLine#: ${Macro.CurLine}
        /if (${ReturnToCamp} && ${Pulled}) {
            /call WaitForMob
            /varset Pulled 0
        }
        /if (${DebugPull}) /echo \atDEBUGPULL Pull Leave Mob ID:${Spawn[${MyTargetID}].ID} \agLine#: ${Macro.CurLine}
    /return

Sub DoThePullDance
	/if (${Target.Distance3D} <= 80) /return
	/declare RandTargetHeading float local 0
	/if (${ActNatural}) {
		/echo doing the pulldance
		/keypress forward hold
		/delay 2
		/keypress forward
	}
	/if (${Math.Rand[2]}) {
		/varcalc RandTargetHeading ${Target.HeadingTo.DegreesCCW} + ${Math.Rand[5,10]}
		/if (${ActNatural}) {
			/keypress left hold
			/delay 4
			/keypress left
		}
	} else {
		/varcalc RandTargetHeading ${Target.HeadingTo.DegreesCCW} - ${Math.Rand[5,10]}
		/if (${ActNatural}) {
			/keypress right hold
			/delay 4
			/keypress right
		}
	}
	/face nolook heading ${RandTargetHeading}
	/if (${ActNatural}) {
		/if (${Math.Rand[2]}) {
			/keypress back hold
			/delay 1
			/keypress back
		} else {
			/keypress forward hold
			/delay 1
			/keypress forward
		}
	}
/return
| -------------------------------------------------------------------------------------
| SUB: Wait for Mob
| -------------------------------------------------------------------------------------
    Sub WaitForMob
	/declare bDanceDone int local 0
        /if (${Select[${Role},hunter,hunterpettank]} || ${DPSPaused}) /return
        /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Enter \agLine#: ${Macro.CurLine}
        /varset WaitTimer 45s
        /if (${Pulled}) {
            /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Waiting for mob \agLine#: ${Macro.CurLine}
            /call DoWeMove WaitForMob
            /if (${ChainPull}) /varset LastMobPullID ${Target.ID}
            /declare FaceTimer timer local 0
            /if (${InvSlot[ranged].Item.Name.NotEqual[${OrigRanged}]} && ${OrigRanged.NotEqual[null]}) {
                /call CheckCasting 50
                /exchange "${OrigRanged}" ranged
            }
		|do the campdance... i.e act like a player, take a step back etc.
		|run a half circle, back up just a little and face the direction of the incomming mob.
		|todo add that code... we can do it with keypresses, its easier than using nav
		|
            :WaitForMob
				/if (!${bDanceDone}) {
                	/if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID})) {
						/call DoThePullDance
						/varset bDanceDone 1
						|/echo dance done...
					}
				}
                /doevents
                /call MobRadar ${CampRadius} WaitForMob
                | If NOT chain pulling and multiple mobs in camp. /return
                /if (${MobCount}>=2 && !${ChainPull}) {
                    /call PullReset
                    /return
                } 
                /if (${DebugPull}) /echo \atDEBUGPULL - WaitTimer: ${WaitTimer} Target Distance: ${Target.Distance} Mob Dist from Camp: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>=${CampRadius} Mob Dist from tank: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Me.Y},${Me.X}]}>=20 \agLine#: ${Macro.CurLine}
                | if target lost somehow add to ignore list and continue pulls
                /if ((!${AggroTargetID} && !${ChainPull}) || ${WaitTimer}==0) {
                    /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob /return no AggroTargetID \agLine#: ${Macro.CurLine}
                    /squelch /alert add 1 id ${Target.ID}
                    /call PullReset 
                    /return
                }
                /varset FaceTimer 1s
                /delay 1s
                | I am PULLER with PET TANK            
                /if (${Select[${Role},pullerpettank]}) {
                    |- Make sure pet is returning to camp with me.
                    /if (${Me.Pet.ID} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${Me.Y},${Me.X}]}>20) {
                        /pet back off
                        /delay 10
                        /pet follow
                    } 
                    | If the mob is within pet attack distance from camp send the pet in to attack
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${PetAttackRange}) /goto :WaitForMob
                    /if (!${PetAttack}) /call CombatPet
                }
                | I am PULLER TANK
                /if (${Select[${Role},pullertank]}) {
                    | Wait in camp for mob if timer active and mob is outside of camp radius and mob is farther away from tank than 20 feet
                    /if (${WaitTimer} && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>${MeleeDistance}) /goto :WaitForMob
                }
                | If I am PULLER and NOT chain pulling
                /if (${Select[${Role},puller]} && !${ChainPull}) {
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>=${CampRadius} && ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20) /goto :WaitForMob
                    /if (${MercOn} && !${MercAssisting} && ${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
                }
                | If I am PULLER and chain pulling
                /if (${Select[${Role},puller]} && ${ChainPull}) {
                    | Leave if multi mobs or no mobs 
                    /if (${MobCount}>=2 || !${MyTargetID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot2}].ID})) { 
                        /call PullReset
                        /return
                    }
                    /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20 && ${Target.ID}==${Spawn[${MyTargetID}].ID} && ${Me.TargetOfTarget.ID}==${Me.ID}) /goto :WaitForMob                 
                }
        }
        /if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Spawn[${MyTargetID}].Distance}<=${MeleeDistance}) /call AssignGroupRole unset "${Me.CleanName}" 3            
        /if (${MyTargetID} && (!${AggroTargetID} && !${ChainPull}) || (!${Me.XTarget[${XTSlot2}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${MyTargetID} && ${ChainPull})) /call PullReset
        /if (${IAmABard}) /call DoBardStuff
        /varset WaitTimer 0
        /call MercsDoWhat
        /if (${DebugPull}) /echo \atDEBUGPULL WaitForMob Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Reset Pull variables
| -------------------------------------------------------------------------------------
    Sub PullReset
        /if (${DebugPull}) /echo \atDEBUGPULL PullReset Enter \agLine#: ${Macro.CurLine}
        /moveto mdist 10
        /varset Pulling 0
        /varset Pulled 0
        /varset MyTargetID 0
        /varset MyTargetName
        /varset ToClose 0
        /attack off
        /if (${MoveTo.Moving}) /moveto off
        /if (${mq2navloaded}) {
			/if (${Navigation.Active}) {
				/echo PullReset stopping nav 
				/nav stop
			}
		}
        /varset WaitTimer 0
        /squelch /target clear
        /if (${DebugPull}) /echo \atDEBUGPULL PullReset Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: TogglePullMode
| -------------------------------------------------------------------------------------
    Sub TogglePullMode(ToggleState)
        /if (!${Select[${Me},${Group.Leader}]} || !${SpawnCount[group mercenary]}) /return
        /if (${ToggleState.Equal[TurnOn]}) {   
            :TurnOnPullRole
            /if (${Target.Distance}>${CampRadius}) {                
                /if (${Group.Puller.ID}!=${Me.ID}) /grouproles set ${Me.CleanName} 3
                /delay 10 ${Group.Puller.ID}==${Me.ID}
                /if ((${Target.Distance}>${CampRadius}) && (${Group.Puller.ID}!=${Me.ID})) /goto :TurnOnPullRole  
                /if (${Group.Puller.ID}==${Me.ID}) /echo + You have been set be group puller.        
            }
        }
        /if (${ToggleState.Equal[TurnOff]}) {    
            :TurnOffPullRole
            /if ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})) {        
                /if (${Debug}) /echo KICKIT! ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})) \agLine#: ${Macro.CurLine}
                /if (${Group.Puller.ID}==${Me.ID}) /grouproles unset ${Me.CleanName} 3
            } else {
                /if ((${Group.Puller.ID}==${Me.ID}) && (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius})) /moveto loc ${CampYLoc} ${CampXLoc} mdist 10
            }
            /delay 10 ${Group.Puller.ID}!=${Me.ID}    
            /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} || (${Group.Puller.ID}==${Me.ID})) /goto :TurnOffPullRole   
            /if (${Group.Puller.ID}!=${Me.ID}) /echo + You are no longer group puller.
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: GroupWatch
| -------------------------------------------------------------------------------------
    Sub GroupWatch
        /if (!${GroupWatchOn} ) /return 
        /if (${AggroTargetID} && !${ChainPull}) /return
        /if (${Debug}) /echo \atDEBUG GroupWatch Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare GrpMemType string local
        /declare GrpMemName string local
        /declare GrpMemClass string local
        /declare GrpMemStat string local
        /if (!${Spawn[=${MainAssist}].ID} && !${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]} && ${CampZone}==${Zone.ID}) {
            /echo I am not detecting Main Assist pausing.
            :WaitForMA
                /doevents
                /call CheckForCombat 1 GroupWatch
                /call WaitSubs
                /if (${Spawn[=${MainAssist}].ID}) {
                    /echo Main Assist is back resuming action.
                    /return
                }
                /delay 10
            /goto :WaitForMA
        }
        /if (${ChainPullHold}==1) /varset ChainPullHold 0
        /for i 1 to 5
            /if (!${Group.Member[${i}].ID} || ${Group.Member[${i}].Type.Equal[corpse]} ) /goto :SkipCheck
            /if (${GroupWatchOn}==2 && !${Select[${Group.Member[${i}].Class.ShortName},CLR,DRU,SHM]}) /goto :SkipCheck
            /varset GrpMemType ${Group.Member[${i}].Type}
            /varset GrpMemName ${Group.Member[${i}].CleanName}
            /varset GrpMemClass ${Group.Member[${i}].Class.ShortName}
            /if (${Select[${GrpMemClass},BER,MNK,ROG,WAR]}) {
                /varset GrpMemStat Endurance
            } else {
                /varset GrpMemStat Mana
            }
            /if (${Debug}) /echo \atDEBUG ${i} /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" ${GrpMemStat} ${GroupWatchPct} 90 \agLine#: ${Macro.CurLine}
            /call CheckStats 1 "${GrpMemName}" ${GrpMemClass} ${GrpMemType} ${GrpMemStat} ${GroupWatchPct} 90
            /if (${Select[${GrpMemClass},BST,PAL,RNG,SHD]}) /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" Endurance ${GroupWatchPct} 90
            :SkipCheck
            /if (${ChainPull} && ${Group.Member[${i}].Type.Equal[corpse]}) /varset ChainPullHold 1
        /next i
        /if (${Debug}) /echo \atDEBUG GroupWatch Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckStats
| -------------------------------------------------------------------------------------
    Sub CheckStats(int statcheck, charname, ckclass, cktype, stat, int pause,int resume)
        /if (!${statcheck}) /return
        /if (!${Spawn[${ckclass} ${cktype} ${charname}].ID}) /return
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}>${pause}) /return
        /if (${Debug}) /echo \atDEBUG CheckStats Enter \agLine#: ${Macro.CurLine}
        /if (${Debug}) /echo \atDEBUG statcheck ${statcheck} charname ${charname} ckclass ${ckclass} stat ${stat} pause ${pause} resume ${resume} \agLine#: ${Macro.CurLine}
        /if (${Role.Equal[puller]} && ${ChainPull} ) {
                /call MobRadar ${MeleeDistance} CheckStats
                /if (${MobCount}>0) {
                 /varset ChainPullHold 1
             /return
            }
        }
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} t "Waiting for >> ${charname} << to med up to ${resume}% ${stat}."
        } else {
            /echo  Waiting for >> ${charname} << to med up to ${resume}% ${stat}.
        }
        | target toon to make sure they aren't at full mana due to lag
        /target id ${Spawn[${ckclass} ${cktype} ${charname}].ID}
        /delay 10
        /varset Pulling 0
        | Only twist med if song no aggro others fighting willnegate bard fast med
        /if (${IAmABard} && ${TwistMed} && ${TwistOn} && ${AggroTargetID}) /squelch /twist ${TwistMed}
        /varset Medding 1
        :wait_for_resume
            /doevents
            /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15 ) {
                /if (!${Me.Mount.ID} && ${Me.Sitting}) {
			/echo going to stand 9
			/stand
		}
                /call DoWeMove CheckStats
                /delay 100 ${MoveTo.Stopped}
            }
            /delay 10
            /call CheckCasting 50
            /delay 10
            /call CheckForCombat 1 CheckStats
            |/if (!${MedCombat}) /call WaitSubs
            /if (${AggroTargetID}) {
                /varset Medding 0
                /return
            }
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}<${resume}) /goto :wait_for_resume
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) /call BroadCast ${IRCOn} ${EQBCOn} t "${charname} is now above ${resume}% ${stat} resuming activity."
        /echo ${charname} is now above ${resume}% ${stat} resuming activity.
        /if (!${Me.Mount.ID} && ${Me.Sitting}) {
		/echo going to stand 10
		/stand
	}
        /varset Medding 0
        /varset ChainPullHold 0 
        /if (${IAmABard} && ${TwistMed}) /stopsong
        /if (${ChainPull} && ${ChainPullPause.NotEqual[0]}) /varset ChainPullTimer ${ChainPullPause.Arg[1,"|"]}m
        /if (${Debug}) /echo \atDEBUG CheckStats Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: alert clear
| -------------------------------------------------------------------------------------
    Sub ClearOutAlerts(int ListToClear)
        /if (${DebugPull}) {
            /echo \atDEBUGPULL ClearOutAlerts Enter  \agLine#: ${Macro.CurLine}
            /echo \atDEBUGPULL Clearing Alert list ${ListToClear}. \agLine#: ${Macro.CurLine}
        }
        /squelch /alert clear ${ListToClear}
        /if (${DebugPull}) /echo \atDEBUGPULL ClearOutAlerts Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Assign Group Role
| -------------------------------------------------------------------------------------
    Sub AssignGroupRole(ASGOnOff, AGRName, AGRRole)
        /if (${Debug}) /echo \atDEBUG AssignGroupRole ${ASGOnOff} ${AGRName} ${AGRRole} \agLine#: ${Macro.CurLine}
        /docommand /grouproles ${ASGOnOff} ${AGRName} ${AGRRole}
        /delay 10
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantSee CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantSee
        /if (${Debug}) /echo \atDEBUG Event_CantSee \agLine#: ${Macro.CurLine}
        | Reset position via stick
        /if (${Pulling}) {
           /varset CantSee 1
           /return
        }
        /if (${Attacking}) {
            /if (${Debug}) /echo Can't See my target. Moving Closer. \agLine#: ${Macro.CurLine}
            /if (${Me.Sitting}) {
		/echo stand in cantsee
		/stand
	    }
            /if (${Target.ID}) {
		/echo facing 10
		/squelch /face nolook
	    }
            /look 0
            /if (${StickHow.NotEqual[0]}) {
                /if (${Me.FeetWet}) {
                /stick 8 uw ${StickHow} id ${MyTargetID}
                } else {
                    /stick 8 ${StickHow} id ${MyTargetID}
                }
            } else {
                /if (${Me.FeetWet}) {
                    /stick 8 uw pin id ${MyTargetID}
                } else {
                    /stick 8 pin id ${MyTargetID}
                }
            }
        }
        /if (${Debug}) /echo Leave Event_CantSee \agLine#: ${Macro.CurLine}
        /doevents flush CantSee
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantHit
        /if (${Debug}) /echo Event_CantHit \agLine#: ${Macro.CurLine}
        | Reset position via stick
        /if (${Pulling}) {
            /varset CantHit 1
        }
        /if (${Debug}) /echo Leave Event_CantHit \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event Missing
| -------------------------------------------------------------------------------------
    Sub Event_Missing

    /return 1
| ----------------------------------------------------------------------------
| SUB: Bind Switch
| ----------------------------------------------------------------------------
    Sub Bind_Switch
        /echo New target called!
        /call CombatReset
        /call Assist
        /call Combat
    /return
| ----------------------------------------------------------------------------
| SUB: Event GotHit - Written by TreeHuginDruid for RedGuides
| ----------------------------------------------------------------------------
    Sub Event_GotHit(string Line, string AttackingMob)
	/if (${Defined[MeleeHit]}) {
		/varset MeleeHit 1
	}
        /declare GotHitDistChk int local 10
        /varset GotHitToggle 1
        /declare AttackingMobID int local
        /if (${AggroTargetID} && !${Target.ID} && !${ReturnToCamp}) {
            /call CheckForCombat 1 Event_GotHit
        }
        /if (${Pulled} && ${WaitTimer} && ${Select[${Role},pullertank,pullerpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
            /if (${NearestSpawn[npc los radius ${CampRadius} targetable].ID}!=${MyTargetID}) {
                /varset MyTargetID 0
                /varset MyTargetName
            }
            /varset WaitTimer 0s
            /echo I got hit (${Line}) by >> ${AttackingMob} << ID:${AttackingMobID} while waitng for mob.
        }     
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]}) {   
            /doevents flush GotHit        
            /varset AttackingMobID ${NearestSpawn[npc radius 39 targetable "${AttackingMob}"].ID}
            /squelch /target id ${Spawn[${AttackingMobID}].ID}                         
            /delay 10 ${Target.ID}==${AttackingMobID}            
            |- If mob that hit me still too close, move to camp or away from mob.
            /if (${GotHitToggle} && ${AttackingMobID}>0) {
                /echo I got hit (${Line}) by >> ${AttackingMob} << ID:${AttackingMobID}!
                /moveto mdist 5
                /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && !${Select[${Role},hunterpettank]} && ${ReturnToCamp}) {
                    |- Only move away from mob if MoveWhenHit enabled (1)
                    /if (${MoveWhenHit}) {
                        /echo Moving back to camp!
                        /moveto loc ${CampYLoc} ${CampXLoc}
                    }
                } else {
                    |- If mob is in pet attack range from camp, send pet in.
                    /if (${Me.Pet.ID} && ${Math.Distance[${Target.Y},${Target.X}:${Me.Pet.Y},${Me.Pet.X}]}<=${PetAttackRange}) /pet attack
                    |- Only move away from mob if MoveWhenHit enabled (1)
                    /if (${MoveWhenHit}) {
                        /echo Trying to get away from >>${AttackingMob}<<.
                        /if (${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}<=${GotHitDistChk}) /moveto loc ${Target.Y} ${Math.Calc[${Target.X}-${GotHitDistChk}]}
                    }
                }
            }
            /if (${MoveWhenHit}) /delay 15 ${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}>${GotHitDistChk}
            /if (${Target.ID}) {
		/echo face 11
		/face nolook
	    }
        }
        /varset GotHitToggle 0
        /doevents flush GotHit
    /return
| ----------------------------------------------------------------------------
| SUB: Event Zoned
| ----------------------------------------------------------------------------
    Sub Event_Zoned(Message)
        /if (${Message.Find[Drunken Monkey]} || ${Message.Find[effects]}) /return
        /delay 60s ${Me.ID}
        /if (!${JustZoned}) /echo Just zoned
        /call CombatReset zoned
        /varset JustZoned 200
        /varset CampOnDeathTimer 10m
        /if (${ReturnToCamp} && ${CampZone}!=${Zone.ID}) /varset RememberCamp 1
        /varset LastZone ${Zone.ID}
        | Shut down combat and mez in GH, GL, PoK, PoT, and Abysmal
        /if (${Select[${Zone.ID},345,344,202,203,279]}) {
            /varset DMZ 1
        } else /varset DMZ 0
        /if (${ReturnToCamp} && ${CampZone}!=${Zone.ID}) /varset ReturnToCamp 0
        /if (${RememberCamp} && ${CampZone}==${Zone.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=100) {
            /varset ReturnToCamp 1
            /varset RememberCamp 0
        }
        /call CombatReset zoned
        /call WinTitle
    /return
| ----------------------------------------------------------------------------
| SUB: Event Joined 20s switch to prevent heals from firing off
| ----------------------------------------------------------------------------
    Sub Event_Joined(string Jmessage,string Joinee)
         /echo ${Joinee} has joined the party.
         /varset JoinedParty 200
     /return
| ----------------------------------------------------------------------------
| SUB: Event Too Close
| ----------------------------------------------------------------------------
    Sub Event_TooClose
        /if (${MyTargetID} && ${AutoFireOn} && ${CombatStart} && ${UseMQ2Melee}) {
	    /echo TURNING AUTOFIRE OFF WE ARE TOO CLOSE
            /varset AutoFireOn 0
            /killthis
            /timed 300 /varset AutoFireOn 1
        }
        /if (${Pulling} && ${PullWithAlt.Equal[Melee]}) {
           /echo Mob Too Close for ${PullWith}... Switching to Melee.
           /varset ToClose 1
        }
        /doevents flush TooClose
    /return
| ----------------------------------------------------------------------------
| SUB: Event Banestrike - by Petesampras
| ----------------------------------------------------------------------------
   Sub Event_Banestrike
    /if (${Target.ID} && !${Banestrike.Find[|${Target.Race}|]}) /varset Banestrike ${Banestrike}${Target.Race}|
   /return
| ----------------------------------------------------------------------------
| SUB: Event Camping - end macro
| ----------------------------------------------------------------------------
    Sub Event_Camping        
        /if (${IAmABard} && ${Twist}) /twist off
        /end
    /return
| ----------------------------------------------------------------------------
| SUB: Event Too Far
| ----------------------------------------------------------------------------
    Sub Event_TooFar
        /if (${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius} && ${MeleeOn} && ${CombatStart} ) {
            /if (${Me.FeetWet}) {
                /squelch /stick 8 uw ${StickHow} id ${MyTargetID}
            } else {
                /squelch /stick 8 ${StickHow} id ${MyTargetID}
            }
        }
	/declare ZDist float local 0
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /call ZAxisCheck ${ZDist} 4.1
        /if (${Select[${Role},pullertank,pullerpettank,puller]} && ${Pulling}) {
            /varset PullTooFar 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Change Var Int resets various interger settings from ini file
| ----------------------------------------------------------------------------
    Sub Bind_ChangeVarInt(ISection, IName, IVar)
        /if (${Debug}) Bind_ChangeVarInt ${ISection} ${IName} ${IVar} \agLine#: ${Macro.CurLine}
        /echo Changing ${IName} to ${IVar}
        /varset ${IName} ${IVar}
        /ini "${IniFileName}" "${ISection}" "${IName}" "${IVar}"
        /if (${IName.Find[mezon]} && !${Defined[MezTimer1]}) /call CreateTimersMez
        /if (${IName.Find[dpson]} && !${Defined[DPSTimer1]}) /call CreateTimersDPS
        /if (${IName.Find[buffson]} && !${Defined[Buffs1Timer0]}) {
            /call CreateTimersBuffs
            /echo Buffs on creating timers
        }
        /if (${IName.Equal[ChaseAssist]} && ${ReturnToCamp}) /varset ReturnToCamp 0
        /if (${IName.Equal[ChaseAssist]} && ${IVar}==0 && ${Stick.Active}) /squelch /stick off
        /if (${IName.Equal[ChaseAssist]} && ${IVar}==1 && !${Stick.Active}) /varset RebuffOn 300
        /if (${IName.Equal[MaxRadius]}) /varcalc CampRadiusExceed ${MaxRadius}+200
    /return
| ----------------------------------------------------------------------------
| SUB: Event Task Update - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_TaskUpdate(Line,name)
       /call BroadCast ${IRCOn} ${EQBCOn} t "Task updated...(${name})"
    /return
| ----------------------------------------------------------------------------
| SUB: Event Gain Something - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_GainSomething(string Line,string text)
        /if (!${EQBCOn} && !${IRCOn}) /return
        /if (${Line.Find["ABILITY POINT!"]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} w "${Me.Name} gained an AA, now has ${Me.AAPoints} unspent"
        } else /if (${Line.Find[LEVEL]}) {
            /call BroadCast ${IRCOn} ${EQBCOn} w "${Me.Name} gained a level, now is Level ${Me.Level}"
            /if (${GMailEvents.Find[level]}) /call GmailSend "${Me.Name} gained a level, I am Level ${Me.Level}"
           | Recalculate pull when level gained
            /if (${PullLevel.Find[auto]}) {
               /varcalc PullMin ${Me.Level}-5
               /varcalc PullMax ${Me.Level}+2       
            } 
        } 
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Edit - Edit ini file in MQ2NotePad
| ----------------------------------------------------------------------------
    Sub Bind_KissE
        /if (!${Bool[${Plugin[MQ2Notepad]}]}) {
            /echo This function requires MQ2Notepad to be loaded..
            /echo 1. Please copy MQUI_NotepadWindow.xml to your Everquest/UIFiles/default or custom ui folder
            /echo 2. then /Plugin MQ2notepad
        }
        /if (${Bool[${Plugin[MQ2Notepad]}]}) {
            /docommand /notepad kissassist_${Me}.ini
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Check - scan ini file for errors based on nostress KissNamechecker.mac
| ----------------------------------------------------------------------------
    Sub Bind_KissCheck
        /call ScanIni
    /return
| ----------------------------------------------------------------------------
| SUB: Event Invised Mainly to turn off bard twisting while invis.
| ----------------------------------------------------------------------------
    Sub Event_Invised
        /if (${IAmABard} && ${Twist}) {
            /twist off
            /stop song
        }
    /return    
| ----------------------------------------------------------------------------
| SUB: Event ImDead
| ----------------------------------------------------------------------------
    Sub Event_ImDead
        /if (${IAmDead}) /return
        /echo I have died and the Angels wept.
        /if (${GMailEvents.Find[dead]}) /call GmailSend "I have died, passed on, departed my mortal coil."
        /varset IAmDead 1
        /call CombatReset ImDead
        /doevents flush ImDead
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM On
| ----------------------------------------------------------------------------
   Sub Event_GoMOn
   /if (${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
		/doevents flush GoMOn
		/return
   }
   /if (!${CombatStart} || ${GoMTimer}) /return
            | Release timer after trying to cast for 10 secs
	    	/varset GoMTimer 3s
            /declare i int local
            /declare GoMCast string local
            /declare GoMTarget string  local
            /for i 1 to ${GoMSpell.Size}
                /if (!${ConditionsOn} || !${GoMCOn} || ${If[${GoMCond[${i}]},1,0]}) {
                    /varset GoMCast ${GoMSpell[${i}].Arg[1,|]}
                    /varset GoMTarget ${GoMSpell[${i}].Arg[2,|]}
                    /if (${GoMCast.Equal[null]} || ${GoMCast.Find[spell]} || ${GoMSpellTimer${i}}) /goto :NextGOM
                    /echo Gift of Mana detected! Trying to cast ${GoMCast}
                    /doevents flush GoMOn
                    /if (${GoMTarget.Equal[Mob]} || (${GoMTarget.Equal[NULL]} && ${MyTargetID})) /varset GoMTarget ${MyTargetID} 
                    /if (${GoMTarget.Equal[Me]} && ${Me.ID}) /varset GoMTarget ${Me.ID}
                    /if (${GoMTarget.Equal[MA]} && ${Spawn[=${MainAssist}].ID}) /varset GoMTarget ${Spawn[=${MainAssist}].ID} 
                    /varset GoMActive 1
                    /if (${GoMTarget.Equal[${MyTargetID}]} && (${Target.Type.Equal[Corpse]} || !${Spawn[id ${MyTargetID}].ID})) {
                        /if (${Debug}) /echo \atDEBUG Event_GoMOn [GoM] skipping because mob is dead or a corpse. \agLine#: ${Macro.CurLine}
                        /echo [GoM] being skipped, because target (${GoMTarget}) is a corpse.
                        /varset GoMTimer 0
                        /delay 10                        
                        /doevents GoMOff
                        /return
                    }
                    | Wait for global cooldown if active
                    /delay 60 ${Me.SpellInCooldown}==FALSE
                    /if (${Me.SpellReady[${GoMCast}]}) {
                        /call CastWhat "${GoMCast}" ${GoMTarget} GoM
                    } else {
                        /echo "${GoMCast}" is not ready!
                        /delay 10
                    }
                    /if (${Debug}) /echo Return: ${Macro.Return} \agLine#: ${Macro.CurLine}
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Gift of Mana Casting >> ${GoMCast} << 
                        /varset GoMTimer 0
                        /varset GoMSpellTimer${i} (${Spell[${GoMCast}].Duration.TotalSeconds}*${DurationMod})*10
                        /doevents flush GoMOn
                        /delay 10
                        /doevents GoMOff
                        /return
                    }
                    :NextGOM
                }
            /next i
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM Off
| ----------------------------------------------------------------------------
    Sub Event_GoMOff
        /varset GoMActive 0
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo guild meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_GUEQBC(Message,GUName,GUText)
        /if (${GUName.Equal[${Me.CleanName}]}) /return
        /if (${EQBC.Connected} && ${Select[${EQBCOn},2,4]}) /call BroadCast ${IRCOn} ${EQBCOn} p "${GUName} tells Guild: ${GUText} "
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo fellowship meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_FSEQBC(Message,FSName,FSText)
        /if (${FSName.Equal[${Me.CleanName}]}) /return
        /if (${EQBC.Connected} && ${Select[${EQBCOn},3,4]}) /call BroadCast ${IRCOn} ${EQBCOn} p "${FSName} tells Fellowship: ${FSText} "
    /return
| ----------------------------------------------------------------------------
| SUB: Event EQBCIRC - Pick up commands from MQ2IRC or MQ2EQBC(todo)
| ----------------------------------------------------------------------------
   Sub Event_EQBCIRC(EIMessage,EISender,EICommand)
    /if (${EICommand.Left[1].Equal[/]} && ${EICommand.Left[2].NotEqual[/]}) /docommand ${EICommand}
    /doevents flush EQBCIRC
   /return
| ----------------------------------------------------------------------------
| SUB: AFK Tools from AHTools by Anonymous Hero
| ----------------------------------------------------------------------------
    Sub AFKTools
    /declare holding bool local
    /if (${CampZone}!=${Zone.ID} || (${HealsOn} && ${AggroTargetID}) ) /return
    /if (${Select[${AFKToolsOn},1,2]}) {
        :CZLockDown
            /if (${Posse.Strangers}>=1) {
                /if (!${holding}) {
                    /echo [AHTools] Macro on hold due to player activity in camp radius.
                    /call BroadCast ${IRCOn} ${EQBCOn} r "**PCS DETECTED IN CAMP RADIUS**"
                    /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                    /varset holding 1
                }
                /delay 1s
        /call CheckForCombat 1 AFKTools
        /doevents
        /goto :CZLockDown
        } else { /varset holding 0 }
    }
    /if (${Select[${AFKToolsOn},1,3]}) {
        /if (${GMailEvents.Find[GM]} && ${SpawnCount[GM]}>=1) /call GmailSend "GM in Zone, ${Zone.ShortName}" 
        :GMLockDown
        /if (${SpawnCount[GM]}>=1) {
            /if (${AFKGMAction}==1) {
                /if (!${holding}) {
                    /echo [AHTools] Macro on hold due to GM Presence
                    /call BroadCast ${IRCOn} ${EQBCOn} r "** GM DETECTED **"
                    /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                    /varset holding 1
                }
                /goto :GMLockDown
            } else {
                /varset holding 0
            }
            /if (${AFKGMAction}==2) /multiline ; /echo [AHTools] Ending Macro due to GM Presence ; /mq2log [AHTools] Ending Macro due to GM Presence ; /endmacro
            /if (${AFKGMAction}==3) /multiline ; /echo [AHTools] Unloading MQ2 due to GM Presence; /mq2log [AHTools] Unloading MQ2 due to GM Presence ; /unload
            /if (${AFKGMAction}==4) /multiline ; /echo [AHTools] Quitting out of EQ due to GM Presence ; /mq2log [AHTools] Quitting out of EQ due to GM Presence ; /quit
        }
    }
   /return
| ----------------------------------------------------------------------------
| SUB: Burn Section for new bind
| ----------------------------------------------------------------------------
    Sub Bind_Burn
        /call Event_Burn
    /return
| ----------------------------------------------------------------------------
| SUB: Burn Section
| ----------------------------------------------------------------------------
    Sub Event_Burn
        /if (${IAmDead} || ${Me.Hovering} || ${CampZone}!=${Zone.ID} || ${BurnText.Equal[null]} || !${BurnText.Length}) {
            /doevents flush Burn
            /return
        }
        /declare i int local
        /declare BurnSpell string local
        /declare BurnTarget string local
        /declare BurnTargetID int local
        /declare  BurnIfSpell string local
        /call BroadCast ${IRCOn} ${EQBCOn} r "BURN ACTIVATED => Autobots Transform <="
        /if (${UseTribute} && !${Me.TributeActive}) {
           /squelch /tribute personal on
           /varset TributeTimer 570s
        }
        /for i 1 to ${Burn.Size}
            /if (${Burn[${i}].Arg[2,|].Length}) {
                /varset BurnSpell ${Burn[${i}].Arg[1,|]}
                /varset BurnTarget ${Burn[${i}].Arg[2,|]}
            } else {
                /varset BurnSpell ${Burn[${i}]}
            }
            /if (${BurnSpell.Equal[null]} || ${Me.Hovering}) /goto :SkipBurnEntry
                /if (!${Burn[${i}].Arg[2,|].Length} || ${BurnTarget.Equal[Mob]}) /varset BurnTargetID ${MyTargetID}
                /if (${BurnTarget.Equal[Me]}) /varset BurnTargetID ${Me.ID}
                /if (${BurnTarget.Equal[MA]}) /varset BurnTargetID ${Spawn[=${MainAssist}].ID}
                /if (${BurnTarget.Equal[Pet]}) /varset BurnTargetID ${Me.Pet.ID}
                | /delay 10
                | Conditional Added to skip entry
                /if (${ConditionsOn} && ${BurnCOn} && ${If[${BurnCond[${i}]},0,1]}) /goto :SkipBurnEntry
                /if (${Burn[${i}].Arg[3,|].Length} && ${Burn[${i}].Arg[4,|].Length} && ${Burn[${i}].Arg[3,|].Equal[if]}) {
                    /varset BurnIfSpell ${Burn[${i}].Arg[4,|]}
                    /if (${Me.Buff[${BurnIfSpell}].ID} || ${Me.Song[${BurnIfSpell}].ID} || ${Me.ActiveDisc.Name.Find[${BurnIfSpell}]}) {
                        /echo ${BurnIfSpell} is active trying to cast ${BurnSpell}
                        /goto :CastBurn
                    } else /goto :SkipBurnEntry
                }
                /if (${Burn[${i}].Arg[3,|].Length} && ${Burn[${i}].Arg[4,|].Length} && ${Burn[${i}].Arg[3,|].Equal[notif]}) {
                    /varset BurnIfSpell ${Burn[${i}].Arg[4,|]}
                    /if (!${Me.Buff[${BurnIfSpell}].ID} && !${Me.Song[${BurnIfSpell}].ID} && !${Me.ActiveDisc.Name.Find[${BurnIfSpell}]}) {
                        /echo ${BurnIfSpell} is NOT active trying to cast ${BurnSpell}
                        /goto :CastBurn
                    } else /goto :SkipBurnEntry
                }
                :CastBurn
                /call CastWhat "${BurnSpell}" ${BurnTargetID} Burn
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting >> BURN${i}:${BurnSpell}
                    /delay 10
                }
            :SkipBurnEntry
        /next i
        /doevents flush Burn
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  Code from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Event_TooSteep
        /varset CampfireOn 0
        /echo Setting CampfireOn to 0. You are on a hill.
    /return


| ----------------------------------------------------------------------------
| SUB: GoBackToCamp Section - Goes back to camp
| ----------------------------------------------------------------------------
Sub Bind_GoBackToCamp
	/if (!${Navigation.Active}) {
		/echo Going back to camp...
               	/nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
	} else {
		/echo well... it looks like Navigation.Active is ${Navigation.Active} so we shouldnt start another
	}
/return

| ----------------------------------------------------------------------------
| SUB: Campfire Section -  OriginalCode from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Bind_Campfire
    /if (${Select[${Zone.ID},33506]}) /return
        /windowstate FellowshipWnd open
        /delay 10
        /nomodkey /notify FellowshipWnd FP_Subwindows tabselect 2
        /if (${Me.Fellowship.CampfireZone.ID}!=${Zone.ID}) {
            /nomodkey /notify FellowshipWnd FP_DestroyCampsite leftmouseup
            /delay 5s ${Window[ConfirmationDialogBox].Open}
            /if (${Window[ConfirmationDialogBox].Open}) {
                /nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
            }
            /delay 5s !${Me.Fellowship.CampfireZone.ID}
        }
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_RefreshList leftmouseup
        /delay 1s        
        /nomodkey /notify FellowshipWnd FP_CampsiteKitList listselect 1
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_CreateCampsite leftmouseup
        /delay 5s ${Me.Fellowship.CampfireZone.ID}
        /windowstate FellowshipWnd close
        /if (${Me.Fellowship.CampfireZone.ID}) /echo Campfire Dropped
    /return
| ----------------------------------------------------------------------------
| SUB: Sort Array
| ----------------------------------------------------------------------------
    Sub SortArray(ArrayName, CArrayName, HiLo, SortHow)
        /declare i                  int     local
        /declare j                  int     local
        /declare k                  int     local
        /declare l                  int     local
        /declare m                  int     local
        /declare TempSortedName     string  local ${HiLo}
        /declare TempPos            int     local 0
        /declare NewArrayPos        int     local 0
        /declare NewArraySize       int     local 0
        /declare TempArray[${${ArrayName}.Size}] string     local 0
        /declare TArray2[${${ArrayName}.Size}]   string     local 0
        /declare CArray[${${ArrayName}.Size}]    string     local TRUE
        /declare MArrayCount int    local 1
        /declare WArrayCount int    local 1
        /declare TempSwapHold       string  local
        /declare Swapped            int     local 1
        /if (${Select[${CArrayName},NULL,GoMCond,HealsCond,DPSCond,BurnCond,GHCond,SHCond,MashCond,WeaveCond,AggroCond,BandolierCond]}==0) {
            /echo ${CArrayName} is an invalid Condition. Supported Conditions for DPS, GOM, Burn, Heals, Mash, Weave, Bandolier and Aggro. 
            /beep
        }
        | Assign Array to temp array
        /for i 1 to ${${ArrayName}.Size}
            /if (${Debug}) /echo ${i} ${${ArrayName}[${i}]} \agLine#: ${Macro.CurLine}
            /varset TempArray[${i}] ${${ArrayName}[${i}]}
            /if (${CArrayName.NotEqual[null]}) {
                /vardata CArray[${i}] ${CArrayName}[${i}]
            }
        /next i
        /if (${ArrayName.Equal[dps]}) {
            /for i 1 to ${TempArray.Size}
                /if (${TempArray[${i}].Find[|weave]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset WeaveArray[${WArrayCount}] ${TempArray[${i}]}
                    /vardata WeaveCond[${WArrayCount}] CArray[${i}]
                    /if (${Debug}) /echo ${WeaveArray[${WArrayCount}]}
                    /if (${WArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc WArrayCount ${WArrayCount}+1
                } else /if (${TempArray[${i}].Find[|mash]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset MashArray[${MArrayCount}] ${TempArray[${i}].Arg[1,|]}
                    /vardata MashCond[${MArrayCount}] CArray[${i}]
                    /if (${Debug}) /echo ${MashArray[${MArrayCount}]}
                    /if (${MArrayCount}) /varset TempArray[${i}] NULL
                    /varcalc MArrayCount ${MArrayCount}+1
                }
            /next i
        }
        | Move Array to Temp Array leaving out useless entries.
        /for m 1 to ${${ArrayName}.Size}
            /if (${TempArray[${m}].Length} && !${TempArray[${m}].Find[|0]} && ${TempArray[${m}].NotEqual[null]}) {
                /varcalc NewArrayPos ${NewArrayPos}+1
                /varset TArray2[${NewArrayPos}] ${TempArray[${m}]}
                /varcalc NewArraySize ${NewArraySize}+1
                /if (${CArrayName.NotEqual[null]} && ${m}!=${NewArrayPos}) {
                     /vardata CArray[${NewArrayPos}] CArray[${m}]
                     /varset CArray[${m}] null
                }
            } else {
                /if (${CArrayName.NotEqual[null]}) /varset CArray[${m}] null
            }
        /next m
        |Sort the Array if needed
        /if (!${Select[${ArrayName},Buffs,Burn,Aggro]} && ${NewArraySize}>1) {
            /varset m ${NewArraySize}
            /while (${Swapped} && ${m}>1) {
                /varset Swapped 0
                /for k 2 to ${m}
                    /varcalc j ${k}-1
                    /if (${TArray2[${j}].Arg[2,|]} ${SortHow} ${TArray2[${k}].Arg[2,|]}) {
                        /varset TempSwapHold ${TArray2[${j}]}
                        /varset TArray2[${j}] ${TArray2[${k}]}
                        /varset TArray2[${k}] ${TempSwapHold}
                        /varset Swapped 1
                        /if (${CArrayName.NotEqual[null]}) {
                            /vardata TempSwapHold CArray[${j}]
                            /vardata CArray[${j}] CArray[${k}]
                            /vardata CArray[${k}] TempSwapHold
                        }
                    }
                /next k
                /varcalc m ${m}-1
            }
        }
        | Bail if array is empty and turn off switch
        /if (!${NewArraySize}) {
            /if (${Defined[${ArrayName}On]}) {
                /varset ${ArrayName}On 0
                /echo ERROR: ${ArrayName}On=1 but section is empty. Turning ${ArrayName} off. Please check your ini file.
                /beep
                /delay 20
            }
            /return
        }
        /deletevar ${ArrayName}
        /declare ${ArrayName}[${NewArraySize}] string outer
        /for l 1 to ${NewArraySize}
            /varset ${ArrayName}[${l}] ${TArray2[${l}]}
            /if (${Debug}) /echo  ${${ArrayName}[${l}]} \agLine#: ${Macro.CurLine}
        /next l
        /if (${CArrayName.NotEqual[null]}) {
            /deletevar ${CArrayName}
            /declare ${CArrayName}[${NewArraySize}] string outer
            /for l 1 to ${NewArraySize}
                /vardata ${CArrayName}[${l}] CArray[${l}]
            /next l
        }
        /if (${ArrayName.Equal[buffs]}) /call CreateTimersBuffs
        /if (${ArrayName.Equal[dps]}) /call CreateTimersDPS
        /if (${Debug}) /echo ${${ArrayName}.Size} \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers DPS
| ----------------------------------------------------------------------------
    Sub CreateTimersDPS    
        | Declare timers for DPS duration spells and Attack buffs
        /declare i int local
        /varset DebuffCount 0
        /for i 1 to ${DPS.Size}
            /if (${Int[${DPS[${i}].Arg[2,|]}]}<101) { 
                /declare DPSTimer${i}       timer         outer 5
                /declare ABTimer${i}        timer         outer 0
                /declare FDTimer${i}        timer         outer 0
            } else {
                /declare DBOTimer${i}       timer         outer 0
                /declare DBOList${i}        string        outer 
                /varcalc DebuffCount ${DebuffCount}+1
            }
        /next i
    /return    
| ----------------------------------------------------------------------------
| SUB: Assign single heals - seperate single heals from group heals
| ---------------------------------------------------------------------------
Sub FindSingleHeals
    /if (${Debug}) /echo Enter FindSingleHeals \agLine#: ${Macro.CurLine}
    /declare i int local
    /declare j int local
    /declare SHCount int 0
    /declare HealHighPoint int  local 0
    /declare HealHighestPoint int  local 0
    /declare HealHighestPointMA int  local 0
    /declare HealPointTag string  local 0
    /declare HealSpell string  local
    /for i 1 to ${Heals.Size}
        /varset HealSpell ${Heals[${i}].Arg[1,|]}
        /varset HealHighPoint ${Heals[${i}].Arg[2,|]}
        /varset HealPointTag ${Heals[${i}].Arg[3,|]}
        /if (${Debug}) /echo ${i} ${HealSpell} ${Spell[${HealSpell}].TargetType} ${Select[${Spell[${HealSpell}].TargetType},SingleHeal,Self]} \agLine#: ${Macro.CurLine}
        /if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) {
            /varcalc SHCount ${SHCount}+1
            /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            /vardata SHCond[${SHCount}] HealsCond[${i}]
            /goto :NextSH
        }
        /if (${Select[${Me.Class.Name},Druid,Shaman]} && (${HealSpell.Find[Intervention]} || ${HealSpell.Find[Survival]})) {
            /varcalc SHCount ${SHCount}+1
            /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            /vardata SHCond[${SHCount}] HealsCond[${i}]
            /goto :NextSH
        }
        /if (${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${Heals[${i}].Arg[3,|].Find[tap]} || ${Heals[${i}].Arg[3,|].Find[pet]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && ${Select[${Heals[${i}].Arg[3,|]},MA,ME,pet]}) {
            /varcalc SHCount ${SHCount}+1
            /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            /vardata SHCond[${SHCount}] HealsCond[${i}]
            /goto :NextSH
        }
        /if (${Spell[${HealSpell}].TargetType.Equal[Free Target]}) {
            /varcalc SHCount ${SHCount}+1
            /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            /vardata SHCond[${SHCount}] HealsCond[${i}]
            /goto :NextSH
        }
        :NextSH
        /if (${HealPointTag.NotEqual[MA]} && ${HealHighPoint}>${SingleHealPoint}) /varset SingleHealPoint ${HealHighPoint}
        /if (${Debug}) /echo ${SingleHealPoint} \agLine#: ${Macro.CurLine}
    /next i
    /if (${SHCount}) /call SortArray SingleHeal SHCond 100|100 >    
    /for j 1 to ${SingleHeal.Size}
         /if (${Debug}) /echo ${j} ${SingleHeal[${j}]} ${Spell[${SingleHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration} \agLine#: ${Macro.CurLine}
         
    /next j 
    /if (${Debug}) /echo Leave FindSingleHeals \agLine#: ${Macro.CurLine}
/return    
| ----------------------------------------------------------------------------
| SUB: Assign Group heals
| ---------------------------------------------------------------------------
Sub FindGroupHeals
    /if (!${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) /return
    /if (${Debug}) /echo Enter FindGroupHeals \agLine#: ${Macro.CurLine}
    /declare i int local
    /declare j int local
    /declare GHCount int 0
    /declare HealSpell string  local
    /for i 1 to ${Heals.Size}
        /varset HealSpell ${Heals[${i}].Arg[1,|]}    
        /if (${Debug}) /echo ${HealSpell} \agLine#: ${Macro.CurLine}
        /if (!${HealSpell.Length} || ${HealSpell.Equal[null]} || ${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]}) /goto :NextGH
        /if (${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) /goto :NextGH
        /if (${Me.Class.Name.Equal[Shaman]} && ${Spell[${HealSpell}].Name.Find[Intervention]} || ${Me.Class.Name.Equal[Druid]} && ${Spell[${HealSpell}].Name.Find[Survival]}) /goto :NextGH
        /if (${Spell[${HealSpell}].TargetType.Find[group v]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && !${Select[${Heals[${i}].Arg[3,|]},MA,ME]}) {
            /varcalc GHCount ${GHCount}+1
            /varset GroupHeal[${GHCount}] ${Heals[${i}]}
            /vardata GHCond[${GHCount}] HealsCond[${i}]
            /goto :NextGH
        }
        :NextGH
    /next i
    /if (${Debug}) /echo ${GHCount} \agLine#: ${Macro.CurLine}
    /if (${GHCount}) {
        /call SortArray GroupHeal GHCond 100|100 >    
        /for j 1 to ${GroupHeal.Size}
            /if (${Debug}) /echo ${j} ${GroupHeal[${j}]} ${Spell[${GroupHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${GroupHeal[${j}].Arg[1,|]}].Duration} \agLine#: ${Macro.CurLine}
        /next j 
    }
    /if (${Debug}) /echo Leave FindGroupHeals \agLine#: ${Macro.CurLine}
/return    
| ----------------------------------------------------------------------------
| SUB: Create Timers Heals
| ----------------------------------------------------------------------------
    Sub CreateTimersHeals    
        | Declare timers for Heal duration spells
        /declare j int local
        /declare k int local
        /declare q int local
        /for j 1 to ${GroupHeal.Size}
            | Group Heal duration timers
            /declare SpellGH${j}    timer   outer   0
        /next j
        /for j 1 to ${SingleHeal.Size}
            /for k 0 to 13
                | Self and MA duration heal timers for  out of group including Pets.
                /declare Spell${j}GM${k}     timer   outer   0
                /if (${Debug}) /echo \atDEBUG Group heal Timers Spell${j}GM${k} ${Spell${j}GM${k}} \agLine#: ${Macro.CurLine}
            /next k
        /next j
       | Declare timers for Pet heals
        /for q 1 to ${SingleHeal.Size}
            /declare PetHealTimer${q} timer outer 0
        /next q
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Rez
| ----------------------------------------------------------------------------        
    Sub CreateTimersRez    
        | Declare timers for Rez duration spells
        /declare m int local
        /for m 1 to 5
            /declare BattleRezTimer${m} timer outer 0
        /next m
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Mez
| ----------------------------------------------------------------------------    
    Sub CreateTimersMez
        | Declare timers for mezzing
        /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
            /declare l int local
            /for l 1 to 30
                /declare MezTimer${l} timer outer 0
                /declare MMTimer${l} timer outer 0
            /next l
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Creat Timers Buffs
| ----------------------------------------------------------------------------
    Sub CreateTimersBuffs
        | Declare timers for Buff duration spells
        /declare o int local
        /declare p int local
        | Create buff timer for all buff in array
        /for o 1 to ${Buffs.Size}
           | Create timers for everyone in group plus 2 extra for MA buffs
            /for p 0 to 7
                /declare Buff${o}GM${p}     timer   outer   0
                /if (${Debug}) /echo \atDEBUG Buff Timers:Buff${o}GM${p} ${Buff${o}GM${p}} \agLine#: ${Macro.CurLine}
            /next p
        /next o
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers GoM
| ----------------------------------------------------------------------------        
    Sub CreateTimersGoM    
        | Declare timers for Rez duration spells
        /declare i int local
        /for i 1 to 5
            /declare GoMSpellTimer${i} timer outer 0
        /next i
    /return    
| ----------------------------------------------------------------------------
| SUB: ZCheck /call ZAxisCheck current ,Z to check, difference
| ----------------------------------------------------------------------------
    Sub ZAxisCheck(float Zcur, float Zdiff)
        | Move down if Z distance more than Zcheck due to levitation
        /if (${Debug}) /echo \atDEBUG ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} Enter. \agLine#: ${Macro.CurLine}
        /if (${Zcur}>=${Zdiff}) {
            /keypress CMD_MOVE_DOWN hold
            /delay 10 ${Math.Distance[${CampZLoc}:${Me.Z}]}<=${Zdiff}
            /keypress CMD_MOVE_DOWN
        }
        /if (${Debug}) /echo \atDEBUG ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} Exit. \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Event_PTaunt 
| ----------------------------------------------------------------------------
    Sub Event_PTaunt
        /varset PetTauntOn 1
    /return
| ----------------------------------------------------------------------------
| SUB: Event_WornOff - secondary check to rebuff
| ----------------------------------------------------------------------------
    Sub Event_WornOff(string Line, string wospell, string wotarget)
        /if (!${RebuffOn}) /return
        /if (${wotarget.Equal[${Me}]}) /return
        /if (${AggroTargetID}) /return
        /if (${Me.Class.Name.Find[bard]}) /return
        /if (${wospell.Find[promised]}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS Event_WornOff Enter ${wospell} ${wotarget} \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare WOSpellTT string local 0
        /declare WOTries int local 0
        /if (${Me.Book[${wospell}]}) {
            /varset WOSpellTT ${Spell[${Me.Book[${Me.Book[${wospell}]}].ID}].TargetType}
        } else {
            /varset WOSpellTT ${Spell[${wospell}].TargetType}
        }
        /for i 1 to ${Buffs.Size}
            /for j 1 to ${Group}
                /if (${Group.Member[${j}].CleanName.Equal[${wotarget}]} && ${Buffs[${i}].Find[${wospell}]}) {
                    /varset Buff${i}GM${j} 0
                    /echo ${wotarget} needs ${wospell} because it wore off.
                    :MakeSureCO
                    /if (${WOTries}>5) /goto :SkipWO
                    /if (${Select[${WOSpellTT},single,group]} && ${Me.Buff[${wospell}].ID})  {
                        /if (${Select[${EverQuest.Server},fippy,vulak,ragefire,lockjaw]}==0) /removebuff ${wospell}
                        | reset spell timer on caster
                        /varset Buff${i}GM0 0
                        /varcalc WOTries ${WOTries}+1
                        /if (${Me.Buff[${wospell}].ID}) {
                              /if (${DebugBuffs}) /echo Spell: ${WOSpellTT} Slot: ${Me.Buff[${wospell}].ID} Buff: ${i} GM: ${j}
                            /goto :MakeSureCO
                        }
                    }
                }
            /next j
            | If MA out of group listen for buffs wearinig off
            /if (!${Spawn[${MainAssist} ${MainAssistType} group].ID} && ${Spawn[=${MainAssist}].CleanName.Equal[${wotarget}]} && ${Buffs[${i}].Find[${wospell}]}) {
                /varset Buff${i}GM7 0
                /echo ${wotarget} needs ${wospell} because it wore off.
            }
        /next i
        :SkipWO
        /varset ReadBuffsTimer 0
        /if (${IniNextTimer}) /varset IniNextTimer 0
         /if (${DebugBuffs}) /echo \atDEBUGBUFFS Event_WornOff Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Merc state 4 = no gold membership
| ----------------------------------------------------------------------------
    Sub WriteBuffsMerc  
        /if (!${Spawn[mercenary ${Group.Member[1].ID}].ID}) /return
        /if (${WriteBuffsMercTimer}) /return
        /if (!${Redguides}) /return
        /if (${AggroTargetID}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsmerc Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Spawn[mercenary ${MyMerc}].ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        /target id ${Spawn[mercenary ${MyMerc}].ID}
        /delay 20
        /for i 1 to 15
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc ${i} ${Target.Buff[${i}]} \agLine#: ${Macro.CurLine}
            /if (${Target.Buff[${i}].Name.Length}) {
                /varset BuffList ${Target.Buff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                /if (${Debugbuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Spawn[mercenary ${MyMerc}].ID}" Buffs "${Writebufflist}"
        /delay 15
        /varset WriteBuffsMercTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsMerc Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Pet
| ----------------------------------------------------------------------------
    Sub WriteBuffsPet
        /if (!${Me.Pet.ID}) /return
        /if (${AggroTargetID}) /return        
        /if (!${Select[${Role},pettank,pullerpettank]} && ${Spawn[${MainAssist} ${MainAssistType}].ID}!=${Me.Pet.ID}) /return
        /if (${WriteBuffsPetTimer}) /return
        /if (!${Redguides}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffPet Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        /target id ${Me.Pet.ID}
        /delay 20
        /for i 1 to 50
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffPet ${i} ${Target.Buff[${i}]} \agLine#: ${Macro.CurLine}
            /if (${Me.PetBuff[${i}].Name.Length}) {
                /varset BuffList ${Me.PetBuff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                /if (${Debugbuffs}) /echo \atDEBUGBUFFS WriteBuffPet: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs "${Writebufflist}"
        /delay 15
        | Open Blocked Pet Buffs window temporarily to read blocked buffs
        /if (!${Window[BlockedPetBuffWnd].Open} && !${BPBWindowOpen}) {
            /windowstate BlockedPetBuffWnd open
            /varset BPBWindowOpen 120m
            /delay 10
        }
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 0 to ${MaxBlockedBuffs}
            /varset Blockedbuff ${Window[BlockedPetBuffWnd].Child[BW_BLOCKEDPETBUFF${k}_Button].Child[BPBuff${k}].Tooltip}
            /if (${Blockedbuff.Length}) {
                 /varset Blockedbufflist ${Blockedbufflist}|${Blockedbuff}
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedPetBuffWnd].Open}) /windowstate BlockedPetBuffWnd close
        /varset WriteBuffsPetTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffsPet Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: Clean Buffs File
| ----------------------------------------------------------------------------
    Sub CleanBuffsFile
        /if (${CleanBuffsTimer}) /return
        /declare i int local
        /declare SectionList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare SectionListCount int local ${SectionList.Count[|]}
        /if (${SectionListCount}==0) /return
        /varcalc SectionListCount ${SectionListCount}-1
        /declare SectionName string local
        /for i 1 to ${SectionListCount}
            /varset SectionName ${SectionList.Arg[${i},|]}
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CleanBuffsFile ${i} ${SectionName} ${Math.Calc[${Ini["KissAssist_Buffs.ini",${SectionName},Day]}-${Time.Day}]} ${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]} Day: ${Time.Day} Hour: ${Time.Hour} \agLine#: ${Macro.CurLine}
            /if (${Ini["KissAssist_Buffs.ini",${SectionName},Day].NotEqual[${Time.Day}]}) {
                /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
                /continue
            }
            /if (${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]}!=0) /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
        /next i
        /varset CleanBuffsTimer 10m
    /return
| ----------------------------------------------------------------------------
| SUB: AE check - cast area effect spells depending on set number of mobs
| ----------------------------------------------------------------------------
    Sub AECheck
        /if (!${AEOn}) /return
        /if (${Target.Type.Equal[corpse]}) /return
        /if (!${AggroTargetID}) /return
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Enter \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare k int local
        /declare l int local
        /declare AESpell string local
        /declare AEMobCount int local
        /declare AETarget string local
        /declare AETargetID int local
        /declare ArrayCount int local 0
        /declare AEIfSpell string local
        /declare AENotIfSpell string local
        /declare MobCountTemp int local
        /declare CheckSpawnID
        /call MobRadar ${AERadius} AECheck
        | Adjust mobcount by subtracting mobs not on xtarget
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Mobcount:${MobCount} \agLine#: ${Macro.CurLine}
        /varset MobCountTemp ${MobCount}
        /for j 1 to ${MobCount}
            /varset CheckSpawnID ${NearestSpawn[${j},npc targetable los radius ${AERadius} zradius 50 noalert 3].ID}
            /for i 1 to ${XSlotTotal}
                /if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].ID}) {
                    /if (${CheckSpawnID}==${Me.XTarget[${i}].ID}) {
                        /varcalc ArrayCount ${ArrayCount}+1
                    }
                }
            /next i
            /if (${ArrayCount}==0) {
               /varcalc MobCountTemp ${MobCountTemp}-1 
               /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck MobCountTemp:${MobCountTemp} after xtarget spawn check \agLine#: ${Macro.CurLine}
            }
            /varset ArrayCount 0
        /next j 
        /if (${MobCountTemp}<=0) /return
        /for k 1 to ${AE.Size}
            /varset AESpell ${AE[${k}].Arg[1,|]}
            /varset AEMobCount ${AE[${k}].Arg[2,|]}
            /varset AETarget ${AE[${k}].Arg[3,|]}
            /varset AEIfSpell
            /varset AENotIfSpell
            | Check if AEspell is ready to use if not skip it
            /if (${AESpell.NotEqual[burn]} && !${Me.SpellReady[${Spell[${AESpell}].RankName}]} && !${Me.AltAbilityReady[${AESpell}]} && !${Me.CombatAbilityReady[${Spell[${AESpell}].RankName}]} && !${Me.AbilityReady[${AESpell}]}) /goto :NextAE
            | Check if AEspell if an item is ready to use. if not skip it
            /if (${FindItem[=${AESpell}].ID} && !${Me.ItemReady[=${AESpell}]}) /goto :NextAE
    /if (${AEMobCount}<=${MobCountTemp}) {
        /if (${AETarget.Equal[null]} || ${AETarget.Equal[Mob]} || ${AETarget.Equal[Single]}) /varset AETargetID ${MyTargetID}
        /if (${AETarget.Equal[Me]}) /varset AETargetID ${Me.ID}
        /if (${AETarget.Equal[MA]}) /varset AETargetID ${Spawn[=${MainAssist}].ID}
        /if (${AETarget.Equal[Pet]}) /varset AETargetID ${Me.Pet.ID}
        /if (${AESpell.Equal[burn]} && !${BurnActive}) {
            /echo AE-> ${MobCountTemp} Mobs: Activating BURN
            /varset BurnActive 1
            /call Event_Burn
            /return
        }
        /if (${Spawn[npc id ${AETargetID}].ID} && ${SpawnCount[npc xtarhater loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} radius ${Spell[${AESpell}].AERange}]} < ${SpawnCount[npc loc ${Spawn[id ${AETargetID}].X} ${Spawn[id ${AETargetID}].Y} radius ${Spell[${AESpell}].AERange}]}) {
            /if (${AETarget.NotEqual[Single]}) /echo AE-> Casting ${Spell[${AESpell}].Name} now would aggro more mobs than we have on xtarget
            /goto :NextAE
        }
        /if (${AE[${k}].Arg[3,|].Length} && ${AE[${k}].Arg[4,|].Length} && ${AE[${k}].Arg[3,|].Equal[if]}) {
            /varset AEIfSpell ${AE[${k}].Arg[4,|]}
            /if (${AE[${k}].Arg[5,|].Equal[mob]}) {
            /varset AETargetID ${MyTargetID}
            /if (${Int[${Target.Buff[${AEIfSpell}].ID}]}>0)
            /echo AE-> ${MobCountTemp} Mobs: ${AEIfSpell} is active on Target trying to cast ${AESpell}
            /goto :CastAE
            } else { 
                /if (${Me.Buff[${Spell[${AEIfSpell}].RankName}].ID} || ${Me.Song[${Spell[${AEIfSpell}].RankName}].ID} || ${Me.ActiveDisc.Name.Find[${AEIfSpell}]}) {
                    /echo AE-> ${MobCountTemp} Mobs: ${AEIfSpell} is active trying to cast ${AESpell}
                    /goto :CastAE
                } else {
                    /goto :NextAE
                }
            }
        }
        /if (${AE[${k}].Arg[3,|].Length} && ${AE[${k}].Arg[4,|].Length} && ${AE[${k}].Arg[3,|].Equal[notif]}) {
             /varset AENotIfSpell ${AE[${k}].Arg[4,|]}
             /if (${AE[${k}].Arg[5,|].Equal[mob]}) {
                 /varset AETargetID ${MyTargetID}
              /if (${Int[${Target.Buff[${AENotIfSpell}].ID}]}==0)
              /echo AE-> ${MobCountTemp} Mobs: ${AENotIfSpell} is Not active on Target trying to cast ${AESpell}
              /goto :CastAE
            } else { 
            /if (!${Me.Buff[${Spell[${AENotIfSpell}].RankName}].ID} && !${Me.Song[${Spell[${AENotIfSpell}].RankName}].ID} && !${Me.ActiveDisc.Name.Find[${AENotIfSpell}]}) {
                /echo AE-> ${MobCountTemp} Mobs: ${AENotIfSpell} is NOT active trying to cast ${AESpell}
                    /goto :CastAE
                } else {
                    /goto :NextAE
                }
            }
        }
        :CastAE
        /if (${MobCountTemp}==1 && ${AETarget.Equal[Single]}) {
            /call CastWhat "${AESpell}" ${AETargetID} AoE
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo AE-> ${AESpell} on Single target  >> ${Spawn[${AETargetID}].CleanName} <<
            }
            /goto :NextAE
        } else /if (${MobCountTemp}>=2 && ${AETarget.Equal[Single]}) {
            /goto :NextAE
        } else {
            /call CastWhat "${AESpell}" ${AETargetID} AoE
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo AE-> ${MobCountTemp} Mobs: Casting AE ${AESpell}
            }
        } 
    }
            :NextAE
        /next k
        /if (${DebugCombat}) /echo \atDEBUGCOMBAT AECheck Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: WriteDebuffs
| ----------------------------------------------------------------------------
    Sub WriteDebuffs
    /if (${DebugHeal}) /echo \amDEBUGHEALS WriteDebuffs Enter \agLine#: ${Macro.CurLine}
        /declare DebuffList string local 
        /declare IAmDuffed int local ${Math.Calc[${Int[${Me.Poisoned.ID}]}+${Int[${Me.Diseased.ID}]}+${Int[${Me.Cursed.ID}]}+${Int[${Me.Corrupted.ID}]}]}
        /if (${IAmDuffed} && !${NeedCuring}) {
            /varset NeedCuring 1
            /varset DebuffList ${IAmDuffed}|${Int[${Me.Poisoned.ID}]}|${Int[${Me.Diseased.ID}]}|${Int[${Me.Cursed.ID}]}|${Int[${Me.Corrupted.ID}]}
            /ini "KissAssist_Buffs.ini" "${Me.ID}" Debuffs "${DebuffList}"
            /if (${DebugHeal}) {
		/echo \amDEBUGHEALS WriteDebuffs Writing debuffs to ini file \agLine#: ${Macro.CurLine}
	    }
        }
        /if (!${IAmDuffed} && ${NeedCuring}) {
            /varset NeedCuring 0
            /varset DebuffList 
            /ini "KissAssist_Buffs.ini" "${Me.ID}" Debuffs "${DebuffList}"
            /if (${DebugHeal}) {
		/echo \amDEBUGHEALS WriteDebuffs Clearing debuffs from ini file \agLine#: ${Macro.CurLine}
	    }
        }
        /if (${DebugHeal}) /echo \amDEBUGHEALS WriteDebuffs Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: CheckCures
| ----------------------------------------------------------------------------
    Sub CheckCures
        /if (!${CuresOn}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${Medding} && ${MedCombat}) /return
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures Enter  \agLine#: ${Macro.CurLine}
        /declare i int local
        /declare j int local
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        /declare IniDebuffCount string local 0
        /declare IniDebuffList string local
        /declare CuretoCast string local 
        /declare CTID int local
        /for i 1 to ${Cures.Size}
            /if (!${Cures[${i}].Length}) /goto :skipi
            /for j 1 to ${IniIDCount}
                /varset CuretoCast
                /varset IniDebuffCount ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${j},|]},"Debuffs"]} 
                /varset CTID ${Spawn[${IniIDList.Arg[${j},|]}].ID}
                /if (${IniDebuffCount.Arg[1,|]} && ${Spawn[${IniIDList.Arg[${j},|]}].ID} && ${Spawn[${IniIDList.Arg[${j},|]}].Distance}<100) {
                    /if (${IniDebuffCount.Arg[1,|]} && ${Cures[${i}].Arg[2,|].Length}==0) {
                        /varset CuretoCast ${Cures[${i}]}
                    } else /if (${IniDebuffCount.Arg[2,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[poison]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
                    } else /if (${IniDebuffCount.Arg[3,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[disease]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}
                    } else /if (${IniDebuffCount.Arg[4,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[curse]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}    
                    } else /if (${IniDebuffCount.Arg[5,|]}>0 && ${Cures[${i}].Arg[2,|].Equal[corruption]}) {
                        /varset CuretoCast ${Cures[${i}].Arg[1,|]}    
                    }  
                    | Check cures for group component since they don't seem to work on out of group toons
                    /if (${Spell[${CuretoCast}].TargetType.Find[group v]} && !${Spawn[id ${IniIDList.Arg[${j},|]} group].ID}) {
                        /if (${DebugHeal} && !${CureTimer${CTID}${i}}) /echo CURING: >> ${Spawn[${IniIDList.Arg[${j},|]}].CleanName} << is not in your group and >> ${CuretoCast} << is a group spell.
                        /if (!${Defined[CureTimer${CTID}${i}]}) {
                            /declare CureTimer${CTID}${i} timer outer 30s
                            /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures /echo declare CureTimer${CTID}${i} \agLine#: ${Macro.CurLine}
                        } else /if (!${CureTimer${CTID}${i}}) {
                            /varset CureTimer${CTID}${i} 30s
                            /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures /echo varset CureTimer${CTID}${i} \agLine#: ${Macro.CurLine}
                        }  
                        /goto :skipj
                    }
                    /if (${Me.SpellReady[${Spell[${CuretoCast}].RankName}]} || ${Me.AltAbilityReady[${CuretoCast}]} || ${Me.CombatAbilityReady[${Spell[${CuretoCast}].RankName}]} || ${Me.AbilityReady[${CuretoCast}]}) {
                        /call CastWhat "${CuretoCast}" ${IniIDList.Arg[${j},|]} Cure
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast ${IRCOn} ${EQBCOn} o "CURING: >> ${Spawn[${IniIDList.Arg[${j},|]}].CleanName} << with ${CuretoCast}"
                        /delay 10
                    }
                }
	    :skipj
            /next j
	:skipi
        /next i
        /if (${DebugHeal}) /echo \amDEBUGHEALS CheckCures Leave \agLine#: ${Macro.CurLine}
    /return
| ----------------------------------------------------------------------------
| SUB: WaitSubs - bunch of crap to call while medding standing around etc
| ----------------------------------------------------------------------------
    Sub WaitSubs
        /if (!${Me.Mount.ID} && !${Me.Sitting}) {
		/echo going to sit 4
		/sit
	}
        /if (${HealsOn}) /call CheckHealth
        /call WriteDebuffs
        /if (${CuresOn}) /call CheckCures
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) /call DoMezStuff
        }
        /call WriteBuffs
        /if (${AutoRezOn}) /call RezCheck
        /call CanIDoStuff
        /call CastMana
        /if (${PetOn}) /call DoPetStuff
        /if (${BuffsOn}) /call CheckBuffs
        /if (${MercOn}) /call MercsDoWhat
    /return
| ----------------------------------------------------------------------------
| SUB: BroadCast - Handles echos and messages in mq2irc and mq2eqbc
| ----------------------------------------------------------------------------
    Sub BroadCast(doirc, doeqbc, eqbcolor, message)
        /if (${eqbcolor.Equal[null]}) /varset eqbcolor w

        /if (${doeqbc}) {
		/if (${Bool[${Plugin[MQ2EQBC]}]}) {
			/if (${EQBC.Connected}) /${EQBCSay} [+${eqbcolor}+] [${Time}] ${message} [+x+]
		}
	}
        /if (${Bool[${Plugin[MQ2IRC]}]} && ${doirc}) /i say ${message}
        /echo ${message}
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire ${Window[FellowshipWnd].Child[FP_CampPage].Child[FP_CampsiteViewer].Text}
| ----------------------------------------------------------------------------
    Sub Campfire
        /if (!${CampfireOn}) /return
        /if (${CampfireTimer}) /return
        /if (${Me.Fellowship.CampfireZone.ID} && (${Me.Fellowship.CampfireZone.ID}==${Zone.ID} || ${Me.Fellowship.CampfireZone.Name.Find[guild hall]})) /return
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) /return
        /if (${AggroTargetID}) /return
        /if (${CombatStart}) /return
        /declare FellowCount int local 0
        /declare i int local
        /declare j int local
        /for i 1 to ${SpawnCount[pc radius 50]}
            /for j 1 to ${Me.Fellowship.Members}
                /if (${NearestSpawn[${i},PC radius 50].CleanName.Equal[${Me.Fellowship.Member[${j}]}]}) /varcalc FellowCount ${FellowCount}+1
            /next j
        /next i
        /if (${FellowCount}>=3) {
            /call Bind_Campfire
        } else {
            /echo Not enough fellowship members trying again in 5 minutes
            /varset CampfireTimer 5m
        }
        /doevents TooSteep
    /return
| ----------------------------------------------------------------------------
| SUB: NamedWatch
| ----------------------------------------------------------------------------
    Sub NamedWatch
    /if (!${BurnAllNamed}) /return
    /if (${Spawn[${MyTargetID}].Named}) {
        /popup *** Mob:(${Target.CleanName}) is a NAMED!
        /echo *** Mob:(${Target.CleanName}) is a NAMED!
        /call Event_Burn
        /varset NamedCheck 1 
        /if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
    } else {
        /declare i int local
        /for i 1 to 25        
            /if (${MobsToBurn.Find[null]}) /return
            /if (${MobsToBurn.Arg[${i},,].Length} && !${MobsToBurn.Find[null]} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${MyTargetID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Target.CleanName}]}) {
                /call Event_Burn
                /popup *** Mob:(${Target.CleanName}) is a NAMED!
                /echo *** Mob:(${Target.CleanName}) is a NAMED!    
                /if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
                /varset NamedCheck 1 
            }
        /next i
    }
    /return
| ----------------------------------------------------------------------------
| SUB: Scan ini file for errors in spelling or missing items
| ----------------------------------------------------------------------------
    Sub ScanIni
    /declare i int local 1
    /declare j int local 1 
    /declare Section1 string local Buffs
    /declare Section2 string local DPS
    /declare Section3 string local Burn
    /declare Section4 string local Heals
    /declare Section5 string local AE
    /declare Section6 string local Cures
    /declare Section7 string local Pet
    /declare Section8 string local PetBuffs
    /declare Section9 string local GoM
    /declare CountEnrties int local 0
    /declare CountErrors int local 0
    /declare iniKey string local

    /for j 1 to 9
        /echo ---------------->> Scanning ${Section${j}} <<----------------
        /varset CountEnrties 0
        /varset CountErrors 0
        /for i 1 to 20            
            /varset iniKey ${Ini["${IniFileName}",${Section${j}},${Section${j}}${i}]}
            /if (${Section${j}.Equal[Pet]} && ${i}==1) /varset iniKey ${Ini["${IniFileName}",${Section${j}},PetSpell]}
            /if (${Section${j}.Equal[Pet]} && ${i}==2) /varset iniKey ${Ini["${IniFileName}",${Section${j}},PetShrinkSpell]}
            /if (${Section${j}.Equal[PetBuffs]}) /varset iniKey ${Ini["${IniFileName}",Pet,Petbuffs${i}]}
            /if (${Section${j}.Equal[GoM]}) /varset iniKey ${Ini["${IniFileName}",GoM,GomSpell${i}]}                                    
            /if (${iniKey.NotEqual[null]}) {
                /if (${Debug}) /echo ScanIni: ${Section${j}}${i}=${iniKey}  \agLine#: ${Macro.CurLine}
                | find out if there is a Rank and fix spell name.
                /call Spell_Rk_Check "${iniKey}"
                /varset iniKey ${Macro.Return}
                /if (${Debug}) /echo ScanIni: ${iniKey} after return  \agLine#: ${Macro.CurLine}
                /if (${iniKey.Find[|]}) /varset iniKey ${iniKey.Arg[1,|]}
                /if (${Section${j}.Equal[GoM]} && ${iniKey.Find[Gift Of Mana]}) /goto :SkipInientry
                /if (${Section${j}.Equal[AE]} && ${iniKey.Find[Burn]}) /goto :SkipInientry
                /if (!${Me.Book[${iniKey}]} && !${Me.CombatAbility[${iniKey}]} && !${Me.AltAbility[${iniKey}]} && !${FindItem[=${iniKey}].ID} && ${iniKey.NotEqual[banestrike]} && !${Me.Ability[${iniKey}]}) {
                    /echo ...ERROR: ${Section${j}}${i}=${iniKey} unable to find as a Spell, AA, Item or Combat Ability
                    /varcalc CountErrors ${CountErrors}+1
                }
                /varcalc CountEnrties ${CountEnrties}+1
            }
            :SkipInientry
            /if (!${CountEnrties} && ${i}==20) {
                /echo -- Nothing defined in this section
            }
            /if (!${CountErrors} && ${CountEnrties} && ${i}==20) {
                /echo -- No Spelling Errors or Missing Items Detected
            }       
        /next i
    /next j
    /return
| ----------------------------------------------------------------------------
| SUB: IniWrite - quick ini entry for spells,  aas, discs, items
| ----------------------------------------------------------------------------
    Sub Bind_IniWrite(IWSection, IWE1, IWE2, IWE3, IWE4, IWE5, IWE6)
    /if (${Debug}) /echo Bind_IniWrite: Enter ${iwMessage} \agLine#: ${Macro.CurLine}
    /declare keyNum int local 0
    /declare IWPercent int local 100
    /declare IWSlot int local 1
    /declare IWType string local ${IWE1}
    /declare IWTypeSingle string local
    /declare IWArray int local ${${IWSection}.Size}
    /declare IWEmptySlot string local 0
    /declare IWEntry string local
    /declare i int local
    /declare j int local
    /declare k int local
    | Determine if single type 
    /if (${Select[${IWType},aa,disc,item,spell,clear]}) {
        | Set Item
        /if (${IWType.Equal[item]}) {
            /if (!${Cursor.ID}) {
                /echo ..SET${IWSection}: You need to put the item on your cursor.
                /return
            }
            /varset IWTypeSingle ${Cursor.Name}
            /echo ${IWTypeSingle}
        }
        | Set Spell
        /if (${IWType.Equal[spell]}) {
            /if (!${Me.Gem[${IWE2}].Name.Length}) {
                /echo ..SET${IWSection}: You need to mem a spell
                /return
            }
            /varset IWTypeSingle ${Me.Gem[${IWE2}].Name}
         }
        | Set AA
        /if (${IWType.Equal[aa]}) {
            /if (!${Me.AltAbility[${IWE2}]}) {
                /echo ..SET${IWSection}: You don't have that AA
                /return
            }
            /varset IWTypeSingle ${Me.AltAbility[${IWE2}].Name}
        }
        | Set Disc/Combat Ability
        /if (${IWType.Equal[disc]}) {
            /if (!${Select[${IWE2},1,2,3,4,5,6,7,8]}) {
                /echo ..SET${IWSection}: Disc # must be a Combat Abilty Button 1-8 
                /return
            }
            /if (!${Me.CombatAbility[${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}]}) {
                /echo ..SET${IWSection}: You don't have that Disc or Combat Ability button ${IWE2} is empty.
                /return
            }
            /varset IWTypeSingle ${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}
        }
        | Final Catchall for error control
        /if (!${IWTypeSingle.Length}) {
            /echo ..SET${IWSection}: ${IWType} parameter is blank. Please provide a ${IWType}
            /return
        }
        | Find empty slot & check if entry exists
        /echo ..SET${IWSection}: Looking of for spot to write ${IWTypeSingle}
        /for k 1 to ${IWArray}
            /varset IWEntry ${Ini[${IniFileName},${IWSection},${IWSection}${k}]}
            /if (${IWSection.Equal[DPS]}) /varset IWPercent 90
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            /if (${Debug}) /echo ${${IWSection}[${k}].Length} \agLine#: ${Macro.CurLine}
            /if (${IWEntry.Find[${IWTypeSingle}]}) {
                /echo ..SET${IWSection}: Duplicate entry ${IWSection}${k}=${IWTypeSingle} skipping.
                /return
            }
            /if (${IWEntry.Equal[null]} && ${IWEmptySlot}==0) {
                /varset IWEmptySlot ${k}
            }
            /if (${k}==${IWArray} && !${IWEmptySlot}) /varset IWEmptySlot ${k}
        /next k
        /if (${IWEmptySlot}==${IWArray}) {
            /echo ..SET${IWSection}: No empty slots in ${IWSection} to write
            /return
        }
        /if (${Select[${IWSection},DPS,Heals]}) {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}|${IWPercent}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}|${IWPercent}
        } else {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}
        }
        /return
    }    
    /echo ..SET${IWSection}: This command will write over current ${IWSection} settings 
    /for i 1 to ${IWArray}
        /varset keyNum ${i}
        /if (${Me.Gem[${IWE${i}}].Name.Length} && ${i}<7) {
            /if (${IWSection.Equal[DPS]}) /varcalc IWPercent ${IWPercent}-5
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            /if (${Select[${IWSection},DPS,Heals]}) {
                /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}|${IWPercent}"
                /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}|${IWPercent}
            }
            /if (${Select[${IWSection},Buffs]}) {
                /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}"
                /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}
            }
            /varcalc IWSlot ${IWSlot}+1
            /delay 10
        }
    /next i
    /return
|-----------------------------------------------------------------------------
| SUB: Campfire back to camp
| ----------------------------------------------------------------------------
    Sub CampfireBack
        /if (!${ClickBacktoCamp}) /return
        /if (${CampfireClickTimer}) /return
        /if (${Me.Hovering}) /return
        /varset CampfireClickTimer 1m
        | Am I Dead?
        /if (${Me.Buff[Revival Sickness].ID} && ${CampZone} != ${Zone.ID}) /varset IAmDead 1
        /if (${IAmDead}) {
            | Does Campfire Exist?
            /if (!${Me.Fellowship.CampfireZone.ID}) {
                /echo There is no campfire up.
                /return
            }
            | Am I & the campfire in the same zone?
            /if (${Me.Fellowship.CampfireZone.ID}==${Zone.ID}) {
                /echo I'm back in the same zone as my campfire. 
                /varset IAmDead 0
                /return
            }
            /if (${FindItem[Fellowship Registration Insignia].TimerReady} == 0) {
                /echo Time to get back to work. Clicking Fellowship Insignia in 30 seconds.
                | Delay for rest state to kick in
                /delay 30s
                /squelch /nomodkey /itemnotify "Fellowship Registration Insignia" rightmouseup
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Debug All
| ----------------------------------------------------------------------------
    Sub Bind_DebugAll
        /if (${Everquest.CurrentUI.NotEqual[Default]}) {
            /echo You are using a Custom UI. Please switch to Default UI before Posting.
        }
        /if (!${DebugAllOn}) {
            /varset DebugAllOn 1
            /echo \atDEBUG ALL On
        } else {
            /varset DebugAllOn 0
            /echo \atDEBUG ALL Off
        }
        /varset Debug ${DebugAllOn}
        /varset DebugBuffs ${DebugAllOn}
        /varset DebugCombat ${DebugAllOn}
        /varset DebugHeal ${DebugAllOn}
        /varset DebugMez ${DebugAllOn}
        /varset DebugMove ${DebugAllOn}
        /varset DebugPet  ${DebugAllOn}
        /varset DebugPull ${DebugAllOn}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd1
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateAdd1
        /varset PetActiveState  0
        /varset PetSuspendState 1
        /varset PetTotCount     1
        /if (${DebugPet}) /echo PetSusStateAdd1 triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd2
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateAdd2
        /varset PetActiveState  1
        /varset PetSuspendState 1
        /varset PetTotCount     2
        /if (${DebugPet}) /echo PetSusStateAdd2 triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateSub
| ----------------------------------------------------------------------------    
    Sub Event_PetSusStateSub
        /varset PetActiveState  1    
        /varset PetSuspendState 0
        /varset PetTotCount     1
        /if (${DebugPet}) /echo PetSusStateSub triggered. \agLine#: ${Macro.CurLine}
        /if (${DebugPet}) /echo PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState}) \agLine#: ${Macro.CurLine}
    /return   
|-----------------------------------------------------------------------------  
| SUB: Back Off and stop melee  
| ----------------------------------------------------------------------------      
    Sub Bind_BackOff  
        /if (${DPSPaused}) {  
            /if (${DPSPaused}==2 && ${UseMQ2Melee}) /squelch /melee on
            /varset DPSPaused 0  
            /echo Resetting. No Longer Backing off.  
        } else {  
            /varset DPSPaused 1  
            /varset CombatStart 0  
            /if (${UseMQ2Melee}) /squelch /melee off
            /if (${Melee.Combat}) {  
                /squelch /attack off  
                /if (${Stick.Active})  /stick off 
            }  
            /call CombatReset  
            /varset DPSPaused 2 
            /echo Backing off - All Combat has been reset.
        }  
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {  
            /call DoWeMove Bind_BackOff
        }  
        /doevents flush BackOff  
    /return 
| -------------------------------------------------------------------------------------
| SUB: Event PetToysPlease 
| -------------------------------------------------------------------------------------    
    Sub Event_PetToysPlease(Message,string MTPet)
        /if (!${MTPet.Length}) /return
        /if (${MTPet.Find[null]}) /return
        /if (${Spawn[${MTPet}].Type.NotEqual[Pet]} && ${MTPet.NotEqual[group]}) /return
        /declare PTPPetID int local
        /declare GMemID int local
        /declare GMemShortName string local
        /declare GMemPetName string local
        /declare i int local 0
        /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: Enter \agLine#: ${Macro.CurLine}
        | If group command give all pets in group toys
        /if (${MTPet.Find[GROUP]}) {
            /echo I am giving pet toys to every Pet in Group except mine.
            | Start at 1 my pet doesn't need toys
            /for i 1 to ${Group}
            /varset GMemID ${Group.Member[${i}].ID};
            /varset PTPPetID ${Group.Member[${i}].Pet.ID}
            /varset GMemShortName ${Group.Member[${i}].Class.ShortName} 
            /varset GMemPetName ${Group.Member[${i}].Pet.CleanName}
            /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: ${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]} \agLine#: ${Macro.CurLine}
            /if (${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}) {
                /if (${PetToysOn}) /call pettoys ${GMemPetName}
            }
            /next i
        } else {
            | Individual Pet.
            /if (${PetToysOn}) {
                /echo Giving pet toys to (${MTPet}).
                /call pettoys ${MTPet}
            }
        }
        /if (${DebugPet}) /echo \atDEBUGPET PetToysPlease: Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Add stuff to alert list  
| -------------------------------------------------------------------------------------      
    Sub AlertAddToList(int whatlist, MvarList)
        /if (${Debug}) /echo \atDEBUG AlertAddToList List:${whatlist} Mlist: ${MvarList} \agLine#: ${Macro.CurLine}
        /declare k int local
        | Clear ignore mobs alert from list before assigning from ini list
         /squelch /alert clear ${whatlist}
        /if (${MvarList.Length} && !${MvarList.Find[null]}) {
            /for k 1 to 25
                /if (${MvarList.Arg[${k},,].Length} && !${MvarList.Find[null]} && ${Debug}) /echo \atDEBUG ADD ${MvarList.Arg[${k},,]} to ${MvarList}
                /if (${MvarList.Arg[${k},,].Length}) {
                    /squelch /alert add ${whatlist} "=${MvarList.Arg[${k},,]}"
                    /if (${Debug}) /echo \atDEBUG AlertAddToList Add ${MvarList.Arg[${k},,]} to Alert List ${whatlist} \agLine#: ${Macro.CurLine}
                }
            /next k
        }
        /if (${Debug}) /echo \atDEBUG AlertAddToList Leave \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mount
| -------------------------------------------------------------------------------------      
    Sub CastMount
	/if (${Zone.Indoor}) /return
        /if (${Me.Mount.ID}) /return
        /if (!${MountOn}) /return
        /if (${Me.Invis}) /return
        /if (${HealsOn} && ${AggroTargetID}) /return
        /declare i int local
        /for i 1 to ${Buffs.Size}
        | Cast mount
        /if (${Buffs[${i}].Arg[2,|].Equal[Mount]} && !${Buffs[${i}].Find[0]} && !${Me.Mount.ID} && !${Attacking} && ${MountOn} && !${Me.FeetWet}) {
            /if (${DebugBuffs}) /echo \atDEBUGBUFFS CheckBuffs Mount \agLine#: ${Macro.CurLine}
            /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} CastMount
            /delay 1s
            /if (${Macro.Return.Equal[CAST_OUTDOORS]}) /varset MountOn 0
            /call CheckCasting 80
        }
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mana
| -------------------------------------------------------------------------------------      
    Sub CastMana
        /if (${Me.Invis}) /return
        /declare i int local
        /for i 1 to ${Buffs.Size}    
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) /call DoMezStuff
        }
        /if (${HealsOn}) /call CheckHealth
        | Check and Cast mana type spells/aas/items - Canni/Paragon/Harvest - prevent toon from using before rez after zoning for 2 min
        /if (!${ConditionsOn} || !${BuffsCOn} || ${If[${BuffsCond[${i}]},1,0]}) {
            /if (${Buffs[${i}].Arg[2,|].Equal[Mana]} && !${Me.Buff[Revival Sickness].ID} && !${JustZoned}) {
                /if (${Buffs[${i}].Arg[1,|].Equal[Dichotomic Psalm]} && (${IAmABard}|| ${Me.CurrentEndurance}<6600)) /goto SkipMe
                /if (${Me.PctMana}<=${Buffs[${i}].Arg[3,|]} && ${Me.PctHPs}>${Buffs[${i}].Arg[4,|]}) {
                    /if (${Cursor.ID}) /call CheckCursor
                    /if (${DebugBuffs}) /echo \atDEBUGBUFFS Canni/Paragon/Harvest \agLine#: ${Macro.CurLine}
                        /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} Buffs
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) /echo Casting >> ${Buffs[${i}].Arg[1,|]} << for mana
                }
                :SkipMe
            }
        }
        /if (${Buffs[${i}].Arg[2,|].Equal[Managroup]} && (!${Medding} || (!${MedCombat} && ${Medding}))) /call RegenOther "${Buffs[${i}].Arg[1,|]}" Mana ${Buffs[${i}].Arg[3,|]} 0
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: You Hit DPS Meter
| -------------------------------------------------------------------------------------      
    Sub Event_YouHit(Line, YHMob, YHDamage, string YHSpell)
        /declare l_YHSpell string local 
	/if (${Defined[YHSpell]}) {
		/varset l_YHSpell ${YHSpell}
	}
        /if (!${DPSMeter}) {
            /doevents YouHit flush
            /return
        }
        /if (!${Defined[DPSTimeStart${MyTargetID}]}) {
            /declare DPSTimeStart${MyTargetID} int outer ${Time.SecondsSinceMidnight}
            /varset DPSTarget ${Target.ID}
        }
        /declare DPSType string local
        /declare DPSTime int local
        /varset DPSTime ${Math.Calc[${Time.SecondsSinceMidnight}-${DPSTimeStart${MyTargetID}}]}
	|/echo [${Time}] Setting DPSTime to ${DPSTime}
        /if (${l_YHSpell.Length}==0) {
            /if (${Line.Find[backstab]}) /varset DPSType Backstab        
            /if (${Line.Find[bash]}) /varset DPSType Bash
            /if (${Line.Find[bite]}) /varset DPSType Bite
            /if (${Line.Find[claw]}) /varset DPSType Claw
            /if (${Line.Find[crush]}) /varset DPSType Crush
            /if (${Line.Find[frenz]}) /varset DPSType Frenzy
            /if (${Line.Find[kick]}) /varset DPSType Kick
            /if (${Line.Find[maul]}) /varset DPSType Maul
            /if (${Line.Find[non-melee]}) /varset DPSType Non-melee
            /if (${Line.Find[pierce]}) /varset DPSType Pierce
            /if (${Line.Find[punch]}) /varset DPSType Punch
            /if (${Line.Find[slash]}) /varset DPSType Slash
            /if (${Line.Find[slam]}) /varset DPSType Slam
            /if (${Line.Find[slice]}) /varset DPSType Slice        
            /if (${Line.Find[sting]}) /varset DPSType Sting
        }
        /if (${l_YHSpell.Length}>=1) /varset DPSType Spell
        /if (${Line.Find[${Me.Pet.CleanName}]})  /varset DPSType Pet
        /if (${Line.Find[${Me}`s pet]})  /varset DPSType Pet
        /if (${Line.Find[${Me}`s warder]})  /varset DPSType Pet
 
        /varcalc DPSCounter ${DPSCounter}+1
        /if ((${Line.Find[${Me.Pet.CleanName}]} || ${Line.Find[${Me}`s pet]} ||  ${Line.Find[${Me}`s warder]}) && ${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0) /varcalc DPSPetTotal ${DPSPetTotal}+${YHDamage}
        /if (${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0 && ${DPSType.NotEqual[pet]}) /varcalc DPSTotal ${DPSTotal}+${YHDamage}
        | Return to avoid divide by 0 errors in calculations
        /if (${DPSTime}<=0 || !${DPSTarget}) /return
        /if (${DPSSpam} && ${Select[${YHMob},${Me},${Me.Pet.CleanName}]}==0) /echo Mob/ID: ${YHMob}/${DPSTarget} -  Type: ${DPSType}/${YHDamage} - Total Damage: ${DPSTotal} - Time: ${DPSTime}s - DPS: ${Math.Calc[${DPSTotal}/${DPSTime}]}
        /varset DPSLastTime ${DPSTime}
    /return
| -------------------------------------------------------------------------------------
| SUB: Comma Me Bro - CommaNation Domination
| ------------------------------------ -------------------------------------------------           
    Sub CommaMeBro(string cmbnumber)
        /declare CommaNator string local 
        | Strip out any decimal points 
        /varset cmbnumber ${cmbnumber.Arg[1,.]}
        /if (${cmbnumber.Length}<=3 ) /varset CommaNator ${cmbnumber}
        /if (${cmbnumber.Length}>3 && ${cmbnumber.Length}<=6) /varset CommaNator  ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-3]}]},${cmbnumber.Right[3]}
        /if (${cmbnumber.Length}>6  && ${cmbnumber.Length}<=9) /varset CommaNator ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-6]}]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-5]},3]},${cmbnumber.Right[3]}
        /if (${cmbnumber.Length}>9) /varset CommaNator ${cmbnumber.Left[${Math.Calc[${cmbnumber.Length}-9]}]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-8]},3]},${cmbnumber.Mid[${Math.Calc[${cmbnumber.Length}-5]},3]},${cmbnumber.Right[3]}
    /return ${CommaNator}
| -------------------------------------------------------------------------------------
| SUB: Event_Timer 
| ------------------------------------ -------------------------------------------------           
    Sub Event_Timer(Timer, OriginalValue)
       /if (${Select[${Timer},TributeTimer,AggroOffTimer,TellTimer]}==0) /return
       /if (${Timer.Equal[TributeTimer]}) {
          /if (${UseTribute} && ${Me.TributeActive}) {
             /if (!${AggroTargetID} || (${Target.ID} && !${Target.Named})) {
                /squelch /tribute personal off
             } else {
                /if (${Target.ID} && ${Target.Named}) /varset ${Timer} 580s
             }      
          }
       }
       /if (${Timer.Equal[AggroOffTimer]}) {
          /if (${Me.Feigning}) {
		/echo stand feign2
		/stand
	  }
          /if (${Me.Invis}) /makemevisible
       }
       /doevents flush Timer
    /return
| -------------------------------------------------------------------------------------
| SUB: Spell_Rk_Check
| ------------------------------------ -------------------------------------------------           
    Sub Spell_Rk_Check(Rk_Check_What)
        /declare DebugRk                int         local 0
        /declare rkCheck                string      local null
        /declare rkCheck1               string      local 
        /declare rkdCheck               string      local
        /declare rkTemp                 string      ${Rk_Check_What.Arg[1,|]}
        /declare rkdTemp                string      ${Rk_Check_What.Arg[3,|]}
        |/varset DebugRk 1
        /if (${DebugRk}) /echo \atDEBUG Spell_Rk_Checks: Enter \agLine#: ${Macro.CurLine}
        /if (${Rk_Check_What.Left[1].Equal[0]} || ${Int[${Rk_Check_What.Left[1]}]}>0) /return ${Rk_Check_What}
        | Check for Rk. in spell name and Remove it.   
        /if (${rkTemp.Find[ Rk.]}) {
            /varset rkTemp ${rkTemp.Left[${Math.Calc[${rkTemp.Find[ Rk.]}-1]}]} 
        }
        /if (${Int[${Me.Book[${rkTemp}]}]}==0 && ${Int[${Me.Book[${Spell[${rkTemp}].RankName}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}==0 && ${Int[${Me.CombatAbility[${Spell[${rkTemp}].RankName}]}]}==0) /return ${Rk_Check_What}
        /if (${DebugRk}) /echo \atDEBUGSpell_Rk_Checks: 1 rkCheck: "${rkCheck}" rkTemp: "${rkTemp}" rkdCheck: "${rkdCheck}" rkdTemp: "${rkdTemp}"  \agLine#: ${Macro.CurLine}
        | If this is NOT an Alt Ability then it must be a spell.
        /if (${Int[${Me.AltAbility[${rkTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
           /if (${DebugRk}) /echo 1a. well we think ${rkTemp} is an AA
           /varset rkCheck ${rkTemp}
        } else {
           /if (${DebugRk}) /echo 1b. well ${rkTemp} is not an AA
           /varset rkCheck ${Spell[${rkTemp}].RankName}
        }
        | check for null
        /if (${DebugRk}) /echo \atDEBUG Spell_Rk_Checks: 2 rkCheck: ${rkCheck} rkTemp: ${rkTemp} Rk_Check_What: ${Rk_Check_What} \agLine#: ${Macro.CurLine}
        | must NOT be null so lets fix Rk_Check_What.
        /if (${rkCheck.NotEqual[${rkTemp}]}) {
            /if (${Rk_Check_What.Find[|]}>0) {
                /varset rkCheck1 ${rkCheck}${Rk_Check_What.Right[-${Math.Calc[${Rk_Check_What.Find[|]}-1]}]} 
                /varset rkCheck ${rkCheck1}
            }
        } else {
            /varset rkCheck ${Rk_Check_What}
        }
        /if (${Rk_Check_What.Arg[2,|].Equal[dual]}) {
           /if (${rkdTemp.Find[ Rk.]}) {
               /varset rkdTemp ${rkdTemp.Left[${Math.Calc[${rkdTemp.Find[ Rk.]}-1]}]} 
           }
           /if (${Int[${Me.AltAbility[${rkdTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
               /varset rkdCheck ${Spell[${rkdTemp}].RankName}
           } else {
               /if (${Me.Subscription.NotEqual[gold]}) {
                   /varset rkdCheck ${rkdTemp}
               } else {
                   /varset rkdCheck ${Spell[${rkdTemp}].RankName}
               }
           }
           /if (${DebugRk}) /echo \atDEBUG Spell_Rk_Checks: 3 rkdCheck: ${rkdCheck} rkdTemp: ${rkdTemp} Rk_Check_What: ${Rk_Check_What} \agLine#: ${Macro.CurLine}
           /varset rkCheck ${rkCheck.Arg[1,|]}|dual|${rkdCheck}
        }
        /if (${DebugRk}) /echo \atDEBUG Spell_Rk_Checks: 4 Rk_Check_What: ${Rk_Check_What} rkCheck: ${rkCheck} rkTemp: ${rkTemp} \agLine#: ${Macro.CurLine}
        /if (${DebugRk}) /echo \atDEBUG Spell_Rk_Checks: Exit \agLine#: ${Macro.CurLine}
        |/varset DebugRk 0
    /return ${rkCheck}
| -------------------------------------------------------------------------------------
| SUB: Check cursor
| -------------------------------------------------------------------------------------           
    Sub CheckCursor
        :inventory
            /autoinventory
            /delay 10
        /if (${Cursor.ID}) /goto :inventory
    /return      
| -------------------------------------------------------------------------------------
| SUB: Event LeftGroup
| ------------------------------------------------------------------------------------- 
    Sub Event_LeftGroup(Line,LGName)
        /if (${GMailEvents.Find[leftgroup]}) /call GmailSend "${LGName} has left the group."
        /doevents flush LeftGroup
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind IVU
| ------------------------------------------------------------------------------------- 
    Sub Bind_IVU(IVUid)
	/if (!${Me.Book[Invisibility versus Undead]}) /return
        /if (!${IVUid}) {
		/echo no id supplied in IVU, returning
		/return
	}
        /echo time to ivu on ${Spawn[${IVUid}]}
	/tar id ${IVUid}
	/delay 2s ${Target.ID}==${IVUid}
	/delay 5s ${Target.BuffsPopulated}==TRUE
:checkland
	/if (${Target.Buff[Invisibility versus Undead].ID}) {
		/echo ${Spawn[${IVUid}]} is IVUED!
	} else {
		/casting "Invisibility versus Undead"
		/call WaitCast
		/delay 1
		/goto :checkland
	}
	/echo leaving Bind_IVU
/return

| -------------------------------------------------------------------------------------
| SUB: Bind ZoneInfo
| ------------------------------------------------------------------------------------- 
    Sub Bind_ZoneInfo
        /declare LineInfo string local
        /echo -------------------------------------------------------------------------
        /echo MezImmune: ${Ini[${InfoFileName},${ZoneName},MezImmune]}
        /echo MobsToPull: ${Ini[${InfoFileName},${ZoneName},MobsTopull]}
        /echo MobsToIgnore: ${Ini[${InfoFileName},${ZoneName},MobsToIgnore]}
        /echo MobsToBurn: ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
        /echo -------------------------------------------------------------------------
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind WriteMySpell
| ------------------------------------------------------------------------------------- 
    Sub Bind_WriteMySpells
        /declare i int local
            /for i 1 to 13
            /echo Gem ${i}: ${Me.Gem[${i}].Name}
            /ini "${IniFileName}" "MySpells" "Gem${i}" "${Me.Gem[${i}].Name}"
        /next i
    /return  
| -------------------------------------------------------------------------------------
| SUB: Bind MemMySpells
| ------------------------------------------------------------------------------------- 
   Sub Bind_MemMySpells(Message)
        /declare temppCharName          string      local
        /declare pCharName              string      local ${Message}
        /declare tempIniFileName        string      local
        /declare pKV                    string      local
        /declare i                      int         local
        /declare ii                     int         local
        /declare pGem                   string      local       
        /declare tempSpellName          string      local 
        
        /if (${Debug}) /echo \atDEBUG MemMySpells: Enter \agLine#: ${Macro.CurLine}
        /if (!${pCharName.Length} || ${pCharName.Equal[null]}) {
           /varset temppCharName ${Me.CleanName}
        } else {
           /varset temppCharName ${pCharName}
        }
        /if (${Ini[${MacroName}_${EverQuest.Server}_${temppCharName}.ini,General,KissAssistVer].Length}) {
            /varset tempIniFileName ${MacroName}_${EverQuest.Server}_${temppCharName}.ini
            /echo 1 Server Name ini file detected using ${tempIniFileName}
        } else /if (${Ini[Kissassist_${EverQuest.Server}_${Me}_${Me.Level}.ini,General,KissAssistVer].Length}) {
            /varset tempIniFileName Kissassist_${EverQuest.Server}_${Me}_${Me.Level}.ini
            /echo 2 Server Name ini file detected using ${tempIniFileName}
        } else {
	    /echo 3 Server Name ini file detected using ${tempIniFileName}
            /varset tempIniFileName ${MacroName}_${temppCharName}.ini
        }
        /varset pKV ${Ini[${tempIniFileName},General,KissAssistVer]}
        /if (${Int[${pKV}]}==0) {
           /echo Invalid INI file: ${tempIniFileName} for memorizing spells. Returning.
           /return
        }
        /varset pKV ${Ini[${tempIniFileName},"MySpells",Gem1]}
        /if (${Int[${pKV.Length}]}==0) {
           /echo No Spells found in INI file: ${tempIniFileName}. Use /writespells and try again. Returning.
           /return
        }
        /for i 1 to 13
            /varset pGem ${Ini[${tempIniFileName},"MySpells",Gem${i}]}
            /if (${pGem.Length} && ${pGem.NotEqual[null]}) {
                /if (${pGem.Find[ Rk.]}) {
                   /varset tempSpellName ${pGem.Left[${Math.Calc[${pGem.Find[ Rk.]}-1]}]} 
                } else {
                   /varset tempSpellName ${pGem} 
                }
                /varset pGem ${Spell[${tempSpellName}].RankName}
                /if (${Me.Book[${pGem}]}) {
                    /if (${Int[${Me.Gem[${pGem}]}]}>0 && ${Int[${Me.Gem[${pGem}]}]}!=${i}) {
                        /varcalc ii ${Int[${Me.Gem[${pGem}]}]}-1
                        /notify CastSpellWnd CSPW_Spell${ii} rightmouseup
                        /delay 20 ${Int[${Me.Gem[${pGem}]}]}==0
                    }
                    /if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${pGem}]}) {
                        /echo Meming ${pGem} in slot ${i} in Bind_MemMySpells
                        /memspell ${i} "${pGem}"
                        /delay 90 ${Me.Gem[${i}].Name.Equal[${pGem}]}
                    }
                } else {
                    /echo Could Not find the spell ${pGem} in your spell book.
                }
            }
        /next i   
    /if (${Debug}) /echo \atDEBUG MemMySpells: Exit \agLine#: ${Macro.CurLine}
    /return
| -------------------------------------------------------------------------------------
| SUB: MemSpell
| ------------------------------------------------------------------------------------- 
   Sub MemSpell(pGem, int i, int ForceIt)
       /if (${Int[${pGem.Length}]}==0 || ${pGem.Equal[null]} || ${i}==0) /return
       /if (${Int[${Me.Gem[${pGem}]}]}>0 && !${ForceIt}) /return
       /if (${ForceIt}) {
           /if (${Int[${Me.Gem[${pGem}]}]}>0 && ${i}!=${ForceIt}) {
                /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${ForceIt}-1]}]} rightmouseup
                /delay 20 ${Int[${Me.Gem[${i}].ID}]}==0
           }
       }
        /if (${Me.Book[${pGem}]}) {
            /if (${Int[${Me.Gem[${i}].ID}]}>0) {
                /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${i}-1]}]} rightmouseup
                /delay 20 ${Int[${Me.Gem[${i}].ID}]}==0
            }
            /if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${pGem}]}) {
                /echo Meming ${pGem} in slot ${i} in MemSpell
                /memspell ${i} "${pGem}"
                /delay 90 ${Me.Gem[${i}].Name.Equal[${pGem}]}
            }
        } else {
            /echo Could Not find the spell ${pGem} in your spell book.
        }
        /if (${Window[SpellBookWnd].Open}) /windowstate spellbookwnd close
   /return
| -------------------------------------------------------------------------------------
| SUB: Bind Parse
| -------------------------------------------------------------------------------------
    Sub Bind_Parse(TimeToParse)
        /if (!${Defined[ParseDPS]}) /declare ParseDPS     timer       outer       0
        /echo Parsing combat for ${TimeToParse} seconds
        /tar npc dummy
        /delay 10 ${Target.ID}
        /varset MyTargetID ${Target.ID}
        /varset MyTargetName ${Target.CleanName}
        /varset ParseDPS ${TimeToParse}s
        /call Combat
        /call CombatReset
        /target clear
        /attack off
        /stick off
        /endmacro
    /return
| -------------------------------------------------------------------------------------
| Task Code
| -------------------------------------------------------------------------------------
| SUB: Unmount
| -------------------------------------------------------------------------------------
    Sub Event_KTDismount
	/echo Turning off Mounts.
        /if (${MountOn}) {
		/varset MountOn 0
	}
        /if (${Me.Mount.ID}) /dismount
    /return
|-----------------------------------------------------------------------------
| SUB: Target NPC
| ----------------------------------------------------------------------------        
    Sub Event_KTTarget(Line, NPCName)
        /declare ZDist float local
        /echo Targeting ${NPCName}
        /if (${NPCName.Equal[null]}) {
            /echo NPC Name is Null. Check your variables.
            /return FALSE
        }
        /if (!${Spawn[npc ${NPCName}].ID}) {
            /echo ${NPCName}? You must be in the wrong palce, no one here by that name
            /return FALSE
        }
        /target id ${Spawn[${NPCName}].ID}
        /delay 3s ${Target.ID}==${Spawn[${NPCName}].ID}
        /if (${Target.Distance}>15 && ${Target.Distance}<50) {
            /moveto id  ${Spawn[${NPCName}].ID}
            /delay 250 ${MoveTo.Stopped}
        }
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /call ZAxisCheck ${ZDist} 4.1
        /echo face 12
	/face nolook
        /delay 10
        /return TRUE
|-----------------------------------------------------------------------------
| SUB: KTHail
| ----------------------------------------------------------------------------    
    Sub Event_KTHail(Line, KTMobID)
        /tar id ${Spawn[npc ${KTMobID}].ID}
        /delay ${Math.Rand[20]}
        /keypress h
        /doevents flush KTaskSay
    /return            
|-----------------------------------------------------------------------------
| SUB: KTSay
| ----------------------------------------------------------------------------    
    Sub Event_KTSay(Line, KTSayWhat)
        /delay ${Math.Rand[20]}
        /say ${KTSayWhat}
        /delay 10
        /doevents flush KTaskSay
    /return
|-----------------------------------------------------------------------------
| SUB: TaskDoorTarget
| ----------------------------------------------------------------------------    
    Sub Event_KTDoorClick(Line, int KTDoorID)
    /declare KTCDTimer timer local 10s
    /echo DoorID: ${KTDoorID}
        /delay 10
        /keypress FIRST_PERSON_CAMERA hold
        /delay 2
        /keypress FIRST_PERSON_CAMERA
        /delay 10
        /if (${Target.ID}) /squelch /tar clear
        /delay 3
        :retrydoortarget
        /echo target door id ${KTDoorID}
        /if (${KTDoorID}) {
            /doortarget id ${KTDoorID}
        } else /doortarget 
        /delay 3
        /echo ${DoorTarget.Name}
        /if (!${Switch.ID}) {
            /if (${KTCDTimer}) /goto :retrydoortarget
        }
	/echo face the door
        /face door
        /delay 3
        :retryopendoor
        /if (${DoorTarget.Distance}<=70)  {
        /echo Moving to Door 
            /if (${DoorTarget.Distance}>15) {
                /keypress forward hold
                /delay 3
                /keypress forward
            } else /if (${DoorTarget.Distance}<10) {
                /keypress back hold   
                /delay 1
                /keypress back
            }
        }
        /if (!${Switch.Open} || ${DoorTarget.Name.Length}) {
		/echo facing a door
            /face door
            /delay 3
            /echo clicking door
            /click left door
            /delay 1s
            /if (${KTCDTimer}) /goto :retryopendoor
        }
        /if (${Window[largedialogwindow].Open}) {
            /notify largedialogwindow LDW_YesButton leftmouseup
        }
        /doevents flush KTDoorClick
    /return
|-----------------------------------------------------------------------------
| SUB: KTInvite
| ----------------------------------------------------------------------------       
    Sub Event_KTInvite
    /declare i int 
    /declare WhoToInvite ${SpawnCount[pc radius 75 guild]}
    /alert clear 6 
    /squelch /alert add 6 ${Me}
    /for i 1 to ${WhoToInvite}
        /target id ${NearestSpawn[radius 75 pc guild noalert 6].ID}
        /delay 10
        /invite
        /delay 20
        /bct ${Target.CleanName} //invite
        /delay 10 
        /squelch /alert add 6 id ${Target.ID}
    /next i
    /return
|-----------------------------------------------------------------------------
| SUB: AssignLooter
| ----------------------------------------------------------------------------       
    Sub AssignLooter
        /if (${Select[${Me},${Group.Leader}]}==0) /return
        /if (${LooterAssigned}) /return
        /if (${Group}<=0) /return
        /if (${Group.MasterLooter.ID}>=1) /return
        /if (${Debug}) /echo \atDEBUG Sub AssignLooter Enter \agLine#: ${Macro.CurLine}
        /declare k int local
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare IniIDCount int local ${Math.Calc[${IniIDList.Count[|]}-1]}
        | If I am group leader set Main Looter Tag for Group
        /if (${Select[${Me},${Group.Leader}]}) { 
            /if (${Debug}) /echo \atDEBUG AssignLooter: /echo I am group Leader \agLine#: ${Macro.CurLine}
            |Assign myself as MainLooter if LootOn=1
            /if (${LootOn}) {
            /if (${Debug}) /echo \atDEBUG AssignLooter: /echo I am the looter \agLine#: ${Macro.CurLine}
                /if (${Group.MasterLooter.Name.NotEqual[${Me}]} && ${Group.MasterLooter.Name.Length}) {
                    /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                    /delay 30 !${Group.MasterLooter.Name.Length}
                    /call AssignGroupRole set "${Group.MainAssist.Name}" 5
                    /call BroadCast ${IRCOn} ${EQBCOn} r "Assigning ${Me} as Master Looter in Group Window"
                    /varset LooterAssigned 1
                    /return
                }
            }
            /if (${LootOn}==0) {
                /if (${Debug}) /echo \atDEBUG AssignLooter: Looking for looter \agLine#: ${Macro.CurLine}
                /for k 1 to ${IniIDCount}
                    /if (${Debug}) /echo \atDEBUG AssignLooter: ${Spawn[${IniIDList.Arg[${k},|]}].ID} ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"AmILooting"]}  ${Spawn[${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} ${Spawn[id ${IniIDList.Arg[${k},|]} group].ID} \agLine#: ${Macro.CurLine}
                    | If toon is not the zone or not a PC skip to next ID
                    /if (!${Spawn[id ${IniIDList.Arg[${k},|]}].ID} || ${Spawn[id ${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} || !${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"AmILooting"]}) /goto :NextLooterCheck
                    /if (${Spawn[id ${IniIDList.Arg[${k},|]} pc group].ID}) {
                        | If Looter is someone else than who its suppose to be unset Group tag
                        /if (${Group.MasterLooter.Name.Length} && ${Group.MasterLooter.Name.NotEqual[${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName}]}) /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                        /delay 30 !${Group.MasterLooter.Name.Length}
                        /call AssignGroupRole set "${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName}" 5
                        /call BroadCast ${IRCOn} ${EQBCOn} r "LOOT: Assigning ${Spawn[id ${IniIDList.Arg[${k},|]} group pc].CleanName} as Master Looter in Group Window"
                        /varset LooterAssigned 1
                        /return
                    }
                :NextLooterCheck
                /next k
            }
        }
        /if (${Debug}) /echo \atDEBUG Sub AssignLooter Leave \agLine#: ${Macro.CurLine}
    /return    
| ----------------------------------------------------------------------------
| SUB: GmailParse
| ----------------------------------------------------------------------------
    Sub GmailIniParse
    /declare i int local 0
    /declare GMailEventCheck string local
        /for i 1 to ${GMail.Size}
            /varset GMailEventCheck ${Ini[${IniFileName},Gmail,Gmail${i}]}
            /if (${GMailEventCheck.Length} && ${GMailEventCheck.NotEqual[null]}) {
                /if (${Select[${GMailEventCheck},Dead,GM,Level,Named,Leftgroup]}) {
                    /echo ${i}. ${GMailEventCheck}
                    /if (${GMailEvents.Length}) {
                        /varset GMailEvents ${GMailEvents},${GMailEventCheck}
                    } else {
                        /varset GMailEvents ${GMailEventCheck}
                    }
                }
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: GmailSend
| ----------------------------------------------------------------------------
    Sub GmailSend(GMessage)
    |Goofy time shit because Gmail fails if any entry has a colon : in it. 
        /declare GTime string local 
        /declare GtimeHour string local ${Time.Hour}
        /declare AMPM string local am
        /if (${Time.Hour}>=13) {
            /varset GtimeHour ${Int[${Math.Calc[${Time.Hour}-12]}]}
            /varset AMPM pm
        }    
        /varset GTime Date.${Time.Date} Time.${GtimeHour}.${Time.Minute} ${AMPM}
        | Ghetto fix for buffer overflow until MQ2GMail is fixed
        /squelch /plugin MQ2Gmail unload 
        /squelch /plugin MQ2Gmail
        /gmail "Kiss-${EverQuest.Server}-${Me.CleanName}" "${GTime} - ${GMessage}"
        /echo GMAIL just sent "Kiss-${EverQuest.Server}-${Me.CleanName}" "${GTime} - ${GMessage}"
        /varcalc GSent ${GSent}+1
        /if (${GSent}==5) {
            /varset GSent 0
        }
        /delay 10
    /return    
| ----------------------------------------------------------------------------
| SUB: Roguestuff
| ----------------------------------------------------------------------------
    Sub Roguestuff
        /if (${Me.Class.Name.Equal[Rogue]}) {
			/if (!${Me.Combat} && ${AutoHide}) {
				/if (${Me.AbilityReady[hide]} && ${Me.AbilityReady[sneak]}) {
					/doability hide
               		/doability sneak
				}
			}
		}
    /return
| ----------------------------------------------------------------------------
| SUB: LoadSpellSet
| ----------------------------------------------------------------------------
    Sub LoadSpellSet
    
    /declare GemNum      int local
    /declare ValidSpells int local 0
        
    /if (${Debug}) /echo \atDEBUG Sub LoadSpellSet LoadSpellSet=(${LoadSpellSet}) \agLine#: ${Macro.CurLine}
    /if (${LoadSpellSet}==1) {
        /if (${Debug}) /echo \atDEBUG Sub LoadSpellSet SpellSetName=(${SpellSetName}) \agLine#: ${Macro.CurLine}
        /echo Memming spellset (${SpellSetName}).
        /memspellset ${SpellSetName}    
    } else {       
        |---Test to see if we have MySpells section defined in INI or not.
        /for GemNum 1 to 13
            /call LoadIni MySpells Gem${GemNum} string NULL
            /if (${Gem${GemNum}.Length} && ${Gem${GemNum}.NotEqual[NULL]}) {
                |-- We have found a good spell defined, one good spell is all it takes to be a valid MySpells config.
                /varset ValidSpells 1
            }
        /next GemNum 
        /if (${LoadSpellSet}==2 && ${ValidSpells}==0) /echo You have no valid spells defined in your ini file [MySpells], load your spells now and do a /writespells command while in KissAsssist.
        /if (${LoadSpellSet}==2 && ${ValidSpells}==1) /call Bind_MemMySpells ${Me.CleanName}
    }
    |-- If we called this routine, make sure we update values for ReMemMiscGem and ReMemMiscGemLW since they might have changed after spellset load.
    /varset ReMemMiscGem ${Me.Gem[${MiscGem}].Name}
    /varset ReMemMiscGemLW ${Me.Gem[${MiscGemLW}].Name}
    
    /return    
| ----------------------------------------------------------------------------
| SUB: CheckTargetBuffs
| ----------------------------------------------------------------------------
    Sub CheckTargetBuffs(int TWtargetID, Checkbuff)
        /echo ${TWtargetID} ${Checkbuff}
        /if (!${Checkbuff.Length}) /return
        /declare i int local
        /declare TWBuff string local
        /declare HasBuff string local
        /if (!${Defined[TWIDTimer${TWtargetID}]}) /declare TWIDTimer${TWtargetID} timer outer 0
        /if (${TWIDTimer${TWtargetID}}==0) {
            /target id ${TWtargetID}
            /delay 10 ${Target.ID}
            /for i 0 to 50
                /varset TWBuff ${Target.Buff[${i}].Name} 
                /if (${TWBuff.Length}) {
                    /echo DEBUG WriteBuffs: ${i}-${TWBuff}
                    /varset TWbufflist ${TWbufflist}|${TWBuff}
                }
            /next i
        }
        /if (${TWbufflist.Find[${Checkbuff}]}) {
            /varset HasBuff TRUE
        } else {
            /varset HasBuff FALSE
        }        
        /echo ${TWbufflist}
    /return ${HasBuff}    
| ----------------------------------------------------------------------------
| SUB: Set Window Title Buffs
| ----------------------------------------------------------------------------    
    Sub WinTitle
	/if (${TheWinTitle.NotEqual[NULL]}) {
        	/SetWinTitle ${TheWinTitle}
	}
	/return    
        
    Sub AssassinAttack
	/declare Daggergash string local
	/varset Daggergash ${Spell[${RogueTimerEight}].RankName}
            /if (${Me.AbilityReady[hide]} && ${Me.AbilityReady[sneak]} && ${Me.AbilityReady[backstab]} && ${Me.CombatAbilityReady[${Daggergash}]} && ${Spell[${Daggergash}].EnduranceCost} < ${Me.Endurance}) {
                /echo Im going to ${Daggergash} ${Target}!
		/if (${Me.ActiveDisc.ID}) /stopdisc

		/attack off
                /target id ${MyTargetID}
                /stick 5 id ${MyTargetID} behind
                /delay 10
                /doability hide
                /doability sneak
                /delay 10

                /disc ${Me.CombatAbility[${Daggergash}]}
                /delay 15
                /doability backstab
            }
        /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs
| ----------------------------------------------------------------------------
    Sub WriteBuffs
        /if (${WriteBuffsTimer} || !${Redguides} || ${AggroTargetID}) /return
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffs Enter \agLine#: ${Macro.CurLine}
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Blockedbuffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs
        /ini "KissAssist_Buffs.ini" "${Me.ID}" AmILooting ${LootOn}
        /ini "KissAssist_Buffs.ini" "${Me.ID}" MyRole ${Role}
        | Write all current buffs to Kissassist_Buffs.ini file
        /for i 0 to 40
            /if (${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip.Find[(]}) {
                /varset BuffList ${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip.Arg[1,(].Left[-1]}
            } else {
                /varset BuffList ${Window[BuffWindow].Child[BW_Buff${i}_Button].Child[Buff${i}].Tooltip}
            }
            /if (${BuffList.Length}) {
                /if (${Debug}) /echo \atDEBUG WriteBuffs: ${i}-${BuffList} \agLine#: ${Macro.CurLine}
                /if (${BuffList.Find[:Permanent]}>1) /varset BuffList ${BuffList.Left[${Math.Calc[${BuffList.Find[:Permanent]}-1]}]}
                /varset Writebufflist ${Writebufflist}|${BuffList}
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs "${Writebufflist}"
        /delay 15
        | Open Blocked Buffs window temporarily to read blocked buffs
        /if (!${Window[BlockedBuffWnd].Open} && !${BBWindowOpen}) {
            /windowstate BlockedBuffWnd open
            /varset BBWindowOpen 120m
            /delay 10
        }
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 0 to 39
            /varset Blockedbuff ${Window[BlockedBuffWnd].Child[BW_BLOCKEDBUFF${k}_Button].Child[BBuff${k}].Tooltip}
            /if (${Blockedbuff.Length}) {
                /varset Blockedbufflist ${Blockedbufflist}|${Blockedbuff}
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedBuffWnd].Open}) /windowstate BlockedBuffWnd close
        /varset WriteBuffsTimer 30s
        /if (${DebugBuffs}) /echo \atDEBUGBUFFS WriteBuffs Leave \agLine#: ${Macro.CurLine}
    /return

Sub GetHostilesOnXTarget
	/declare hostilecount int local 0
	/declare i int local
	/for i 1 to 13
            /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.Equal[NPC]}) {
                /varcalc hostilecount ${hostilecount}+1 
            }
       /next i
/return ${hostilecount}

Sub SmartMerc
	/if (!${MercOn}) /return
	/if (${Mercenary.State.Equal[Active]} && ${Mercenary.Class.Name.Equal[Wizard]} && ${Me.Subscription.Equal[GOLD]}) {
		/call GetHostilesOnXTarget
		/if (${Macro.Return}!=0) {
			/if (${Bool[${Me.GroupAssistTarget.ID}]}==TRUE && ${Spawn[${Me.GroupAssistTarget.ID}].Type.Equal[NPC]} && ${Spawn[${Me.GroupAssistTarget.ID}].PctHPs}<=90) {
				/if (${Mercenary.Stance.NotEqual[Burn]}) {
					/call BroadCast ${IRCOn} ${EQBCOn} t "I'm using SmartMerc so telling merc to burn"
					/stance burn
				}
			} else /if (${Mercenary.Stance.NotEqual[Balanced]}) {
				/call BroadCast ${IRCOn} ${EQBCOn} t "I'm using SmartMerc so telling merc to balance (1)"
				/stance balanced
			}
		} else /if (${Mercenary.Stance.NotEqual[Balanced]}) {
				/call BroadCast ${IRCOn} ${EQBCOn} t "I'm using SmartMerc so telling merc to balance (2)"
				/stance balanced
		}
	}
/return
